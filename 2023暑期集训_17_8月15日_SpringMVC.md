# 2023年8月15日

### `<url-pattern>`中的`/ ` 和  `/* `区别

`/*` 是拦截所有请求

`/`是拦截`.jsp`以外的所有请求

## SpringMVC

这是一个封装了Servlet的框架，它能够接收请求，返回响应

搭建步骤：

1. 创建一个Maven项目，添加框架的支持，选择springMVC
2. 在pom.xml中添加spring-webmvc和servlet的依赖
3. 在web.xml中将`<url-pattern>`修改为`/`，并在请求分发器的`<servlet>`添加初始化参数指向spring配置文件（dispatcher-servlet.xml）
4. 修改spring配置文件，添加扫描器扫描控制器所在的包
5. 修改spring配置文件，添加视图解析器，指向返回页面的前缀和后缀
6. 在控制器类中添加@Controller注解，方法上添加@RequestMapping("请求名")表示接收指定的请求，返回值为响应的页面文件名
7. 启动Tomcat，完成测试。

pom.xml中添加依赖：

~~~xml
        <!-- SpringMVC -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.6</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
~~~

web.xml中进行修改

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
    </context-param>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
         <!-- 添加了4行 -->
        <init-param>      
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/dispatcher-servlet.xml</param-value>
        </init-param>
        
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>  <!-- 修改了 -->
    </servlet-mapping>
</web-app>
~~~

修改dispatcher-servlet.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/context
      					  https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 使用了扫描器 -->
    <context:component-scan base-package="com.iweb.test.controller"></context:component-scan>
</beans>
~~~

被扫描的类

```java
package com.iweb.test.controller;
import org.springframework.stereotype.Controller;

@Controller
public class HelloSpringMVC {

    @RequestMapping("/hellospringmvc")
    public String hello() {
        System.out.println("来了个请求！");
        return "hello";
    }
```

在dispatcher-servlet.xml中加入视图解析器：

~~~xml
    <!-- 视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/jsp/"></property><!-- 前缀 -->
        <property name="suffix" value=".jsp"></property><!-- 后缀 -->
        <!-- 前缀后后缀中间缺少的，就是@Controller中return的字符串，例如HelloSpringMVC.java中的return "hello" -->
    </bean>
~~~

## ModelAndView

这是一个类，用来返回响应到指定页面，并且在request中携带数据

我们的控制器方法可以返回该类型

addObject("键"，"值") ---- 存放数据到request中

setViewName() ---- 设置返回页面的路径

```java
@RequestMapping("/test2")
public ModelAndView test(ModelAndView mv) {
    System.out.println("来了个ModelAndView请求！");
    mv.addObject("myKey","myValue");
    mv.setViewName("hello");
    return mv;
}
//前端使用${requestScope.myKey}来打印
```

在SpringMVC的控制器方法中，我们可以定义HttpSession和HttpRequestRequest参数，由SpringMVC传递给我们使用

```java
@RequestMapping("/test2")
public ModelAndView test(ModelAndView mv, HttpSession session,
                         HttpServletRequest request) {
    System.out.println("来了个ModelAndView请求！");
    mv.addObject("myKey", "myValue");
    mv.setViewName("hello");
    session.setAttribute("sessionKey", "sessionValue");
    request.setAttribute("requestKey","requestValue");
    ServletContext application = request.getServletContext();
    application.setAttribute("applicationKey","applicationValue");
    return mv;
}
```

```jsp
${requestScope.myKey}
<br/>
${sessionScope.sessionKey}
<br/>
${requestScope.requestKey}
<br/>
${applicationScope.applicationKey}
```

在@RequestMapping注解中，

method = RequestMethod.GET表示只接受get请求
method = RequestMethod.POST表示只接受post请求

## @RequestParam

接收请求参数

```java
    @RequestMapping(value = "/test2", method = RequestMethod.GET)
    public ModelAndView func(ModelAndView mv, @RequestParam String username, @RequestParam String password) {
        mv.setViewName("world");//去world.jsp prefix是/jsp/  suffix是.jsp
        System.out.println("username = " + username);
        System.out.println("password = " + password);
        return mv;
    }
```

## CharacterEncodingFilter过滤器

完成参数转码，解决中文乱码的问题。

在web.xml中

```xml
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>utf-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## @PathVariable

可以绑定url中的占位符到控制器方法的形参中，占位符部分使用{参数名}表示

```jsp
<a href="<%=request.getContextPath()%>/test3/1001">test3</a>
```

```java
@RequestMapping("/test3/{id}")
public String test3(@PathVariable("id") String id){
    System.out.println(id);
    return "hello";//跳转到hello.jsp
}
```

## Model 

这时ModelAndView中的Model，它可以绑定数据到request中

addAttribute("键"，"值") ---- 将键值对存入request中。

```java
@RequestMapping("/test3/{id}")
public String test3(@PathVariable("id") String id, Model model) {
    System.out.println(id);
    model.addAttribute("modelKey", "modelValue");
    return "hello";//跳转到hello.jsp
}
```

## @ModelAttribute

可以把一个对象绑定到Model中

```java
@RequestMapping("/test4")
public String test4(@ModelAttribute User user){
    user.setUsername("xunyi");
    user.setFullname("xunyi lannister");
    user.setPassword("213");
    return "hello";
}
```

```jsp
${requestScope.user.fullname}
```

@ModelAttribute可以绑定同名参数到某个对象的同名属性中

```java
@RequestMapping("/test5")
public String test5(@ModelAttribute User user){
    return "hello";
}
```

# 2023年8月16日

## SpringMVC中对静态文件的放行

在web.xml中，请求分发器配置了斜杠,他能够拦截`.jsp`以外的所有请求，当我们需要导入静态文件的时候，它也会拦截，我们需要对静态文件放行，具体操作：

添加<servlet-mapping>里面包含<servlet-name>为default，<url-pattern>为*.后缀

具体的某个后缀的静态文件就会被放行

```xml
<!-- 放行*.js -->
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.js</url-pattern>
</servlet-mapping>
```

新版：检测用户名是否存在

```jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2023-08-16/0016
  Time: 8:47
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>

    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#username").change(function () {
                var username = $(this).val();
                var jsonObj = {
                    "username": username
                };
                var url = "<%=request.getContextPath()%>/checkedUser"
                $.post(url, jsonObj, function (data) {
                    var resultObj = JSON.parse(data);
                    if (resultObj.flag == 1) {
                        $("#message").css("color", "green").html("恭喜，用户名可用");
                        $("#sub").prop("disabled", false);
                    } else {
                        $("#message").css("color", "red").html("对不起，用户名已存在");
                        $("#sub").prop("disabled", true);//提交按钮置灰
                    }
                })
            })
        })
    </script>
</head>
<body>
<form action="<%=request.getContextPath()%>/test5" method="post">
    username<input type="text" name="username" value="" id="username"/>
    <span id="message"></span>
    <br/>
    password<input type="text" name="password" value=""/>
    <br/>
    fullname<input type="text" name="fullname" value=""/>
    <br/>
    <input type="submit" value="提交" id="sub"/>
</form>
</body>
</html>

```

```java
package com.iweb.test.controller;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Controller
public class CheckedUsername {


    @RequestMapping("/checkedUser")
    public void checkedUser(HttpServletResponse response, @RequestParam String username) throws IOException {
        List<String> users = new ArrayList<>();
        users.add("tom");
        users.add("jerry");
        String result = "";
        if (users.contains(username)) {
            result = "{\"flag\":0}";
        } else {
            result = "{\"flag\":1}";
        }
        System.out.println("校验用户名是否存在");
        response.getWriter().print(result);

    }

}
```

## SpringMVC中的跳转

1. 转发到页面：默认返回的字符串，需要拼上前缀后缀。

2. 转发到下一个控制器：返回的字符串格式：“forward:/url地址”

   ```java
   @RequestMapping("forwardToController1")
   public String next1(){
       System.out.println("即将请求转发到下一个控制器");
       return "forward:/next";//不会去读前缀后缀
   }
   ```

   ```java
   package com.iweb.test.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.RequestMapping;
   
   @Controller
   public class NextController {
   
       @RequestMapping("/next")
       public String next() {
           System.out.println("我是下一个控制器");
           return "hello";
       }
   
   }
   ```

   ```jsp
   <a href="<%=request.getContextPath()%>/forwardToController1">转发去下一个控制器</a>
   ```

用ModelAndView的写法：

```java
@RequestMapping("/forwardToController1")
public ModelAndView next2(ModelAndView mv){
    System.out.println("即将请求转发到下一个控制器");
    mv.setViewName("forward:/next");
    return mv;
}
```

3 、重定向到下一个页面：返回的字符串格式："redirect:url地址" ，支持String和ModelAndView的返回值

```java
    @RequestMapping("/redirectToPage")
    public ModelAndView next3(ModelAndView mv){
        System.out.println("即将重定向到下一个页面");
        mv.setViewName("redirect:/jsp/hello.jsp");
        return mv;
    }
```

4、重定向到下一个控制器

```java
@RequestMapping("/redirectToController")
public ModelAndView next4(ModelAndView mv){
    System.out.println("即将重定向到下一个控制器");
    mv.setViewName("redirect:/next");
    return mv;
}
```

## 控制器之间传递数据

1、使用session

第一个控制器：

```java
@RequestMapping("/redirectToController")
public ModelAndView next4(ModelAndView mv,HttpSession session){
    System.out.println("即将重定向到下一个控制器");
    session.setAttribute("message","ni hao");
    mv.setViewName("redirect:/next");
    return mv;
}
```

第二个控制器：

```java
@RequestMapping("/next")
public String next(HttpSession session) {
    System.out.println("我是下一个控制器");
    System.out.println(session.getAttribute("message"));
    session.removeAttribute("message");
    return "hello";
}
```

2、使用RedirectAttributes用于在重定向的时候传递数据

`addFlashAttribute("键"，"值") `---- 用来存值

在接收端通过`@ModelAttribute( "键") ` 来接收数据

同时在spring容器种添加` <mvc:annotation-driven`>使其生效

了解即可，做项目基本不用