---
title:  笔记_001_java
tag: 
	- java
categories: 
	- java
---

# 第一天

## 面向对象

一个类的某个对象是另外一个类的方法的参数
把现实生活的事物以及关系，抽象成类，通过继承，实现，组合的方式把万事万物都给容纳了。实现了对现实世界的数学建模

举个例子： 想吃蛋炒饭
面向过程：自己去买鸡蛋，米饭，起锅浇油炒饭，最后吃到
面向对象：对老妈喊我要吃蛋炒饭，根本不需要知道怎么做，饭来张口就能吃到，在这里，老妈所做的事是面向过程的

- 面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。
- 面向对象是模型化的，只需抽象出一个类，这是一个封闭的盒子，在这里我们拥有数据也拥有解决问题的方法，需要什么功能直接使用就可以了，至于这个功能是如何实现的，我们不必知道

面向对象是为了模拟现实：就好比想吃饭的只需要知道怎么咀嚼，而不需要知道怎么下厨

### 面向对象的三大特性
1、封装
隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
2、继承
子类从父类继承方法，使得子类具有父类相同的行为。继承是多态的前提
3、多态
父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。

和类同名的方法——构造方法

### java标识符命名规则：

- 类名：首字母大写
- 变量名和方法名：首字母小写
  - 如果有多个单词，后面每个单词首字母大写（驼峰命名法）


### java代码的编写

1. 先有类后有对象

   - 我们使用class关键词定义一个类

   - 类：

     - 成员变量： 类型 变量名 = 初始值；

     - 方法： 返回值类型 方法名（参数1，参数2...）{

       方法体；

       }

  2. 每一句话都以分号结尾

  3. 
     | 基本数据类型(值类型) |  缺省值  |
     | :------------------: | :------: |
     | byte short int long  |    0     |
     |     float double     |   0.0    |
     |         char         | '\u0000' |
     |       boolean        |  false   |

     

 4. 引用类型默认值： null

 5. 定义多个变量 ： double x,y,z;

### 引用类型

如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表着一个引用。

~~~~java
String s; //创建一个引用，引用可以独立存在，并不一定需要和一个对象相关联
String str = new String("123");//通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。
~~~~

- 强引用

  ~~~~java
  //Java中默认声明的就是强引用，比如：
  Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收
  obj = null;  //手动置null
  //只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式地将强引用赋值为null，这样一来，JVM就可以适时的回收对象了
  ~~~~

- 软引用

  ~~~~java
  //软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等
  ~~~~

- 弱引用
- 虚引用

### 构造方法 

用来创建对象的方法，被new关键字调用；其方法名与类同名；

~~~~java
//格式
类名 对象名 = new 类名(); //左边的对象存储一个来自堆的地址
~~~~

当我们不写构造方法，系统会自动提供默认无参构造方法；当我们自己手写时，系统就不会提供默认构造方法；构造方法没有返回值，前面也不能加void

手写有参构造方法时最好再配一个无参构造方法

手写有参构造方法时，往往利用传入的参数给当前对象赋属性值

~~~~java
public class Car{
	String brand;
    Car(String _brand)
    {
        brand = _brand;
}
    Car(){
        
    }
}
//调用
Car c = new Car("奥迪");
~~~~

### 内存解析

虚拟机在内存中识别数据来进行处理

内存被划分为5块：

- 栈：存放局部变量
- 堆：存放new出来的对象
- 方法区：存放人写的静态代码以及常量池
- 本地方法栈：与操作系统相关（仅了解）
- 程序计数器：与CPU相关（仅了解）

### 方法的重载

在一个类中，多个方法，方法名一样，参数不一样

参数不一样体现在要么参数的个数不一样，要么参数的类型不一样。在调用的时候，根据传入的参数，决定具体调用哪个方法。

构造方法也可以重载

### this

就是一个引用。它在当前对象的内部，存放的是当前对象的内存地址

我们可以通过 this.成员变量 来访问当前对象的成员变量；

还可以通过 this.方法来调用当前类的方法。

### static

1. static可以修饰成员变量，被static修饰的成员变量只有一份，它被当前类的所有对象共享；我们可以使用任一对象访问static的成员变量，也可以直接使用类名访问static的成员变量；static的成员变量往往可以用来计数。
2. static可以修饰方法，这样的方法叫作静态方法，静态方法可以被类名直接调用。静态方法种调用本类其他的静态方法，连类名也可以省略。静态方法种不能直接调用本类种其他非静态方法。

# 第二天

### 包

java中为了解决类名冲突的问题，引入了包的概念，包可以层层嵌套，同一个包下不允许有相同的类名；往往包名都是所在公司域名的倒写;

注意：同一个包下的类可以直接使用，前面不用加包名。

~~~~java
package 包名；//定义一个包
    //例如
    package com.iweb.test;
/////////////
import 全类名；//导入具体的某个包，然后再当前类中就可以直接使用（全类名：带有包名的类名）
    import com.iweb.test.Cat;//如导入包com.iweb.test中的Cat类
//注意：可以导入包.*  来使用该包下所有类
import com.iweb.test.*;
~~~~

包 java.lang 是唯一一个无需导入,所有包都可以使用其中的类的包。

## 问题：相同类名引入，如何使用？

### 答：遵循以下原则：

前置准备：

~~~~java
package com.a;
public class Test(){
    public int num1 = 1;
}
~~~~

~~~~java
package com.b;
public class Test(){
public int num2 = 2;
}
~~~~

1. 使用声明更具体的包的类

~~~~java
import com.a.*;
import com.b.Test:
//使用b中的Test类
~~~~

2. 导入包声明程度一样具体的——只能使用第一个，第二个直接报错

~~~~java
import com.a.Test;
import com.b.Test;
//只能使用a中的Test；
~~~~

3. 不同导入包都采用通配符声明——必须进行选择才可正常使用

~~~~java
import com.a.*;
import com.b.*;
public static void main(String[] args){
    com.a.Test a = new com.a.Test();//当写出这一行时，开头自动生成 import com.a.Test;
    Test b = new Test();
    //只能用a中的Test
}
~~~~

4. 主程序内采用完整包名新建一个对象，都可以使用

   ~~~~java
   public class Test3 {
       public static void main(String[] args) {
        
           com.a.Test a = new com.a.Test();
           com.b.Test b = new com.b.Test();
   
           System.out.println(a.num1);
           System.out.println(b.num2);
           //都能用
       }
   }
   ~~~~



### 继承

“xxx是一种xxx”  这句话说得通则两者存在继承关系

java只支持单继承，一个子类只能有一个父类

子类继承父类，子类就自动拥有了父类所有的属性和方法，子类还可以有自己新增的属性和方法

子类拥有父类的所有属性和方法，但是子类不能访问父类私有的属性和方法

语法：	class 子类名 extends 父类名

~~~~java
//例：学生类继承人类
public class Student extends Person{
    
}
~~~~

### 继承中的构造方法

1. 子类构造过程中必须先调用父类的构造方法来构造父类对象
2. 当子类中没有写明调用父类的哪个构造方法，则默认调用父类无参的构造方法
3. 我们在子类构造方法中，可以使用 super(参数列表) 来手动调用父类的某个指定的构造方法（注意：super(参数列表)必须写在方法第一行）
4. 如果没有手动调用，而父类中又没有无参的构造方法，则编译报错

### 访问控制符

用来修饰属性和方法

它们的作用范围：

|         | 同一个类 | 同一个包 | 子类 | 任何地方 |
| :-----: | :------: | :------: | :--: | :------: |
| private |    Y     |          |      |          |
|  不写   |    Y     |    Y     |      |          |
| protect |    Y     |    Y     |  Y   |          |
| public  |    Y     |    Y     |  Y   |    Y     |

对于class的修饰可以使用public或者不写，如果不写，只能在当前包中使用

### JavaBean

我们应该将Java中的实体封装成JavaBean，每一个成员变量都私有化，设置为private，针对每个成员变量都提供public 的 get方法来取值，public 的set方法来存值。JavaBean体现了Java面向对象的**封装性**

alt+ins ==> getter and setter 直接生成

### 方法的重写

父类和子类，子类对父类的方法进行重写时，方法名一样，返回值类型一样，参数也一样，根据调用者的类型来决定调用哪个方法

注意：在重写方法的时候可以添加@Override注解检查是否在重写；重写方法不能比被重写方法有更严格的访问权限；

### super

它是一个引用，它指向当前对象的父类对象，我们可以使用 super.成员变量 来访问父类的属性，我们可以使用 super.方法 来调用父类的方法

super(参数)来调用父类中某一个构造函数，调用super()必须写在子类构造方法的第一行，否则编译不通过



~~~~java
//我们可以使用this(参数列表)来调用本类其他构造方法来构造对象
package com.iweb.test2;

public class Person {

    String cardId;
    String name;
    String age;

    public Person(String cardId, String name, String age) {
        this.cardId = cardId;
        this.name = name;
        this.age = age;
    }

    public Person(String cardId) {
        this(cardId, "无名氏", "0");//给另外两个参数赋缺省值
    }

    public Person() {
        this("12313131", "无名氏", "0");//全部赋缺省值
    }
}

~~~~



### Object

这是所有类的根类，当某个类不继承任何类的时候，就相当于继承了Object，任何一个类都拥有并且可以使用Object类中的方法toString()——将当前对象以字符串的形式表现出来。Object中的toString()返回的是 全类名@哈希编码；我们可以自由的重写toString()来更好的描述当前对象。

### instanceof

对象名 instanceof 类名

判断一个类的对象是否是某个类的对象，返回一个boolean值

### “向下转型”和“向上转型”

父类引用可以指向其子类的对象，也就是说子类对象可以当做父类对象来用，这被称为“向上转型”

~~~~java
//父类Animal 	有方法run() 
//子类Cat 	重写方法run() 单独定义方法miaow()
Animal animal = new Cat();//声明的是父类，实际指向子类的一个对象
//注意：
//1. 向上转型后，子类单独定义的方法会丢失（父类并不知道子类定义的新属性与方法） animal.miaow();是错误的
//2. 父类引用可以指向子类对象，但是子类引用不能指向父类对象
//3. 如果子类中重写了父类的方法，那么调用这个方法的时候，将会调用子类中的方法
~~~~

我们可以将父类引用所指向的子类对象通过 (子类类型) 转为子类的类型，这被称为“向下转型”，目的是调用子类独有的方法;这种方法可扩展性好，防止甲方乱改方案。

~~~~java
package com.iweb.test;

//父类：动物类
public class Animal {
    String name;//动物名

    public Animal(String name) {
        this.name = name;
    }

    public void run() {
        System.out.println("会跑");
    }
}

//子类：猫咪类
 class Cat extends Animal {
    String eyesColor;  //猫咪瞳色
    
    public Cat(String name, String eyesColor) {
        super(name);
        this.eyesColor = eyesColor;
    }
    
    public void miaow() {
        System.out.println("喵喵叫");
    }
}
//测试类
 class ZTest {

    public static void main(String[] args) {

        Animal a = new Animal("动物");
        Cat c = new Cat("猫", "蓝色");

        f(a);//最终返回： 动物 该生物不是猫咪
        f(c);//最终返回： 猫 该生物是猫咪 猫 蓝色 喵喵叫

    }

    public static void f(Animal animal) {
        System.out.println(animal.name);

        if (animal instanceof Cat) { //该生物是猫咪 返回1
            System.out.println("该生物是猫咪");
            System.out.println(((Cat) animal).name); //((Cat) animal)即为向下转型
            System.out.println(((Cat) animal).eyesColor);
            ((Cat) animal).miaow();

        } else {
            System.out.println("该生物不是猫咪");
        }
    }
}
~~~~

## 第三天

### equals()方法

Object类的equals方法用来比较两个对象是否相等，它原生态的写法等同于“==”，只有当两个对象是同一对象时返回true；

我们应该按照自己的方式去重写equals()方法

~~~~java
//例题
//自行定义能满足需要的MyDate类，在MyDate类中重写equals方法，使其判断当两个MyDate类型对象的年月日都相同时，结果为true，否则为false

//MyDate类
package com.iweb.homework;

public class MyDate {
    int year, month, day;

    public MyDate() {

    }

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }


    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        } else {
            if (obj instanceof MyDate) {
                MyDate myDate = (MyDate) obj;
                if (this.year == myDate.year && this.month == myDate.month && this.day == myDate.day) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}
~~~~

~~~~java
//测试类
package com.iweb.homework;

public class ATest {
    public static void main(String[] args) {
        MyDate myDate1 = new MyDate(2000,1,1);
        MyDate myDate2 = new MyDate(2000,1,1);

        System.out.println(myDate1.equals(myDate2));
    }
}
~~~~

### 运行时多态

又叫做动态绑定

当父类引用指向子类对象的时候，父类的引用去调用父类的方法，实际调用到的是子类重写过后的方法

关键词：继承、重写、父类引用指向子类对象

### 抽象方法

定义：只有方法的声明而没有方法的实现，抽象方法需要被abstract关键字修饰

~~~~java
public abstract void draw();//抽向方法必须被重写
~~~~

### 抽象类 

含有抽象方法的类被称为抽象类

- 抽象类需要被abstract关键字修饰
- 抽象类不能被实例化（不能直接创建对象）
- 抽象类是用来被继承的，抽象方法是用来被重写的

### final

- 可以用来修饰一个类——最终类：它不能被继承

- 可以用来修饰一个变量，它的值不可改变

- 可以用来修饰一个方法，它不能被重写

### 常量

整个内存只有一份

~~~~java
public static final 数据类型 常量名 = 常量值； 
    
//常量有三种
public class HelloWorld {
    // 静态常量
    public static final double PI = 3.14;
    // 声明成员常量
    final int y = 10;

    public static void main(String[] args) {
        // 声明局部常量
        final double x = 3.3;
    }
}
~~~~

### 接口

- 如果一个类中所有的方法都是抽象的，那么这个类可以做成接口
- 接口使用interface定义
- 接口被实现类来实现，我们使用implements关键字进行实现
- 实现一个接口，就必须重写接口中所有的抽象方法
- 接口类型的引用可以指向实现类的对象，当它调用接口中的方法时，实际调用到的是实现类中重写过后的方法
- 一个类可以同时实现多个无关的接口
- 注意：当一个类实现多个接口时，该类对象可以多个接口之间转换
- 1. 接口中没有成员变量，只有常量，它是常量和抽象方法的集合
  2. 接口中所有方法都是public，而且只能是public
  3. 1.8及以后版本的jdk，接口中还可以存在static修饰的非抽象方法，使用  接口名.方法名  直接调用

~~~~java
//画家接口
package com.iweb.test2;

public interface Painter {
    public void draw();
    public void sleep();
    public void eat();
    public static void methodInterface(){   //1.8及以后版本的jdk，接口中还可以存在static修饰的非抽象方法，使用  接口名.方法名  直接调用  例如：在测试类中写   Painter.methodInterface();
        System.out.println("我是接口内的非抽象函数")；            
    }
    
}
~~~~

~~~~java
//歌手接口
package com.iweb.test2;

public interface Singer {
    public void sing();
    public void sleep();
}
~~~~

~~~~java
//老师类
package com.iweb.test2;
public class Teachers implements Singer,Painter { //用implements来实现一或多个接口


    @Override
    public void draw() {
        System.out.println("老师在画画");
    }

    @Override
    public void eat() {
        System.out.println("老师在吃饭");
    }

    @Override
    public void sing() {
        System.out.println("老师在唱歌");
    }

    @Override
    public void sleep() {
        System.out.println("老师在睡觉");
    }
}
~~~~

## 第四天

### getClass()

获得当前对象的全类名

### 异常

在代码运行的过程中发生的某些错误情况，例如：除0错误等

### try {    }    catch(){   }

一个try可以对应多个catch，这些catch按照先捕获小的异常再捕获大的异常这样的原则进行顺序编译，也可以只捕获大的异常。

~~~~java
try{
    //里面编写一些可能发生异常的代码
}
catch(异常类型 变量名){
    //catch块   当代码块发生异常时要做的事
}
~~~~

~~~~java
package com.iweb.test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class Test6 {

    public static void main(String[] args) {
        InputStream is = null;
        try {
            is = new FileInputStream("D:\\Desktop\\内容读取.txt");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~~

### finally{  }

它是跟在try/catch后面的第三个代码块，写在finally里面的代码是无论如何都一定会被执行

- 注意：如果finally代码块前面执行了return语句，它依然会执行，并且是在return之前执行

### throws

写在方法声明处【签名(方法的名称+参数类型)的尾部】，表示该方法可能抛出怎样的异常

当一个方法产生一个它不处理的异常时，那么就需要在该方法的头部声明这个异常，以便将该异常传递到方法的外部进行处理

~~~~java
static void b(int n, int m) throws ArithmeticException {
            int result = n / m;
            System.out.println(result);
    }
~~~~

### throw 

~~~~java
//人为的手动抛异常
throw new 异常对象 
~~~~

throw 和 throws 的区别：

- throws 用来声明一个方法可能抛出的所有异常，而 throw 则是抛出一个具体的异常类型
- 通常在一个方法的声明处通过 throws 声明方法可能抛出的所有异常信息，而在方法的内部声明一个具体的异常信息
- throws 通常不明显地捕获异常，而是由系统自动将所有捕获的异常信息抛给上级方法，throw 则需要程序员自己捕获相关的异常，然后再对其进行包装，最后将包装的异常信息抛出。

### 异常类的结构图

注意：RunTimeException在编译的过程中，可以不被try/catch或者throw/throws；而剩下的异常必须被try/catch或者throw/throws，否则边编译报错

<img src="https://cdn.jsdelivr.net/gh/HeartWardrum/MyImageHost/异常类的结构图.png" alt="异常类的结构图" style="zoom:67%;" />

<img src="D:\GitHub\MyImageHost\异常类的结构图.png" alt="异常类的结构图" style="zoom:67%;" />

### String

不可变的字符序列（关于它的变化都会创建一个新字符串）

我们可以通过String 变量名 = "字符串"  来创建一个String对象，它存放在常量区

当我们new String(字符串)时，它实际上创建了两个对象，将指定的字符串对象拷贝了一份

~~~~java
String str = new String("aa");//1.常量池里创建一个 "aa"对象，这是第一个对象
                              //2. 执行该行代码时new一个"aa"的String对象存放在Java堆中，这是第二个对象
						    //3. 栈上的str会指向第二个对象
~~~~

在比较两个字符串的时候，统一使用equals()方法，它比较的是字符串的内容相不相同

```java

String s1 = "hello",s2 = "HELLO",s3 = "e";
s1.equalsIgnoreCase(s2); //字符串比较，忽略大小写
s1.indexOf(s3);//返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1

//字符串分割 spilit("正则表达式")
String s6 = "Tom,Jerry,Marry";
String[] arr = s6.split(",");
for (int i = 0; i < arr.length; i++) {
     System.out.println(arr[i]);
}

//字符串截取  substring(int beginString,int endString)
String s7 = s6.substring(4);
System.out.println(s7);  //Jerry,Marry
String s8 = s6.substring(4, 9);
System.out.println(s8); //Jerry

//取出字符串前后空格  trim()
String s10 = "     hello    ";
String s11 = s10.trim();
System.out.println("s11 =" + s11);//s11 =hello

//其他类型转字符串  String.valueOf()


    
```

详见API文档

### StringBuffer

可变的字符串

我们通过 new StringBuffer(String s)来构造一个StringBuffer对象

~~~~java
//append(String s)   在原字符串后面追加新的字符串
String s = "hello world";
StringBuffer stringBuffer = new StringBuffer(s);
System.out.println(stringBuffer);//hello world
stringBuffer.append(",Tom").append(",Jerry");//甚至可以多次追加
System.out.println(stringBuffer);//hello world,Tom,Jerry

//delete(起始位置，结束位置)   从起始位置删除到结束位置
//insert(位置，String s)    在指定位置插入字符串
 StringBuffer stringBuffer1 = new StringBuffer("0123456789");
 stringBuffer1.delete(4,stringBuffer1.length());
 System.out.println(stringBuffer1); //0123
 stringBuffer1.insert(1,arr);
 System.out.println(stringBuffer1);//0abc123
~~~~

### StringBuilder

可变的字符串

面试题：StringBuffer  和  StringBuilder的区别

- StringBuffer 线程安全（同步），性能较差
- StringBuilder  线程不安全，性能较好

### Math类

算数相关的类，提供各种算数运算的静态方法    Math.方法名

~~~~java
System.out.println(Math.round(3.14)); //4舍5入取整    此处返回3
System.out.println(Math.abs(-100));  //取绝对值  此处返回100
System.out.println(Math.sqrt(81.0));  //开方  此处返回9.0
~~~~

### BigDecimal类

大数值型，可以解决java中基本数据类型长度限制和计算精度的问题

~~~~java
double d3 = 1.2;
double d2 = 1.1;
System.out.println(d3 - d2);//0.09999999999999987

BigDecimal b1 = new BigDecimal("1.2");
BigDecimal b2 = new BigDecimal("1.1");
BigDecimal b3 = b1.subtract(b2);//b1-b2
System.out.println(b3);//0.1
double result = b3.doubleValue();//将此 BigDecimal转换为 double 
System.out.println(b3);//0.1

System.out.println("加法" + b1.add(b2));//2.3
System.out.println("乘法" + b1.multiply((b2)));//1.32
System.out.println("保留五位小数" + b1.divide(b2, 5, BigDecimal.ROUND_HALF_UP));//1.09091
  
~~~~

### 简单的文件读取

~~~~java
package com.iweb.test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class Test6 {

    public static void main(String[] args) {
        InputStream is = null;
        try {
            is = new FileInputStream("D:\\Desktop\\内容读取.txt");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~~



## 第五天 (多线程真tm难)

### Arrays.sort(arr);

//对数组arr进行升序排序

### 读取键盘输入

~~~~java
Scanner sc = new Scanner(System.in);  //System.in 标准输入  

        System.out.println("请输入一个int型的整数：");
        int num = 0;
        try {
            num = sc.nextInt();       //读取整型输入 
        } catch (Exception e) {
            System.out.println("对不起，输入数值非法");
            return;
        }finally {
            sc.close();
        }
        System.out.println("您输入的整数为：" + num);
~~~~

### enum

枚举类型，在定义类型的时候指定它允许的若干值

~~~~java
enum 枚举类型 {
    val1,val2...
};
~~~~

### switch

switch语句允许传入那些类型的变量：byte short int char enum 以及JDK1.7版本之后的String

### 基本数据类型的包装类

我们可以将8种数据类型各自定义为其包装类；包装类的对象中包着基本数据类型的值

~~~~java
Integer 对应 int
Character 对应 char
剩下的六种首字母大写
包装类的对象转基本数据类型 .xxxValue();
//例如：
Integer integer = new Integer(100);
int i = integer.intValue();

//String 转 double  字符串解包
String s = "3.1415926";
double d3 = Double.parseDouble(s);  //parseXxx(String s) 将字符串中的内容转型成基本数据类型
System.out.println(d3);//3.1415926


Double d4 = Double.valueOf(s); //valueOf(string s)将字符串中的内容转型成基本数据类型包装类的对象
System.out.println(d4);//3.1415926 
~~~~

### 自动打包和自动解包

也叫做自动装箱和自动拆箱

- 凡是需要包装类对象的地方，直接传入基本数据类型值即可，系统会自动创建对象
- 凡是需要基本数据类型值的地方，直接传入包装类对象即可，系统会自动将值取出

### 获取当前时间

~~~~java
//方法一 
System.out.println(new Date());//Fri Jul 08 11:23:08 CST 2022

//方法二
SimpleDateFormat sdf = new SimpleDateFormat("hh:mm:ss yyyy/MM/dd");
String s = sdf.format(new Date());
System.out.println(s);//11:23:08 2022/07/08
~~~~

### 进程

- 一段程序的执行过程

### 线程 

- 进程中的一条执行路径
- 线程中的五种状态：

![](https://cdn.jsdelivr.net/gh/HeartWardrum/MyImageHost/线程的五种状态.png)

![线程中的五种状态](D:\GitHub\MyImageHost\线程的五种状态.png)

- 新建状态:
  使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

- 就绪状态:
  当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

- 运行状态:
  如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

- 阻塞状态:
  如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：

  ​			等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
  ​			同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
  ​			其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
  
- 死亡状态:
  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。


线程阻塞：通常是指一个线程在执行过程中暂停（例如sleep），以等待某个条件的触发



### 多线程

- 多个线程同时执行

- 实现多线程的方式：

  1. 继承Thread类并重写run()方法，然后利用该类对象调用start()方法启动一个新的线程执行run()方法

     （这种方法不好）
  
     ~~~~java
     package com.iweb.Test;
     public class TestThread extends Thread {
         @Override
         public void run() {
             for (int i = 0; i < 200; i++) {
     
                 System.out.println("我是run方法，我打印到：" + i);
             }
         }
     
         public static void main(String[] args) {
     
             TestThread t = new TestThread();
             t.start();
     
             for (int i = 0; i < 200; i++) {
                 System.out.println("我是main方法，我打印到：" + i);
             }
         }
     }
     //打印结果 两边交替打印，但是所分配时间并不均匀
     我是main方法，我打印到：0
     我是main方法，我打印到：1
     我是main方法，我打印到：2
     我是main方法，我打印到：3
     我是main方法，我打印到：4
     我是run方法，我打印到：0
     我是main方法，我打印到：5
     我是run方法，我打印到：1
     我是main方法，我打印到：6
     我是run方法，我打印到：2
     我是main方法，我打印到：7
     我是main方法，我打印到：8
     我是main方法，我打印到：9
     我是main方法，我打印到：10
     我是main方法，我打印到：11
     我是main方法，我打印到：12
         ......
     ~~~~

     
  
  2. 实现Runnable接口并重写run()方法，使用的时候：
  
     > 首先创建该类对象
     >
     > 然后将该类对象当作参数传入Thread构造方法创建Thread
     >
     > 最后再由Thread对象调用start()方法启动一个新的线程来执行run()方法

~~~~java
public class TestRunnable implements Runnable {
    @Override
    public void run() {
            for (int i = 0; i < 200; i++) {
                System.out.println("我是run方法，我打印到：" + i);
            }
    }

    public static void main(String[] args) {

        TestRunnable tr = new TestRunnable();//先创建该类对象 tr
        Thread t = new Thread(tr);//将tr当作参数传入Thread构造方法创建Thread
        t.start();//Thread对象调用start()

        for (int i = 0; i < 200; i++) {
            System.out.println("我是main方法，我打印到：" + i);
        }
    }
}
//打印结果同第一种
~~~~

**注意**：第二种方法比较好，因为java是单继承多实现，我们应该尽可能将继承的机会留给业务逻辑



#### 常用方法

- sleep(毫秒数) ---- 使当前线程休眠毫秒数

  ~~~~java
  package com.iweb.Test;
  
  import java.text.SimpleDateFormat;
  import java.util.Date;
  
  public class MySleep implements Runnable {
      @Override
      public void run() {
          while (true) {
              SimpleDateFormat sdf = new SimpleDateFormat("hh:mm:ss yyyy/MM/dd");
              String s = sdf.format(new Date());
              System.out.println(s);
              try {
                  Thread.sleep(1000);//
              } catch (InterruptedException e) {  //如果睡眠被中断，直接跳出循环
                  return;    
              }
          }
      }
  }
  ~~~~

  ~~~~java
    //测试类
    package com.iweb.Test;
    import java.util.concurrent.ThreadLocalRandom;
    
    public class Test2 {
    
        public static void main(String[] args) {
            MySleep ms = new MySleep();
            Thread t = new Thread(ms);
            t.start();
    
            try {
                Thread.sleep(10000);//睡10s
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            t.interrupt();
        }
    }
    
    //打印结果   每隔一秒打印当前时间  十秒后停止
    11:31:03 2022/07/08
    11:31:04 2022/07/08
    11:31:05 2022/07/08
    11:31:06 2022/07/08
    11:31:07 2022/07/08
    11:31:08 2022/07/08
    11:31:09 2022/07/08
    11:31:10 2022/07/08
    11:31:11 2022/07/08
    11:31:12 2022/07/08

- join() ---- 使指定线程和当前线程合并为同一个线程

~~~java
package com.iweb.Test;

public class TestRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println("我是run方法，我打印到：" + i);
        }
    }


    public static void main(String[] args) {

        TestRunnable tr = new TestRunnable();
        Thread t = new Thread(tr);
        t.start();
        try {
            t.join();      // 使指定线程和当前线程合并为同一个线程
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (int i = 0; i < 200; i++) {
            System.out.println("我是main方法，我打印到：" + i);
        }
    }
}
//打印结果  run方法先打印完再开始打印main方法
~~~

- yield() ---- 让出当前CPU使自己处于就绪状态

  ~~~java
  package com.iweb.Test;
  
  public class TestRunnable implements Runnable {
      @Override
      public void run() {
          for (int i = 1; i < 201; i++) {
  
  
              System.out.println("我是run方法，我打印到：" + i);
              if (i % 10 == 0) {
                  Thread.yield();
              }
          }
      }
  
  
      public static void main(String[] args) {
  
          TestRunnable tr = new TestRunnable();
          Thread t = new Thread(tr);
          t.start();
  
  
          for (int i = 1; i < 201; i++) {
  
              System.out.println("我是main方法，我打印到：" + i);
              if (i % 10 == 0) {
                  Thread.yield();  //整十的时候更容易发生切换
              }
          }
      }
  }
  
  //打印结果  //整十的时候更容易发生切换
  我是main方法，我打印到：1
  我是main方法，我打印到：2
  我是run方法，我打印到：1
  我是run方法，我打印到：2
  我是main方法，我打印到：3
  我是main方法，我打印到：4
  我是main方法，我打印到：5
  我是run方法，我打印到：3
  我是run方法，我打印到：4
  我是run方法，我打印到：5
  我是main方法，我打印到：6
  我是run方法，我打印到：6
  我是run方法，我打印到：7
  我是run方法，我打印到：8
  ~~~

  - setName(线程名) ---- 可以设定线程的名字
  - currentThread().getName() ---- 获得当前线程的名字

  ~~~~java
  package com.iweb.Test;
  
  public class TestRunnable implements Runnable {
      @Override
      public void run() {
          for (int i = 1; i < 201; i++) {
  
              System.out.println("我是"+Thread.currentThread().getName()+"线程,我打印到：" + i);
          }
      }
  
      public static void main(String[] args) {
  
          TestRunnable tr = new TestRunnable();
          Thread t = new Thread(tr);
          t.setName("啦啦啦");
          t.start();
  
  
          for (int i = 1; i < 201; i++) {
  
              System.out.println("我是main线程,我打印到：" + i);
          }
      }
  }
  
  ~~~~

  

  - setPriority(int i) ---- 设置优先级 1 - 10 

  ~~~~java
  package com.iweb.Test;
  
  public class TestRunnable implements Runnable {
      @Override
      public void run() {
          for (int i = 1; i < 201; i++) {
  
  
              System.out.println("我是main线程,我的优先级为：" + Thread.currentThread().getPriority() + "我打印到：" + i);
  
          }
      }
  
  
      public static void main(String[] args) {
  
          TestRunnable tr = new TestRunnable();
          Thread t = new Thread(tr);
          t.setName("啦啦啦");
          t.setPriority(10);
          t.start();
  
          Thread.currentThread().setPriority(1);
          for (int i = 1; i < 201; i++) {
  
              System.out.println("我是main线程,我的优先级为：" + Thread.currentThread().getPriority() + "我打印到：" + i);
          }
      }
  }
  ~~~~

  

  - getPriority() ---- 获得优先级

  

#### 线程不同步实例

~~~~java
package com.iweb.Test;
public class Time {
    int i = 0;

   void add(String str) {  //第一种方法： synchronized void add(String str) 则线程同步
        this.i++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(str + "你好，你是第" + i + "个访问该对象的线程");
    }
}
~~~~

~~~~java
package com.iweb.Test;

public class TestSync implements Runnable {
    Time time;

    TestSync() {
        time = new Time();
    }

    @Override
    public void run() {
        time.add(Thread.currentThread().getName());
    }
}
~~~~

~~~java
//测试类
package com.iweb.Test;

public class Test11 {


    public static void main(String[] args) {
        TestSync testSync = new TestSync();
        Thread t1 = new Thread(testSync);
        Thread t2 = new Thread(testSync);
        t1.setName("t1");
        t2.setName("t2");
        t1.start();
        t2.start();
    }
}
~~~

- synchronized ----- 可以添加在方法的声明处，使得当前方法线程同步，也就是说当一个线程方法访问某对象的该方法，其他线程无法访问该对象的该方法

~~~java
synchronized(对象){
    不可分割的代码块
}
~~~

~~~java
package com.iweb.Test;

public class Time {
    int i = 0;

    void add(String str) {
        synchronized (this) {  //第二种方法  线程同步
            this.i++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(str + "你好，你是第" + i + "个访问改对象的线程");
        }
    }
}
~~~

### 死锁

多个线程同时锁定了对方想要锁定的对象，导致相互等待

 简单死锁：

~~~~java
package com.iweb.test;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-22/0022
 * 描述：简单死锁实例
 */

public class TestDeadLock implements Runnable {
    boolean flag;


    public boolean isFlag() {
        return flag;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }

    //必须要静态变量
    static Object o1 = new Object();
    static Object o2 = new Object();


    @Override
    public void run() {

        if (flag) {
            synchronized (o1) {
                System.out.println(Thread.currentThread().getName() + "开始工作");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println("work is done");
                }

            }
        } else {
            synchronized (o2) {
                System.out.println(Thread.currentThread().getName() + "开始工作");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("work is done");
                }

            }
        }
    }

    public static void main(String[] args) {

        //测试
        TestDeadLock r1 = new TestDeadLock();
        r1.setFlag(true);
        Thread t1 = new Thread(r1);
        t1.setName("线程1");

        TestDeadLock r2 = new TestDeadLock();
        r2.setFlag(false);
        Thread t2 = new Thread(r2);
        t2.setName("线程2");

        t1.start();
        t2.start();
    }
}
~~~~

避免死锁：尽可能将加锁的粒度加粗

- 解锁如下：

~~~java
//只需要修改run()方法
//2023年7月24日修正，以下代码有误，详见新的笔记
@Override

   
~~~

注意：1. 当一个线程进入了某个加锁的方法时，其他线程完全可以访问其他没有加锁的方法

~~~java
package com.iweb.Test2;

public class T implements Runnable {

    int i = 100;

    synchronized void m1() {
        this.i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    void m2() {
        System.out.println(i);
    }

    @Override
    public void run() {
        m1();
    }
}
~~~

~~~java
package com.iweb.Test2;

public class Test13 {
    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t.m2();
    }
}
~~~

	2. 没有加锁的方法会对加锁的方法造成影响
	2. 各自加锁的方法在执行的过程中互斥

### Object类中线程相关的方法

- wait() ---- 使当前线程处于等待状态
- notify() ---- 唤醒当前对象上某个wait中的线程
- notifyAll() ---- 唤醒当前对象上所有wait中的线程

### wait和sleep的区别

1. sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法
2. sleep会自动醒，wait如果没有指定毫秒数则需要notify唤醒
3. 某个线程在sleep的过程中不会释放线程锁，而在wait的过程中会释放线程锁
4. sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信
5. sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。

### 多线程经典例题：生产消费

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-22/0022
 * 描述：消费者
 */

public class Customer implements Runnable {
    MantouStack mantouStack;

    public Customer() {
    }

    public Customer(MantouStack mantouStack) {
        this.mantouStack = mantouStack;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {//没买到20个都要继续买
            Mantou mt = mantouStack.pop();//从框中取走一个
            try {
                Thread.sleep((long) (Math.random() * 1000)); //休息个[0,1)秒再接着买
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
package com.iweb.test3;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-22/0022
 * 描述：生产者
 */

public class Producer implements Runnable {
    MantouStack mantouStack = new MantouStack();

    public Producer() {
    }

    public Producer(MantouStack mantouStack) {
        this.mantouStack = mantouStack;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {//生产完二十个馒头下班回家
            Mantou mt = new Mantou(i);
            mantouStack.push(mt);//馒头放进框内

            //捏累了休息一会
            try {
                Thread.sleep((long) (Math.random() * 1000));//[0,1)随机秒数
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}

~~~

~~~java
package com.iweb.test3;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-22/0022
 * 描述：馒头类
 */

public class Mantou {
    int id;

    public Mantou() {
    }

    public Mantou(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "馒头编号：" + id;
    }
}

~~~

~~~java
package com.iweb.test3;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-22/0022
 * 描述：馒头框
 */

public class MantouStack {

    Mantou[] mantous = new Mantou[6];//馒头框里最多放六个馒头
    int countOfMantou = 0;//当前框里的馒头数


    //放入馒头
    public synchronized void push(Mantou mantou) {
        while (mantous.length == countOfMantou) {//框里馒头满了
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //框里空出来了
        notify();
        mantous[countOfMantou] = mantou;
        countOfMantou++;
        System.out.println("放进来一个馒头 " + mantou);
    }

    //取出馒头
    public synchronized Mantou pop() {
        while (countOfMantou == 0) {//框里没馒头了
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //有馒头了
        notify();
        countOfMantou--;
        System.out.println("取走了 " + mantous[countOfMantou]);
        return mantous[countOfMantou];
    }

}
~~~

~~~java
package com.iweb.test3;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-22/0022
 * 描述：测试类
 */

public class Test {


    public static void main(String[] args) {
        MantouStack mantouStack = new MantouStack();//得使用同一个馒头框
        Producer p = new Producer(mantouStack);
        Customer c = new Customer(mantouStack);
        Thread producerThread = new Thread(p);
        Thread customerThread = new Thread(c);

        producerThread.start();
        customerThread.start();
    }
}
~~~

改写生产者消费者的代码:
两个师傅各生产20个馒头 : 张师傅,李师傅
四个学生各消费10个馒头 : 小明,小王,小强,小红

~~~~java
//馒头类
public class ManTou {
    private int id;
    static int sid = 1;

    public ManTou() {
        this.id = sid++;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "ManTou{" +
                "id=" + id +
                '}';
    }
}
~~~~



~~~java
//馒头框类
public class ManTouStack {
    ManTou[] arr = new ManTou[6];//创建一个可以存放6个馒头的数组
    int index = 0;//表示当前框中的馒头数

    //生产
    synchronized void push(String ProducerName) {//传入生产者的名字
        while (arr.length == index) {//如果馒头框满了，线程等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        ManTou mt = new ManTou();
        arr[index] = mt;
        index++;
        System.out.println(ProducerName + "生产了馒头：" + mt);
    }


    //消费
    synchronized ManTou pop(String ConsumerName) {

        while (index == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        index--;
        System.out.println(ConsumerName + "消费了馒头：" + arr[index]);
        return arr[index];
    }
}
~~~

~~~~java
//生产者类
public class Producer implements Runnable {

    ManTouStack manTouStack;
    String name;

    public Producer(ManTouStack manTouStack, String name) {
        this.manTouStack = manTouStack;
        this.name = name;
    }

    public Producer() {
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            //ManTou mt = new ManTou();
            //manTouStack.push( mt,this.name);
            manTouStack.push(this.name);
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}
~~~~

~~~~java
//消费者类
public class Consumer implements Runnable {


    ManTouStack manTouStack;
    String name;

    public Consumer() {
    }

    public Consumer(ManTouStack manTouStack, String name) {
        this.manTouStack = manTouStack;
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i <= 10; i++) {
            ManTou mt = manTouStack.pop(this.name);
            try {
                Thread.sleep((long) (Math.random() * 2000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~~

~~~java
//测试类
public class Test {

    public static void main(String[] args) {
        ManTouStack mts = new ManTouStack();
        Producer p1 = new Producer(mts, "张师傅");
        Producer p2 = new Producer(mts, "李师傅");
        Consumer c1 = new Consumer(mts, "小明");
        Consumer c2 = new Consumer(mts, "小王");
        Consumer c3 = new Consumer(mts, "小强");
        Consumer c4 = new Consumer(mts, "小红");

        Thread thread1 = new Thread(p1);
        Thread thread2 = new Thread(p2);
        Thread thread3 = new Thread(c1);
        Thread thread4 = new Thread(c2);
        Thread thread5 = new Thread(c3);
        Thread thread6 = new Thread(c4);

        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
        thread5.start();
        thread6.start();
    }
}
~~~

## 第六天

### 集合

- 结构图：

![](https://cdn.jsdelivr.net/gh/HeartWardrum/MyImageHost/集合结构图.png)

![](D:\GitHub\MyImageHost\集合结构图.png)

- ArrayList ---- 这是一个常用的集合类，它实现了List接口

  - 常用方法：

    > `add(对象) ---- 往集合中添加一个对象`
    >
    > `get(下标) ---- 获取集合中指定位置的对象，注意：下标从0开始`
    >
    > `size() ---- 获取集合的长度`
    >
    > `remove() ---- 从当前集合中删除与指定对象相等的对象，注意：是否相等看的是equals方法`
    >
    > `contains(对象) ---- 判断当前集合中是否包含指定的对象，注意：是否包含看的是equals方法`

~~~~java
//例如 
public static void main(String[] args) {
        List list = new ArrayList();
        list.add(new Student("1111","张三",20));
        list.add(new Student("2222","王五",20));
        list.add(new Student("3333","李四",20));
        list.add(1000);
        list.add(1.1);
        System.out.println("当前list长度为： " + list.size());
    
    	//使用简单for遍历
        for (int i = 0; i < list.size(); i++) { 
            System.out.println(list.get(i));
        }
        //使用foreach遍历
    	for(类型名 变量 : 集合名){
			使用变量
		}
    	for (Object o : list) {
            System.out.println(o);
         }

    	//在自己定义的Student类中重写equals方法后，可以删除一个Student类型的元素
    	list.remove(new Student("1111", "张三", 20));
    	//当我们传入int类型的时候,为了移除制定的元素而不至于引起混淆，可以将传入的int先封装一下
        list.remove((Integer)1000);//不封装的话则默认删除下标为1000的元素
    }
~~~~

- 注意：ArrayList 、Vector 和 LinkedList 都是实现了List接口的实现类，他们所提供的方法都是一样的

  - 区别: 

    > ArrayList 和 LinkedList 线程不同步，效率高；Vector 线程同步，效率低
    >
    > ArrayList 底层是数组，擅长查询；LinkedList 底层是链表，擅长插入和删除

    

### 迭代器 Iterator

> 同来遍历一个集合，
>
> 我们使用  集合对象.iterator()  获取迭代器
>
> 使用迭代器的 hasNext() 方法判断是否遍历到集合末尾
>
> 使用迭代器的remove()删除集合中的每一个元素  
>
> 注意：在迭代的过程中不可以使用集合对象的remove()删除元素

~~~java
//foreach的底层   迭代器
Iterator iterator = list.iterator();//获取迭代器
while(iterator.hasNext()){
	System.out.println(iterator.next());
}

//迭代器中删除元素
Iterator iterator = list.iterator();
while(iterator.hasNext()){
	iterator.remove();
}
~~~



# 问题

```
public ManTou() {
    synchronized (sid){
        this.id = id;
    }
    
}//没看到，估计写得不对，在上午第二节课开始处

```
---
title:  笔记_002_java
tag: 
	- java
categories: 
	- java
---

## 第七天

### Set

Set和List都是Collection接口下的子接口，区别：

- List是有序的，可重复的
- Set是无序的，不可重复的
- 对于Set来讲没有get方法，因为它没有下标的概念；而对于List来讲，正因为它有下标的概念，所以它可以使用add(下标，对象)来将对象插入到指定位置

Set常用方法：

> `add(对象) ---- 添加对象`
>
> 

~~~java
Set set = new HashSet();
set.add(100);
set.add("hello");
set.add(new Student("1001","张三",20));
~~~

### Map

存放的是键值对，通过每一个键可以得到每一个值

>put(key,value) ---- 存入键值对
>
>get(key) ---- 根据键得到值
>
>containsKey(key) ---- 判断当前Map中是否包含指定的键
>
>containsValue(value) ---- 判断当前Map中是否包含指定的值

注意：对于Map来讲键值对的键不可重复，如果重复，则后加入的键值对会将先加入的键值对覆盖

~~~java
Map map = new HashMap();
map.put("one", new Integer(100));
map.put("two",new String("hello"));
map.put(null,new Integer(200));
~~~

遍历map

~~~java
for (Map.Entry<Character, Integer> entry: map.entrySet()) {
                System.out.println("\""+entry.getKey()+"\""+"的数量是:"+entry.getValue());
            }
~~~



HashMap和HashTable的区别：

- HashMap线程不同步，效率高；HashTable线程同步，效率低
- HashMap可以使用null作为键 HashTable不可以

### Collections

这是一个帮助类，帮助我们对Collection集合中的元素进行各种处理，例如`Collections.sort()`可以实现对List进行各种排序

### Arrays.sort()

可以对一个数组进行升序排序

### 泛型

在定义集合的时候使用<>同时来定义集合中的对象类型，它可以增强程序的可读性和稳定性

Map中的键、值都可以使用泛型来定义

~~~~java
List<String> list = new ArrayList<>();
Map<String,Integer> map = new HashMap<>();
~~~~

~~~~java
List<Map<String,Object>> list = new ArrayList<>();

for (int i = 0; i < 3; i++) {
     Map<String, Object> m1 = new HashMap<>();
     for (int j = 0; j < 5; j++) {
         m1.put("key" + i + j, "value" + i + j);

     }
            list.add(m1);
}
for (Map<String, Object> stringObjectMap : list) {
     System.out.println(stringObjectMap);
}
~~~~

我们可以使用List<Map<String,Object>>类型来整合一组数据库中的数据

### 泛型类

`Class 类名<泛型标识>{}`

使用泛型类定义对象：`类名<泛型> 变量名 = new 类名<>();`

注意：

- 如果定义对象的时候不使用泛型，那么它的泛型就是Object型
- 某个泛型类下的多个对象，当他们的泛型不同时，他们的类型依然是相同的

### Random

随机数   我们可以使用`该对象.nextXxx(上限值)`返回上限值以内的随机数

简单抽奖：

~~~~java
public class ProductGetter<T> {
    //奖品
    private T product;

    //抽奖池
    List<T> productList = new ArrayList<>();

    static Random random = new Random();

    //往奖池中投放若干奖品
    void putProduct(T product) {
        productList.add(product);
    }
    
    //从奖池中随机抽一个奖品
    T getProduct() {
        return productList.get(random.nextInt(productList.size()));
    }

}
~~~~

~~~java
public class Test {

    public static void main(String[] args) {
        //抽实物
        String[] arr = new String[]{"苹果", "华为", "扫帚", "咖啡机"};
        ProductGetter<String> productGetter = new ProductGetter<>();
        for (String s : arr) {
            productGetter.putProduct(s);

        }
        String product = productGetter.getProduct();
        System.out.println(product);

		//抽现金
        int[] arr2 = new int[]{1000, 2000, 3000, 4000};
        ProductGetter<Integer> productGetter1 = new ProductGetter<>();
        for (int i : arr2) {
            productGetter1.putProduct(i);

        }
        int product2 = productGetter1.getProduct();
        System.out.println(product2);

    }

}

~~~

### 泛型中的继承

1. 当父类是泛型类时，如果子类也是泛型类，则定义子类时，它的泛型标识必须和父类一致

~~~java
//父类
public class Parent<T> {
    T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    public Parent(T value) {
        this.value = value;
    }

    public Parent() {
    }
}
~~~

~~~java
//子类1
public class Child<E> extends Parent<E> {

    @Override
    public E getValue() {
        return super.getValue();
    }

    @Override
    public void setValue(E value) {
        super.setValue(value);
    }
}
~~~

2. 当父类是泛型类时，如果子类不是泛型类，需要指明父类的泛型类型

~~~java
//子类2
public class Child2 extends Parent {

    @Override
    public Object getValue() {
        return super.getValue();
    }

    @Override
    public void setValue(Object value) {
        super.setValue(value);
    }
}
~~~

~~~java
    //测试类
public static void main(String[] args) {
        Child<String> child = new Child<>();
        child.setValue("abc");
        System.out.println(child.getValue());

        Child2 child2 = new Child2();
        child2.setValue("hello");
        System.out.println(child2.getValue());
        
    }
~~~

### 泛型接口

1. 当接口是泛型接口时，如果实现类也是泛型类，则定义实现类时，它的泛型标识必须和接口一致

~~~java
public interface GenericInterface<T> {
    T getValue(T t);
}
~~~

~~~java
public class MyImplement<T> implements GenericInterface<T> {
    @Override
    public T getValue(T t) {
        return t;
    }
}
~~~

2. 当接口是泛型接口时，如果实现类不是泛型类，则定义实现类时，需要指明接口的泛型类型

### 泛型方法

我们在方法声明的地方添加 <泛型标识> ,这样的方法称为泛型方法，它可以在用户调用方法的时候来指明具体的泛型

注意：如果方法是静态的，我们可以定义多个泛型

~~~java
static <T, E, K> void test1(T t, E e, K k){
        System.out.println(t.getClass());
        System.out.println(e.getClass());
        System.out.println(k.getClass());
    }
~~~

~~~java
ProductGetter.test1(false,10,"hello");
//打印结果
class java.lang.Boolean
class java.lang.Integer
class java.lang.String
~~~

### 可变参数的泛型方法

在定义泛型方法的时候，参数列表使用`泛型标识...变量`来表示可变参数

实际接收到的参数是一个泛型参数的数组

~~~java
static <T> void test2(T...t){
        System.out.println("参数数组的个数： " + t.length);
        for (int i = 0; i < t.length; i++) {
            System.out.print(t[i] + "   ");
        }
    }
~~~

~~~java
productGetter.test2(1,2,3,4,5);
//打印结果
参数数组的个数： 5
1   2   3   4   5
~~~

### 泛型中的通配符 

`?` 在泛型中表示通配符，它可以修饰某个类型的变量，该变量可以接收任何泛型的该类对象

~~~java
List<?> list1 = new ArrayList<>();
List<String> list2 = new ArrayList<>();
list1 = list2;
~~~

~~~java
Map<?,?> map1 = new HashMap<>();
Map<String,Integer> map2 = new HashMap<>();
map1 = map2;
~~~

### Arrays.copyOf(旧数组，新数组的长度) 

创建一个新数组，然后将旧数组拷贝到新数组中，返回新数组的引用

## 第八天

### Vector 集合对象如何扩容

在我们创建Vector对象的时候，可以指定初始容量和扩容容量，每次就按照自己指定的扩容容量来扩容，如果没有指定扩容容量，则每次扩容时容量翻倍

### LinkedList

单链表 ---- 每个节点存放数据的同时，还存放下一个节点的地址

双向链表 ---- 每个节点存放数据的同时，还存放上一个节点和下一个节点的地址

JDK中的LinkedList是一个双向链表

### 栈

- 先进后出，后进先出
- 在java当中，我们使用Deque接口，只对其一端进行操作，来表示栈

~~~java
//十进制转2进制
public static void main(String[] args) {

        int t = 255;

        Deque deque = new LinkedList();
        do {
            int mod = t % 2;
            deque.push(mod);
            t /= 2;
        } while (t > 0);
        while (!deque.isEmpty()) {
            System.out.print(deque.poll());
        }


    }
}
~~~



### 队列

- 先进先出，后进后出
- 在java中，有两个接口：
   - Queue ---- 队列
     - `add() ---- 入队`
     - `poll() ---- 出队`
     - `peek() ---- 获取队首元素`
   - Deque ---- 双端队列 ：两端都可以入队出队
     - `addFirst() ---- 从队首入队`
     - `addLast() ---- 从队尾入队`
     - `pollFisrt() ---- 从队首出队`
     - `pollLast() ---- 从队尾出队`
     - `peekFirst() ---- 获取队首元素`
     - `peekLast() ---- 获取队尾元素`

注意：java中通常使用LinkedList来实现栈和队列

### 树

树是一个集合以及在该集合上定义的一种关系结构

- 节点的度 ---- 节点拥有的子树的数目就是节点的度
- 树的度 ---- 各个节点最大的度，就是树的度

有序树：如果将树中的节点各个子树看成从左至右是有序的，就称为有序树，否则就是无序树

m叉树：一棵树的任一节点往下，最多分几个叉就是几叉树

二叉树：每个节点的度均不超过2的有序树

 - 满二叉树 ：除了叶子节点，每个层的节点都达到最大数

 - 完全二叉树：在满二叉树基础上，最下层从最右侧起，去掉若干相邻的子节点得到的二叉树

   

二叉树的特性：度为2的节点数量 + 1 = 终端节点的数量

注意：在java中数组和链表都可以表达二叉树，但是数组并不好0用，我们常常使用链表来表达二叉树

### 二叉树的遍历

按照某种访问的次序对二叉树中的所有节点依次访问，而且每个节点恰好访问一次

二叉树的遍历方式：

- 先序： 根   左子树  右子树
- 中序：左子树  根   右子树
- 后序： 左子树  右子树   根

面试题：
中序：4513267
后序：5437621
求先序

1. 先看后序的最后一个数就是根 此处为 1

2. 看中序，分出根的左右子树

3. 看后序，54的顺序决定了4是左子树的根
    到此为止：先序：145...

  注意：由中序可知4在前5在后，所以5是4的右孩子

4. 看后序，2是右子树的根

  到此为止：先序：1452...

5. 看中序，3是2的左孩子，67是2的右孩子

  到此为止：先序：14523...

6. 再看2的右子树，由后序可知，76的顺序是7在前，6在后，那么6就是7的父亲，所以6就是2的右子树的根

  到此为止：先序：1452367

7. 最后由中序可知7是6的右孩子

### 简单递归

~~~java
static int dg(int i) {
int sum = 0;
if (i == 1)
    return 1;
else
    sum = i + dg(i - 1);
return sum;
}
~~~

## 第十天

###  IO流

- 按照传输的方向来分:

  > 输入流：数据流向了CPU，所以读文件是输入流
  >
  > 输出流：数据从CPU流出去，所以写文件是输出流
  >
  > 注意：输入和输出的方向问题，永远都是站在CPU的角度来看待的

- 按照传输的最小单位分：

  > 字节流 ---- 按照字节为单位进行传输
  >
  > 字符流 ---- 按照字符为单位进行传输

- 按功能的强弱分：
  
  > 节点流 ---- 基本功能的数据流，数据往往按照最小单位传输
  >
  > 处理流 ---- 功能强大的一些数据流，数据往往是批量传输

在Java中，所有的流都继承自以下4个抽象类：

`InputStream ---- 字节输入流`

`OutputStream ---- 字节输出流`

`Reader ---- 字符输入流`

`Writer ---- 字符输出流`

### FileInputStream 

文件输入流，用来读文件；当我们new一个FileInputStream对象时，需要传入文件路径，换句话说相当于一根管道怼到了该文件上，这根管道可以用来从文件中抽水

`read() ---- 抽一个字节出来返回给CPU 返回值是一个unicode编码 类型为int`

`close() ---- 关闭该输入流`

Windows的文件分割符默认为反斜杠，Linux是正斜杠；Java中的`File.separator() `返回的是当前操作系统的文件分隔符

在实际开发中，我们其实只需要写正斜杆，因为Windows会智能地将其转为反斜杠

~~~java
  public static void main(String[] args) {
        InputStream is = null;
        //String path = File.separator;
        try {
            is = new FileInputStream("D:/GitHub/Java/算法.md");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i); //将i转成char型 不然打印结果为一堆数字
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)// 提高代码健壮性 如果路径失效 压根没开启is 就不用close
                    is.close();//相当于截断管道
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
//打印结果中的中文字会变成乱码
~~~

注意：字节流每读取一个中文字，实际上是读取到中文字的一半的编码，所以不能直接打印，我们可以使用字符流来读取并打印

### FileReader

文件字符输入流，用来读文件；当我们new一个FileReader对象时，需要传入文件路径，换句话说相当于一根管道怼到了该文件上，这根管道可以用来从文件中抽水

~~~java
public static void main(String[] args) {
        Reader is = null;
        //String path = File.separator;
        try {
            is = new FileReader("D:/java/MyProject/Test20220708/src/com/iweb/test/Test.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)// 提高代码健壮性 如果路径失效 就不用close
                    is.close();//相当于截断管道
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

### FileOutputStream

文件字节输出流，用来写文件；当我们new一个FileOutputStream对象时，需要传入文件路径，如果路径不存在，则会自动创建。换句话说相当于一根管道怼到了该文件上，这根管道可以用来向文件中注水

`write(int) ---- 将一个字节通过该字节流输出到文件中`

`close() ---- 关闭该输入流`

~~~java
public static void main(String[] args) {
        InputStream is = null;
        OutputStream os = null;
        //String path = File.separator;
        try {
            is = new FileInputStream("D:/java/MyProject/Test20220708/src/com/iweb/test/Test.java");
            os = new FileOutputStream("D:/Desktop/hello.txt");
            int i = 0;
            while ((i = is.read()) != -1) {
                os.write(i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)// 提高代码健壮性 如果路径失效 就不用close
                    is.close();//相当于截断管道
                if (os != null)
                    os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

### FileWriter

文件字符输出流，用来写文件；当我们new一个FileWriter对象时，需要传入文件路径，如果路径不存在，则会自动创建。换句话说相当于一根管道怼到了该文件上，这根管道可以用来向文件中注水

`write(int) ---- 将一个字节通过该字节流输出到文件中`

`close() ---- 关闭该输入流`

注意：构造方法的第二个参数

- 是true表示追加
- 是false表示覆盖

~~~java
public static void main(String[] args) {
        Writer w = null;
        try {
            w = new FileWriter("D:/Desktop/hello.txt");// FileWriter(路径,Boolean boolean)
            for (int i = 0; i < 50000; i++) {
                w.write(i);
            }
            System.out.println("创建完毕");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (w != null) {
                try {
                    w.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
~~~

### BufferedInputStream和BufferedOutputStream

字节输入/输出缓冲流

他们的read方法和write方法会一次性从硬盘读取/写入8k个字节到缓存，然后针对缓存进行操作；当缓存用完之后才会再访问硬盘，减少了硬盘的访问次数

他们都是处理流

注意：处理流是包在节点流外面的，当处理流关闭时，节点流自动关闭

~~~java
public static void main(String[] args) {
        InputStream is = null;
        BufferedInputStream bis = null;
        try {
            is = new FileInputStream("D:/java/MyProject/Test20220708/src/com/iweb/test/Test.java");
            bis = new BufferedInputStream(is);
            int i = 0;
            while ((i = bis.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bis != null)// 提高代码健壮性 如果路径失效 就不用close
                    bis.close();//相当于截断管道
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

### BufferedReader

字符输入缓冲流，它可以读文件

`readLine() ---- 每次从文件中读一行，返回该字符串`

`close() ---- 关闭该缓冲流`

### BufferedWriter

字符输出缓冲流，它可以写文件

`write(String s) ---- 写入一个字符串`

`newLine() ---- 另起一行`

`flush() ---- 清空缓冲区`

`close() ---- 关闭该输出流`

~~~java
public static void main(String[] args) {
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {
            bw = new BufferedWriter(new FileWriter("D:/Desktop/random.txt"));
            br = new BufferedReader(new FileReader("D:/Desktop/random.txt"));
            for (int i = 0; i < 100; i++) {
                String s = String.valueOf(Math.random());
                bw.write(s);
                bw.newLine();//另起一行
            }
            bw.flush();//清空缓冲区
            String s1 = "";
            while ((s1 = br.readLine()) != null) {
                System.out.println(s1);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
~~~

### PrintWriter

打印流

用来打印日志，它只有输出，没有输入，不会抛出异常

提供各种重载的print()方法和println()方法用来打印

它自带缓冲功能，具有flush()方法

### InputStreamReader

这是将字节流转字符流的桥梁，传入一个字节流，它返回一个字符流

注意：该字符流是一个节点流

~~~java
public static void main(String[] args) {
        String s = null;
        PrintWriter pw = null;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            FileWriter fw = new FileWriter("D:/Desktop/log.txt", true);
            pw = new PrintWriter(fw);
            while ((s = br.readLine()) != null) {
                if ("exit".equals(s)) {
                    break;
                }
                System.out.println(s);
                pw.println("--------");
                pw.println(s);
            }
            pw.println("======" + new Date() + "======");
            pw.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (pw != null)
                    pw.close();
                if (br != null)
                    br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

### DataInputStream 和 DataOutputStream

数据流，往往用于网络上的数据传输，它们的readUTF()方法和writeUTF()方法可以实现UTF-8的编码格式来传输数据

UTF-8 ---- 可变长度的Unicode编码格式

### ServerSocket

这是网络编程中的服务器类，它可以调用accept()方法来接收某个客户端向它发起是请求，并返回Socket对象

### Socket

这是网络编程中的客户端类，它可以向服务器发起请求，该类对象可以调用getInputStream()和getOutputStream()获取当前请求响应的数据流中的字节流对象

### 简单服务器

~~~java
//服务器端
public class TcpServer {

    public static void main(String[] args) {
        System.out.println("我是服务器，我开始启动了");
        ServerSocket ss = null;
        Socket s = null;
        DataInputStream dis = null;
        DataOutputStream dos = null;
        try {
            ss = new ServerSocket(9527);
            while (true) {
                s = ss.accept();
                InputStream is = s.getInputStream();
                dis = new DataInputStream(is);
                String str = dis.readUTF();
                System.out.println(str);
                dos = new DataOutputStream(s.getOutputStream());
                dos.writeUTF("Hello I am Server!");
                dos.flush();


            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (s != null)
                    s.close();
                if (dis != null)
                    dis.close();
                if (dos != null)
                    dos.close();
                if (ss != null)
                    ss.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
//客户端
public class TcpClient {
    public static void main(String[] args) {
        System.out.println("我是客户端，我即将向服务器发起请求");
        Socket s = null;
        DataOutputStream dos = null;
        DataInputStream dis = null;
        try {
            s = new Socket("127.0.0.1", 9527);
            dos = new DataOutputStream(s.getOutputStream());
            dos.writeUTF("Hello,I am Client!");
            dis = new DataInputStream(s.getInputStream());
            System.out.println(dis.readUTF());

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dos != null)
                    dos.close();
                if (dis != null) {
                    dis.close();
                }
                if (s != null)
                    s.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

### 设计模式

#### 单例Singleton

一个类只能创建出一个对象

- 饿汉模式：
  1. 构造方法私有化
  2. 提供`static finally 当前类型的成员变量`，初始化为当前类的对象
  3. 提供一个public static 返回当前类型的方法，用来返回该唯一对象

~~~java
//单例类  饿汉模式
public class Singleton1 {

    static final Singleton1 only = new Singleton1();

    private Singleton1() {

    }

    public static Singleton1 getSingleton1() {
        return only;
    }
}
~~~

~~~java
//测试类
public class Test {
    public static void main(String[] args) {
        Singleton1 s1  = Singleton1.getSingleton1();

    }
}
~~~

- 懒汉模式：

  1. 构造方法私有化
  2. 提供 `static  当前类型的成员变量`
  3. 提供一个`public static` 返回当前类型的方法，判断成员变量是否为空，如果为空则创建唯一对象，返回该唯一对象

  注意： 懒汉模式需要做线程同步

~~~java
public class Singleton2 {

    static Singleton2 only;

    private Singleton2() {

    }

    public synchronized static Singleton2 getSingleton1() {
        if (only == null)
            only = new Singleton2();
        return only; 
    }
}
~~~

#### 工厂模式

提供一个工厂类，将创建的对象的工作封装起来，提供公共的静态的工厂方法给访问者调用，返回它所需要的对象

- 静态工厂模式：创建对象以及封装对象的过程放在静态代码块中，用户无需创建工厂，而可以直接调用静态的工厂方法获得产品对象

~~~java
public class Car {
    private String cno;
    private String brand;
    private double price;

    @Override
    public String toString() {
        return "Car{" +
                "cno='" + cno + '\'' +
                ", brand='" + brand + '\'' +
                ", price=" + price +
                '}';
    }

    public Car(String cno, String brand, double price) {
        this.cno = cno;
        this.brand = brand;
        this.price = price;
    }

    public Car() {
    }


    public String getCno() {
        return cno;
    }

    public void setCno(String cno) {
        this.cno = cno;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}
~~~

~~~java
public class CarFactory {


    private static Map<String, Car> map = new HashMap<>();

    static {
        map.put("1001", new Car("1001", "Audi", 300000.0));
        map.put("1002", new Car("1002", "Ford", 150000.0));
        map.put("1003", new Car("1003", "Volvo", 200000.0));

    }

    public static Car getCar(String id) {
        return map.get(id);
    }
}
~~~

~~~java
public class Test2 {

    public static void main(String[] args) {
        Car car = CarFactory.getCar("1002");
        System.out.println(car);
    }
}
~~~

- 实例工厂模式：创建对象以及封装对象的过程放在工厂类的构造方法中，用户首先需要创建工厂对象，然后通过工厂对象调用工厂方法

~~~java
public class CarFactory2 {
    private static Map<String, Car> map;

    CarFactory2() {
        map = new HashMap<>();
        map.put("1001", new Car("1001", "Audi", 300000.0));
        map.put("1002", new Car("1002", "Ford", 150000.0));
        map.put("1003", new Car("1003", "Volvo", 200000.0));

    }

    public static Car getCar(String id) {
        return map.get(id);
    }
}
~~~

~~~java
public class Test3 {

    public static void main(String[] args) {
        CarFactory2 cf2 = new CarFactory2();
        Car car = cf2.getCar("1003");
        System.out.println(car);
    }
}
~~~

#### 代理模式

首先要有主题业务，在主题业务的周边还存在许多次要的业务，代理类就是负责处理主题业务的同时再去处理这些周边的业务

这样一来，主体类只需要专注于主体业务，降低了程序的耦合度

实际操作过程中，我们需要提供业务的接口，主体类和代理类同时实现该接口，代理类中包含主体类的对象，并在业务方法中调用主体方法，同时执行其他周边的业务操作

~~~java
public interface CarSale {

    public void sale();
}
~~~

~~~java
//主体类
public class CarFactory implements CarSale {


    private static Map<String, Car> map = new HashMap<>();

    static {
        map.put("1001", new Car("1001", "Audi", 300000.0));
        map.put("1002", new Car("1002", "Ford", 150000.0));
        map.put("1003", new Car("1003", "Volvo", 200000.0));

    }

    public static Car getCar(String id) {
        return map.get(id);
    }


    @Override
    public void sale() {
        System.out.println("工厂正在卖车");
    }
}
~~~

~~~java
//代理类
public class Car4s implements CarSale {
    CarFactory cf = new CarFactory();

    @Override
    public void sale() {
        System.out.println("办个车展");
        System.out.println("开展促销优惠活动");
        cf.sale();
        System.out.println("帮忙上保险");
        System.out.println("帮忙上牌照");
        System.out.println("提供售后服务");

    }
}
~~~

~~~java
 public static void main(String[] args) {
        CarSale cs = new Car4s();
        cs.sale();
    }
~~~

## 第十一天

### 反射

当某个类加载到内存中的静态代码区时，系统自动创建Class类的对象，这个对象称为反射对象，它就像一面镜子一样把当前类的所有成员变量及方法看的清清楚楚。它还可以创建当前类的对象，调用当前类的方法

获取Class对象的三种方式：

1. `类名.class`
2. `Class.forName("当前类的全类名")`
3. `对象名.getClass()`

~~~java
        System.out.println("获取Class对象的三种方式---------------------------");
        System.out.println("第一种：");
        Class c1= Person.class;
        System.out.println(c1);
        System.out.println("第二种：");
        Class<Person> c2 = null;
        try {
            c2 = (Class<Person>)Class.forName("com.iweb.test9.Person");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(c2);
        System.out.println("第三种:");
        Person p1 = new Person();
        Class c3 = p1.getClass();
        System.out.println(c3);
~~~

我们可以通过Class对象调用`getFields()`得到当前类中的public的成员变量，返回Field 数组

也可以调用`getDeclaredFields()`得到当前类中的所有成员变量，返回Field数组

注意：在反射看来，每一个成员变量其实都是Field对象

~~~java
        Field[] fields1 = c2.getFields();
        System.out.println("Person类中public方法数目为：" + fields1.length);
        for(Field field : fields1){
            System.out.println(field);
        }
        Field[] fields2 = c2.getDeclaredFields();
        System.out.println("Person类中所有方法数目为："  + fields2.length);
        for (Field field : fields2) {
            System.out.println(field);
        }
//打印结果
Person类中public方法数目为：1
public java.lang.String com.iweb.test9.Person.pno
Person类中所有方法数目为：3
public java.lang.String com.iweb.test9.Person.pno
private java.lang.String com.iweb.test9.Person.pname
private java.lang.String com.iweb.test9.Person.page
~~~

我们可以通过Class对象调用`getDeclaredMethods()`获取当前类中的所有方法，返回Method数组

我们可以通过Class对象调用`getDeclaredConstructor()`获取当前类中所有的构造方法，返回Constructor数组

注意：构造方法不属于传统意义的方法，只是名字类似

~~~java
System.out.println("----------------------------------------------");
Method[] methods = c2.getDeclaredMethods();
System.out.println(methods.length);
for (Method method : methods) {
	System.out.println(method);
}
System.out.println("----------------------------------------------");
Constructor[] constructors = c2.getDeclaredConstructors();
for (Constructor constructor : constructors) {
	System.out.println(constructor);
}
~~~

我们可以调用Class对象的`newInstance()`方法来获取当前类的对象，我们还可以调用Class对象的`getField("成员变量名")`获取某个public的成员变量的Field对象

我们通过Field调用set方法传入当前类对象和属性值来给成员变量赋值

~~~java
            Person p1 = c2.newInstance();
            Field f1 = c2.getField("pno");//获取当前类中指定的成员变量
            f1.set(p1, "1001");
            System.out.println(p1);
~~~

我们可以通过Class调用`getDeclaredConstructor()`传入参数的反射对象来得到Constructor对象，在由该类Constructor对象调用newInstance方法去执行有参构造方法来得到当前类的对象

~~~java
            Person p2 = null;
            Constructor<Person> c4 = c2.getDeclaredConstructor(String.class, String.class, String.class);
            p2 = c4.newInstance("1002", "Jerry", "20");
            System.out.println(p2);
~~~

对于非public的成员变量，我们可以通过Class对象调用getDeclaredField("变量名")得到Field对象，然后将Field调用setAccessible(true)进行授权

最后才可以调用set()方法进行赋值

~~~java
            Field f3 = c2.getDeclaredField("page");
            f3.setAccessible(true);
            f3.set(p1, "20");
            System.out.println(p1);
~~~

我们可以通过Class对象调用getDeclaredMethod("方法名")获取对应的Method对象，再由Method对象调用invoke(当前类对象)完成无参方法调用

~~~java
            Method m1 = c2.getDeclaredMethod("show");
            m1.invoke(p2);
~~~

我们可以通过Class对象调用getDeclaredMethod(方法名,参数类型的Class对象)获取对应的Metho的对象，再由Method对象调用Invoke(当前类对象,参数值)完成对有参方法的调用

~~~java
            Method m2 = c2.getDeclaredMethod("display", String.class);
            m2.invoke(p2,"中国");
~~~



### &和&&区别

区别在于 & 两边都运算，而 && 先算 && 左侧，若左侧为 false 那么右侧就不运算了。因此从效率上来说，判断语句中推荐使用 &&





























# 问题

---
title:  笔记_003_数据结构
tag: 
	- 数据结构
categories: 
	- java
---

## 1. List

~~~java
//List 接口
public interface List {

    public int size();//返回当前List的长度

    public Object get(int i);//返回指定下标处的元素

    public boolean isEmpty();//判断当前数组是否为空

    public void add(Object e);//将传入的元素e插入到当前List集合最后一个位置

    public void add(int i,Object e);//在指定下标位置插入指定元素
}
~~~

#### 下标越界异常

~~~java
public class MyIndexOutOfBoundsException extends RuntimeException {
    public MyIndexOutOfBoundsException() {
    }

    public MyIndexOutOfBoundsException(String message) {
        super(message);
    }
}
~~~

### 1. ArrayList

~~~java
//ArrayList  动态数组
public class ArrayList implements List {

    private Object[] elementData;//底层的数组
    private int size;//当前集合中的元素个数

    public ArrayList() {
        elementData = new Object[4];
        size = 0;
    }

    public ArrayList(int initialCapacity) {
        elementData = new Object[initialCapacity];
        size = 0;
    }


    @Override
    public int size() {
        return size;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size) {
            throw new MyIndexOutOfBoundsException("对不起，下标越界了！越界下标为：" + i);
        }
        return elementData[i];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public void add(Object e) {

//        if (size == elementData.length) {
////            //扩容
////            //创建一个新数组，长度是旧数组的1.5倍
////            Object[] newArr = new Object[elementData.length + (elementData.length >> 1)];
////            //将旧数组拷贝到新数组
////            for (int i = 0; i < elementData.length; i++) {
////                newArr[i] = elementData[i];
////            }
////            //将旧数组的变量指向新数组
////            elementData = newArr;
//            grow();
//        }
//        elementData[size] = e;
//        size++;
        this.add(size, e);
    }


    @Override
    public void add(int i, Object e) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundsException("对不起，下标越界了！越界下标为：" + i);
        }
        if (size == elementData.length) {
            grow();
        }
        //依次后移
        for (int j = size; j > i; j--) {
            elementData[j] = elementData[j - 1];
        }
        elementData[i] = e;
        size++;
    }


    //扩容
    public void grow() {
        elementData = Arrays.copyOf(elementData, elementData.length + (elementData.length >> 1));

    }

    @Override
    public String toString() {
        if (size == 0) {
            return "[]";
        } else {
            StringBuffer stringBuffer = new StringBuffer("[");
            for (int i = 0; i < size - 1; i++) {
                stringBuffer.append(elementData[i]).append(",");
            }
            stringBuffer.append(elementData[size - 1]).append("]");
//            for (int i = 0; i < size; i++) {
//                if (i != size - 1) {
//                    stringBuffer.append(elementData[i]).append(",");
//                } else {
//                    stringBuffer.append(elementData[i]).append("]");
//                }
//            }
            return stringBuffer.toString();
        }
    }
}
~~~

~~~java
//测试类
public class Test {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(000);
        list.add(100);
        list.add(200);
        list.add(300);
        list.add(400);
        list.add(500);
        list.add(2, 999);
        System.out.println("动态数组长度:" + list.size());
        System.out.println("动态数组是否为空：" + list.isEmpty());
        System.out.println("遍历动态数组-------------------");
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i) + "  ");
        }
        System.out.println();
        System.out.println("测试toString方法-------------------");
        System.out.println(list);
    }
}
~~~



### 2. SingleLinkedList

~~~java
//单链表
public class SingleLinkedList implements List {


    Node head = new Node(); //头结点  里面不存数据
    int size; //一共多少个节点


    @Override
    public int size() {
        return size;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundsException("对不起，下标越界了！");
        }
        Node p = head;
        for (int j = 0; j <= i; j++) {
            p = p.next; //p指向下表为i的元素
        }
        return p.getData();


    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public void add(Object e) {
        this.add(size, e);

    }

    @Override
    public void add(int i, Object e) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundsException("对不起，下标越界了！");
        }
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        Node newNode = new Node();
        newNode.data = e;
        newNode.next = p.next;
        p.next = newNode;
        size++;
    }


    @Override
    public String toString() {
        if (size == 0) {
            return "[]";
        } else {

            StringBuffer stringBuffer = new StringBuffer("[");
            Node p = head;
            for (int i = 0; i < size - 1; i++) {
                p = p.next;
                stringBuffer.append(p.getData()).append(",");
            }
            stringBuffer.append(p.next.getData()).append("]");
            return stringBuffer.toString();
        }
    }
}
~~~

~~~java
//测试类
public class Test2 {
    public static void main(String[] args) {
        List list = new SingleLinkedList();
        list.add(100);
        list.add(200);
        list.add(300);
        list.add(400);
        list.add(500);
        list.add(2, 999);
        System.out.println("单链表长度:" + list.size());
        System.out.println("单链表是否为空：" + list.isEmpty());
        System.out.println("遍历单链表-------------------");
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i) + "  ");
        }
        System.out.println();
        System.out.println("测试toString方法-------------------");
        System.out.println(list);
    }
}
~~~

## 2. 二叉树

~~~java
//BinaryTree 接口
public interface BinaryTree {

    //是否是空树
    public boolean isEmpty();

    //节点的数量
    public int size();

    //获取二叉树的高度
    public int getHeight();

    //根据节点值查找指定的节点
    public Node findKey(int value);

    //先序遍历
    public void preOrderTravers();

    //中序遍历
    public void inOrderTravers();

    //后序遍历
    public void postOrderTravers();

    //从指定的节点开始先序遍历
    public void preOrderTravers(Node node);

    //从指定的节点开始中序遍历
    public void inOrderTravers(Node node);

    //从指定的节点开始后序遍历
    public void postOrderTravers(Node node);

    //层次遍历整个二叉树
    public void levelOrderByStack();

}
~~~

~~~java
//Node k
public class Node {

    Object value;//节点的值
    Node leftChild;//左孩子
    Node rightChild;//右孩子

    public Node() {
    }

    public Node(Object value, Node leftChild, Node rightChild) {
        this.value = value;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Node getLeftChild() {
        return leftChild;
    }

    public void setLeftChild(Node leftChild) {
        this.leftChild = leftChild;
    }

    public Node getRightChild() {
        return rightChild;
    }

    public void setRightChild(Node rightChild) {
        this.rightChild = rightChild;
    }
}
~~~





~~~java
public class LinkedBinaryTree implements BinaryTree{
    Node root;
    
    public LinkedBinaryTree(){
        
    }
    public LinkedBinaryTree(Node root){
        this.root = root;
    }
    public Node getRoot(){return root;}
    public void setRoot(Node root){this.root = root;}

    @Override
    publlic 
}
~~~







---
title:  笔记_004_数据库
tag: 
	- 数据库
categories: 
	- java
---

### 数据库表结构的设计：

找名词，将名词分为 实体和属性

每个实体一张表，每个属性一个字段

确定表与表的关系：

- 一对一： 将一张表的编号字段添加到另一张表中作为关键字段
- 一对多：将一的一端的编号添加到多的一端表中作为关联字段
- 多对多：新建一张关系表，它记录着两端的编号

 ER图 ---- 这是一个数据库表结构设计的辅助工具 矩形表示表，椭圆表示字段，菱形表示关系

员工关系系统需求：公司的每个部门中包含各自的员工，部门需要统计编号，名称所在地。员工需要统计编号，姓名

#### 范式：数据库表设计的规范

- 第一范式：列不可分
- 第二范式：要有主键，不存在部分依赖
- 第三范式：不存在传递依赖

# 日期 2022-7-16

## sql

对数据库操作的标准语言

DDL ---- 数据定义语言：针对数据库对象进行操作的语言

DML ---- 数据操纵语言：针对数据进行操作的语言

### 创建一张表：

~~~~plsql
create table 表名(
    字段名1 类型,
    字段名2 类型,
    ...
)
~~~~

### 插入一条记录：

~~~plsql
insert into 表名(字段名1,字段名2,...)values('值1','值2',...)
-- 注意：values前面的小括号决定了要对那些字段插值，如果对所有的字段插值，则values前面的小括号可以省略不写
insert into cominfo0716
  (cno, cname, phone, address, email)
values
  ('1001', '张三', '123655', '江苏省', '12@qq.com');
~~~

### 查询记录：

~~~plsql
select 字段列表 from 表名  
-- 注意：* 表示所有字段
select * from COMINFO0716 t
~~~

### 删除记录：

~~~plsql
delete from 表名 where 条件
delete from cominfo0716 where cno = '1001';
~~~

### 删除表：

~~~plsql
drop table 表名
~~~

### Oracle中的数据类型：

- `varchar2(长度)` ---- 不定长的字符串
- `integer` ---- 整型
- `date` ---- 日期型
- `number(长度,小数位)` ---- 浮点型
- `to_date('日期字符串','日期格式')` ---- 将字符串转日期型，在日期格式中y表示年，m表示月，d表示日

~~~plsql
create table cominfo0716(
       cno varchar2(20),
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2)
);

insert into cominfo0716
values
  ('1003',
   '王五',
   '14343655',
   '江苏省',
   '12111@qq.com',
   '1208196222',
   to_date('1998-07-01', 'yyyy-mm-dd'),
   '70.75');
~~~

h表示小时

mi表示分钟

s表示秒

~~~plsql
insert into cominfo0716
values
  ('1005',
   '赵六',
   '14343655',
   '江苏省',
   '12111@qq.com',
   '1208196222',
   to_date('1998-07-01 20:03:08', 'yyyy-mm-dd hh24:mi:ss'),-- hh24表示24小时制 hh表示12小时制
   '117.714111');-- 超出精度的小数会自动四舍五入 超出精度的整数会报错
~~~

### 修改记录：

~~~plsql
update 表名 set 字段名1 = 新值,字段名2 = 新值2...
where 条件语句
~~~

### 约束：

限定表中的数据必须满足某种要求

- not null ---- 该字段值不能为空
- unique ---- 唯一约束，该字段值不能重复

~~~plsql
create table cominfo0716(
       cno varchar2(20) not null,-- 该字段值不能为空
       cname varchar2(20),
       phone varchar2(20) unique, -- 该字段值不能重复
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2)
);
~~~

~~~plsql
-- 注意：还可以使用constraint 自定义名字 unique() 表示该字段唯一
create table cominfo0716(
       cno varchar2(20) not null,
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2),
       constraint uk0716 unique(phone) -- 表示该字段唯一
);
~~~

- primary key ---- 主键约束，它包含了非空和唯一

  注意：还可以使用 constraint 自定义名字 primary key(字段)表示该字段为主键；

~~~plsql
create table cominfo0716(
       cno varchar2(20) primary key,
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2),
       constraint uk0716 unique(phone)
);


create table cominfo0716(
       cno varchar2(20),
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2),
       constraint uk0716 unique(phone),
       constraint uk0716 primary key(cno)-- 小括号里如果是多个字段则为联合主键
);
~~~

- 外键约束 ---- 将被关联表的主键字段添加到当前表中当作外键，两层约束：

  1. 当插入从表中的数据时，其外键值必须存在于主表中
  2. 当删除主表中的数据时，其主键值必须没有被从表关联

  语法：在外键字段后添加 references 主表名(主表主键名)

~~~plsql
create table class0716(
cno varchar2(32) primary key,
cname varchar2(32)
);

create  table student0716(
sno varchar2(32) primary key,
sname varchar2(32),
sage integer,
cno varchar2(32) references class0716(cno)
);
~~~

~~~plsql
-- 注意：也可以使用constraint 自定义名称 foreign key(字段名) references 主表名(主表主键名) 来创建外键
create  table student0716(
sno varchar2(32) primary key,
sname varchar2(32),
sage integer,
cno varchar2(32),
constraint fk0716 foreign key(cno) references class0716(cno)
);
~~~

# 日期 2022-07-18

### sql语句中的别名：

我们可以在表名和字段名的后面添加空格 别名

别名在当前语句中就指代这个表或字段

我们可以通过表的别名自动补出字段名

~~~plsql
select * from teacher t;
select t.tno 编号,t.tname 姓名,t.tage 年龄 from teacher t;
~~~

### distinct关键字

在结果集所有字段有重复的情况下可以用来排重

~~~plsql
select  distinct t.tname 姓名 from teacher t;
~~~

### order by

排序，注意：在排序字段后 asc表示升序(可以缺省) desc表示降序

~~~plsql
select * from teacher order by tno desc;
~~~

注意：order by 后面可以跟多个字段，按照先后的优先级依次排序

### where子句

条件查询，它写在from子句的后面，用来条件查询

### between 下限 and 上限

表示在下限和上限之间(两边都闭)  等价于 `xx >= 下限 and xx <= 上限`

### and

多个条件如果是并且关系 用and连接

### 空值的判断

is null ---- 为空

is not null ---- 不为空

### 不等于 <>

注意：oracle中还支持  != 

注意：关于优先级的问题 我们可以使用小括号将自己认为先算的表达式括起来即可

### in

表示在指定范围内进行匹配，查询出符合要求的记录

~~~plsql
select * from teacher t where t.birplace in('北京','上海','江苏','浙江');
~~~

注意： not in 表示不在指定范围内

### like

模糊查询

~~~plsql
-- 全匹配： 字段名 like '%关键字%'
select * from teacher t where t.birplace like '%江%';
-- 左匹配：字段名 like '关键字%'
select * from teacher t where t.birplace like '江%';
-- 右匹配：字段名 like '%关键字'
select * from teacher t where t.birplace like '%江';
~~~

### 聚合函数

1. sum() 函数 ---- 求和

~~~plsql
select sum(t.sal) 男教师薪资综合 from teacher t where t.tsex = '男';
~~~

2. count() ---- 计数 可以传入    *  主键  1

~~~plsql
select count(*) from teacher t where t.tsex = '男';
select count(tno) from teacher t where t.tsex = '男';
select count(1) from teacher t where t.tsex = '男';
~~~

3. max() ---- 最大值
4. min() ---- 最小值
5. avg() ---- 平均值

~~~plsql
select max(t.tage) from teacher t;
select min(t.tage) from teacher t;
select round(avg(t.tage),0) from teacher t;
~~~

### round(数值,小数位)

以四舍五入的方式保留小数位

### group by

`group by 分组字段` ---- 就会按照指定字段进行分组

~~~plsql
-- 查询男女老师的人数
select count(*),t.tsex from teacher t group by t.tsex;
-- 查询各个籍贯人数
select count(*),t.birplace from teacher t group by t.birplace;
~~~

分组往往伴随着聚合函数

注意：select 后面的非函数字段，必须是group by 表达式

### having子句

对分组统计后的函数结果进行条件过滤，需要使用having子句，它写在group by后面

~~~plsql
-- 统计那些籍贯不止一个老师，展示籍贯和教师数
select count(*),t.birplace from teacher t 
where t.birplace is not null
group by t.birplace
having count(*) > 1;
~~~

### 子查询

一个查询语句的结果是另一个查询语句的条件，那么该查询语句就是子查询

注意：子查询只能查一个字段当作条件值

~~~plsql
--统计李树标同系别的其他老师的信息
--1.查询李树标的系别编号
--2.查询哪些教师的系别编号是该编号
select * from teacher t1 where t1.dno = (
select t.dno from teacher t where t.tname = '李树标')
and t1.tname <> '李树标';
~~~

### 多表查询

我们可以在from子句中写入多张表，逗号分隔

注意：我们还需要在where子句中编写他们的关联条件，如果关联条件不够，则会出现笛卡尔集的错误

~~~plsql
select t.tname,d.dname from teacher t,department d where t.dno = d.dno;
~~~

~~~plsql
-- 查询每个教师的姓名以及他们所教课程的名字
select t.tname, c.cname
  from teacher t, course c, t_course tc
 where t.tno = tc.tno
   and tc.cno = c.cno;
~~~

多表查询也可以使用子查询的写法，首先查出某张表关联字段的值，然后将该值带入外层查询作为条件

~~~plsql
--查询计算机系的老师的编号和姓名
select t.tno,t.tname from teacher t,department d
where t.dno = d.dno
and d.dname = '计算机系';

--1.查询计算机系的系别编号
--2.查询该编号下的老师信息
select t.tno, t.tname
  from teacher t
 where t.dno = (select d.dno from department d where d.dname = '计算机系');
~~~



### 左外关联

左边的表，所有记录全部展示

右边的表，如果关联到记录，就展示数据，否则字段值留空

语法：

~~~plsql
select 字段列表 from 左表 left join 右表 on 关联条件
~~~

~~~plsql
-- 查询老师名字和部门名字
select t.tname, d.dname
  from teacher t
  left join department d
    on t.dno = d.dno;
~~~

注意：inner join表示内连接，相当于传统的多表关联   inner可以省略

注意：Oracle数据库中可以使用传统关联的写法，在关联条件的一边添加（+），使得另一边全部展示

### union	并集

多条select语句，他们之间如果结果集的字段个数和类型都一样，那么可以添加union来求他们的并集

~~~plsql
 --统计全校所有男同胞的姓名
 select t.tname from teacher t where t.tsex = '男'
 union
 select s.sname from student s where s.sex = '男'; 
~~~

注意：union自带排重效果，union all不会排重（比如上例中老师学生名字一样就给排除了）

### intersect	交集

~~~plsql
-- 统计赵汗青和韩信选了哪些相同的课展示课程名称
select c.cname from course c ,s_course sc,student s
where c.cno = sc.cno and sc.sno = s.sno and s.sname = '赵汗青'
intersect
select c.cname from course c ,s_course sc,student s
where c.cno = sc.cno and sc.sno = s.sno and s.sname = '韩信';
~~~

### minus	差集

~~~plsql
-- 统计赵汗青选了哪些课但韩信没有选，展示课程名称
select c.cname from course c ,s_course sc,student s
where c.cno = sc.cno and sc.sno = s.sno and s.sname = '赵汗青'
minus
select c.cname from course c ,s_course sc,student s
where c.cno = sc.cno and sc.sno = s.sno and s.sname = '韩信';
~~~

### to_char(date字段，日期格式)

将日期格式转字符串

`to_char(date字段,'yyyy-mm-dd hh24:mi:ss')`

sysdate ---- 当前时间

~~~plsql
select s.sno,
        s.sname,
        to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy')  -- 返回年龄
   from student s
  where s.sno in (select sc.sno from s_course sc where sc.mark < 60);
~~~



~~~plsql
 -- 查询“大学英语”最高分同学资料
 select s.sno,
        s.sname,
        to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age,
        sc.mark
   from student s, s_course sc, course c1
  where s.sno = sc.sno
    and sc.cno = c1.cno
    and c1.cname = '大学英语'
    and sc.mark = (select max(sc1.mark)
                     from s_course sc1, course c
                    where sc1.cno = c.cno
                      and c.cname = '大学英语');
~~~

# 日期 2022-07-19

~~~~plsql
--统计同时选修了'java基础'和'高等数学'这两门课的同学
--并且他们的'java基础'的成绩要比'高等数学'高，展示这些同学的信息
select *
  from student s
 where s.sno in
       (      
        select sc1.sno
          from s_course sc1, s_course sc2
         where sc1.sno = sc2.sno
           and sc1.cno =
               (select c.cno from course c where c.cname = 'java基础')
           and sc2.cno =
               (select c1.cno from course c1 where c1.cname = '高等数学')
           and sc1.mark > sc2.mark);
~~~~

### 临时表

在我们使用sql语句的过程中，可以借助临时表将我们需要的中间数据先查出来，然后再针对临时表进行查询，可以逐步简化我们的思路

格式：

~~~plsql
with 临时表名1 as(select 语句),
	临时表名2 as(select 语句)
	...
总的select语句
~~~

~~~plsql
--统计同时选修了'java基础'和'高等数学'这两门课的同学
--并且他们的'java基础'的成绩要比'高等数学'高，展示这些同学的信息
--临时表
with table1 as
 (select s.sno, s.sname, s.sex, sc.mark
    from student s, s_course sc, course c
   where s.sno = sc.sno
     and sc.cno = c.cno
     and c.cname = 'java基础'),
table2 as
 (select s.sno, s.sname, s.sex, sc.mark
    from student s, s_course sc, course c
   where s.sno = sc.sno
     and sc.cno = c.cno
     and c.cname = '高等数学')
select *
  from table1, table2
 where table1.sno = table2.sno
   and table1.mark > table2.mark;
~~~

~~~plsql
--统计所有偏科厉害的同学信息
--存在挂科
--个人均分大于所有人总均分
with t1 as
 (select sc.sno, trunc(avg(sc.mark), 1) avgmarkper
    from s_course sc
   group by sc.sno)
select *
  from student s, t1, s_course sc1
 where s.sno = t1.sno
   and s.sno = sc1.sno
   and sc1.mark < 60
   and t1.avgmarkper > (select avg(mark) from s_course);
~~~

### trunc(数值,小数位)

直接丢弃的方式保留小数位

### substr(字符串,起始位置,截取长度)

从指定位置开始截取指定的长度

~~~plsql
select substr('hello',2,2) from dual;-- el  数据库下标从1开始
select substr(c.cname,1,2) from course c;
~~~

注意：从右往左截取，两种方式：

1. substr(字符串,length(字符串) - 截取长度 + 1,截取长度)
2. substr(字符串,- 从右边开始的位数,截取长度)

~~~plsql
-- 截取末尾两位   jk
select substr('abcdefghijk',length('abcdefghijk') - 2 + 1,2) from dual;
select substr('abcdefghijk',-2,2) from dual;
~~~

### length(字符串)

返回字符串的长度

~~~plsql
select length('hello') from dual;
~~~

### case 语句

用来根据表中的数据进行业务逻辑判断，将结果展示为一个新的字段

注意：整个case语句写在select子句中

~~~plsql
--语法1：
case 
when 条件1 then 结果1
when 条件2 then 结果2
...
else
结果n
end

--例如：
select sc.sno,
       trunc(avg(sc.mark), 1) avgmarkper,
       case
         when trunc(avg(sc.mark), 1) < 60 then
          '差'
         when trunc(avg(sc.mark), 1) < 80 then
          '中'
         when trunc(avg(sc.mark), 1) < 90 then
          '良'
         when trunc(avg(sc.mark), 1) <= 100 then
          '优'
         else
          '其他'
       end dj
  from s_course sc
 group by sc.sno;
~~~

~~~plsql
--语法2：
case 字段 
when 值1 then 结果1
when 值2 then 结果1
...
else
结果n
end

--例如
 select s.sno,
        s.sname,
        case s.sex
          when '男' then
           'boy'
          when '女' then
           'girl'
          else
           'other'
        end gender
   from student s;
~~~

~~~plsql
-- 列转行
select t.student,
       sum(case t.course
             when '语文' then
              t.score
             else
              null
           end) 语文,
       
       sum(case t.course
             when '数学' then
              t.score
             else
              null
           end) 数学,
       
       sum(case t.course
             when '英语' then
              t.score
             else
              null
           end) 英语,
       
       sum(case t.course
             when '物理' then
              t.score
             else
              null
           end) 物理

  from test t
 group by t.student;
~~~

### 列转行 unpivot()
~~~plsql
with temp as(
    select '四川省' nation ,'成都市' 第一,'绵阳市' 第二,'德阳市' 第三,'宜宾市' 第四  from dual 
    union all
    select '湖北省' nation ,'武汉市' 第一,'宜昌市' 第二,'襄阳市' 第三,'' 第四   from dual
)
select nation,name,title from
temp
unpivot
(name for title in (第一,第二,第三,第四))t
~~~

### decode(字段名,值1,结果1,值2,结果2,...)

可以取代case语句的第二种格式

~~~plsql
select s.sno,
s.sname,
decode(s.sex,'男','boy','女','girl','other') gender
from student s;
~~~

~~~plsql
-- 列转行
select t.student ,
sum(decode(course,'语文',t.score)) 语文,
sum(decode(course,'数学',t.score)) 数学,
sum(decode(course,'英语',t.score)) 英语,
sum(decode(course,'物理',t.score)) 物理
from test t
group by t.student;
~~~

### 视图

存储下来的select语句

作用：

1. 简化查询
2. 控制访问权限

创建视图的语法：

~~~plsql
create or replace view 视图名 
as select语句
~~~

注意：我们就像查询表一样去查询视图

注意：我们可以在as之前添加小括号，里面写视图的字段名

~~~plsql
create or replace view myview0719
(编号,姓名,工作)
as
select t.empno ,t.ename ,t.job from emp t;

select * from myview0719 
~~~

对视图的增删改操作，其实是在操作它背后的那张基表中的数据

简单视图指的是单表查询，没有分组和函数；其他的视图称为复杂视图

简单视图可以增删改操作，而复杂视图不允许增删改操作

创建一个视图可以在创建语句的最后添加  with read only将当前视图设置为只读视图，不允许做增删改操作

~~~plsql
create or replace view myview001
as
select t.empno ,t.ename ,t.job from emp t
with read only;
~~~

#### 删除视图

drop view 视图名

我们可以快速创建一张表并向表中添加select结果的数据

~~~plsql
create table 表名 as
select语句
~~~

### rowid

伪列，它存放着当前这条记录在文件中的位置

我们在select语句中添加rowid可以实现直接在图形化界面上进行操作

~~~plsql
select e.*,e.rowid from emp e;
~~~

我们也可以在select语句结尾添加for update 来完成图形化操作(这种方法不推荐)

~~~plsql
select e.* from emp e for update;
~~~

### rownum

也叫伪列，它存放在当前结果集中的行号

~~~plsql
select e.*,rownum from emp e;
~~~

如果我们的select语句需要排序，那么先排序，然后在外层嵌套while子句，对rownum进行条件过滤

~~~plsql
select e.*, rownum
  from (select * from emp order by sal desc) e
 where rownum <= 10;
~~~

rownum只支持 < 和 <= 

我们可以对rownum 起别名，然后在外层对别名进行过滤，就可以使用其他的符号

~~~plsql
select * from (
select e.*, rownum rn
  from (select * from emp order by sal desc) e
 where rownum <= 10)
 where rn > 5 and rn <=10;
~~~

### 分页查询

~~~plsql
select * from (
select e.*, rownum rn
  from (select * from emp order by sal desc) e)
 where rn > 每页条数 * (页码 - 1) and rn <= 每页条数 * 页码;
~~~

### 序列

sequence ---- 用来返回唯一数值的数据库对象

它通常采用递增的方式保证数据的唯一

创建序列：

~~~plsql
create sequence 序列名
start with 起始值
increment by 递增值
maxvalue 最大值;

--测试
create sequence myseq0718
start with 1
increment by 1
maxvalue 99999999999999999999999;

select myseq0718.nextVal from dual;
~~~

~~~plsql
使用序列：
序列名.nextVal

查看序列：
序列名.currVal
~~~

~~~plsql
insert into course values(myseq0718.Nextval,'嘿嘿嘿嘿',32);--在插入数据时使用序列。如果执行后回滚数据，使course表中没有新加入的这条数据，那么序列也会自增，意味着浪费了部分序列
~~~

删除序列

~~~plsql
drop sequence 序列名
~~~

### 索引

index ---- 为了提高数据库根据某字段查询的速度的一种数据库对象，它是添加到字段上的。

自动添加：当某个字段是主键，或者有唯一约束时，自带索引

手动添加：create index 索引名 on 表名(字段名);

考虑什么时候加索引：

- 数据量很大
- 该字段经常被当作where 条件，而很少增删改
- 该字段取值范围广

### 游标 cursor
#### 隐式游标
当Oracle执行 `select into` , `insert` , `update` , `delete` sql语句时 ，它会自动创建一个隐式游标，Oracle内部管理整个隐式游标的整个执行周期，并且只暴露出游标的信息和状态 ，例如：`SQL%ROWCOUNT`、 `SQL%ISOPEN`、 `SQL%FOUND` 和`SQL%NOTFOUND`。当查询返回零行或多行时，隐式游标不够优雅，这会分别导致NO_DATA_FOUND或TOO_MANY_ROWS异常。
#### 显示游标
显示游标是再当前快或包规范的声明不为中显式声明的select语句，你可以控制显示游标的整个执行周期 从 `OPEN`，`FETCH`和`CLOSE`。Oracle定义了一个执行周期来执行SQL语句并将游标与之关联。

1.声明一个游标
在使用显式游标之前，你必须声明它。
`CURSOR cursor_name IS query`
上句中，首先在CURSOR关键字之后指定了游标的名字，然后在IS关键字后定义了一个获取数据的查询。

2.打开游标
在开始从游标中获取行之前，你必须先打开游标，你可以使用下面的语法来打开游标。
`OPEN cursor_name`
在这句话中，cursor_name是在声明部分所声明游标的名字。
当你打开游标，Oracle会解析查询，绑定变量并且执行所关联的SQL语句。Oracle也决定了执行计划，将变量和游标参数与SQL语句中的占位符相关联，确定结果集，并将游标设置到结果集中的第一行。




~~~plsql
-- 声明游标
declare cursor cur_student is 
select * from student;
v_student  cur_student%rowtype;
begin

-- 开启游标
open cur_student;

-- 获取数据（一次获取一行）
fetch cur_student into v_student ;
dbms_output.put_line(v_student.id || ' : ' || v_student.name);
 -- 4 关闭游标
  close cur_student;

end;
~~~


# 日期 2022-07-20

## Mysql

1. 查询系统时间

   select now()

2. create table语句

   auto_increment 表示字段值自增长

   datetime表示日期型

   primary key(主键字段)

   注意：语句结尾添加default charset = utf8;表示可以接收中文

   ~~~mysql
   create table stu0720(
   sno integer auto_increment,
   sname varchar(32),
   birthday datetime,
   age integer,
   primary key(sno)
   )default charset = utf8; -- 加上这句可以添加中文数据
   ~~~

3. 主键值的插入使用null

4. 日期字段的插入，直接写字符串

   ~~~mysql
   select * from stu0720;
   
   insert into stu0720(sno,sname,birthday,age)
   values(null,'李四','2000-04-10 20:50:12','22');
   ~~~

5. 日期型转字符串

   ~~~mysql
   date_format(日期字段,'%Y-%m-%d %H:%i:%s')
   
   -- 例如
   select s.sno,s.sname,date_format(s.birthday,'%Y-%m-%d %H:%i:%s') birthday 
   from stu0720 s;
   ~~~

6. 分页查询

   ~~~mysql
   select 语句 limit 起始条数 ,每页多少条
   
   -- 例如
   select * from category limit 8,3;
   ~~~

   注意：查询的结果是从起始条数的下一条开始，不允许在select中写计算公式

# 问题
---
title:  笔记_005_JDBC
tag: 
	- JDBC
categories: 
	- java
---
## JDBC ---- 这是java连接数据库的接口

通常需要
1. 使用 ` Class.forName(驱动类)` 来加载数据库驱动
2. 接着获取`Connection`对象表示数据库的连接
3. 然后获取`Statement`对象表示sql语句
4. 最后获取`ResultSet`对象表示查询的结果集，它通过`Statement`对象调用`excuteQuery(Sql语句)`来执行获取

注意：以上对象在使用完毕后需要调用close方法来进行关闭

固定语句：

~~~java
public class HelloJdbc {

    public static void main(String[] args) {

        Connection conn = null;
        Statement stat = null;

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");//加载驱动
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql", "root", "123456");
            stat = conn.createStatement();//获取sql语句的操作对象
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

}
~~~



例子：

~~~java
public static void main(String[] args) {

        Connection conn = null;
        Statement stat = null;
        ResultSet rest = null;

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");//这是第一步 加载驱动 Driver类的全类名
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql", "root", "123456");//这是第二步 getConnection("jdbc:mysql://xxx.xxx.xxx.xxx:3306/数据库名,"账号","密码")
            stat = conn.createStatement();//这是第三步 获取sql语句的操作对象
            String sql = "select s.sno,s.sname,date_format(s.birthday,'%Y-%m-%d %H:%i:%s') birthday \n" +
                    "from stu0720 s";
            rest = stat.executeQuery(sql);//执行sql语句，返回一个结果集
            while(rest.next()){//遍历每一行
                int sno = rest.getInt("sno");
                String sname = rest.getString("sname");
                String birthday = rest.getString("birthday");
                System.out.println(sno + "," + sname + "," + birthday);
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                if(rest != null)
                {
                    rest.close();
                }
                if(stat != null){
                    stat.close();
                }
                if(conn != null){
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
~~~

# 2022年7月21日

ResultSetMetaData

JDBC 获取结果集中列相关的信息

我们可以通过ResultSet对象调用`getMetaData()`获取该对象

它提供了一些常用方法：

`getColumnCount() ---- 获取列数`

`getColumnName(列数) ---- 获取列名`

对于`ResultSet`来讲，我们还可以通过`getObject(列数)`来获取列值

## 查询

~~~java
public static void main(String[] args) {

        Connection conn = null;
        Statement stat = null;
        ResultSet rest = null;
        ResultSetMetaData rsmd = null;//获取结果集中的列相关的信息

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");//这是第一步 加载驱动 Driver类的全类名
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql", "root", "123456");//这是第二步 getConnection("jdbc:mysql://xxx.xxx.xxx.xxx:3306/数据库名,"账号","密码")
            stat = conn.createStatement();//这是第三步 获取sql语句的操作对象
            String sql = "select s.sno,s.sname,date_format(s.birthday,'%Y-%m-%d %H:%i:%s') birthday,s.age \n" +
                    "from stu0720 s";
            rest = stat.executeQuery(sql);//执行sql语句，返回一个结果集
            rsmd = rest.getMetaData();//获取列相关的信息
            int columnCount = rsmd.getColumnCount();
            while (rest.next()) {
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = rsmd.getColumnName(i);
                    Object columnValue = rest.getObject(i);
                    System.out.print(columnName + "=" + columnValue + "    ");

                }
                System.out.println();

            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null) {
                    rest.close();
                }
                if (stat != null) {
                    stat.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
~~~

## 增删改

我们可以调用`Statement`对象的`executeUpdate(sql语句)`来执行增删改操作

使用JDBC操作Mysql数据库，如果需要操作中文数值，则url后面需要添加参数：`?characterEncoding=utf-8`

~~~java
public static void myJdbc() {

        Connection conn = null;
        Statement stat = null;
        ResultSet rest = null;
        ResultSetMetaData rsmd = null;//获取结果集中的列相关的信息

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");//这是第一步 加载驱动 Driver类的全类名
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8", "root", "123456");//这是第二步 getConnection("jdbc:mysql://xxx.xxx.xxx.xxx:3306/数据库名,"账号","密码")
            stat = conn.createStatement();//这是第三步 获取sql语句的操作对象
            String sql = "insert into stu0720(sno,sname,birthday,age) \n"
                    + "values(null,'李寻欢','2001-03-23',21)"; //增删改的语句写在这里面
            int i = stat.executeUpdate(sql);
            System.out.println("成功操作了：" + i + "条记录");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null) {
                    rest.close();
                }
                if (stat != null) {
                    stat.close();
                }
                if (conn != null) {
                    conn.close();
                }

            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
~~~

## 登录

~~~java
public static void main(String[] args) {
        System.out.println(isLogin("admin","123456"));
    }

    public static boolean isLogin(String username, String password) {

        Connection conn = null;
        Statement stat = null;
        ResultSet rest = null;
        int cou = 0;
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8", "root", "123456");
            stat = conn.createStatement();
            String sql = "select count(*) cou from my_user u\n" +
                    "where u.username = '" + username + "'\n" +
                    "and u.password = '" + password + "'";
            rest = stat.executeQuery(sql);
            while(rest.next()){
                cou = rest.getInt("cou");
            }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally{
            try {
                if(conn != null)
                    conn.close();
                if(stat != null)
                    stat.close();
                if(rest != null)
                    rest.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return cou > 0;
    }
~~~

## 防止sql注入

`PreparedStatement` ----这是一个Statement 接口的子接口，它可以执行sql语句的时候，防止用户进行sql注入

具体步骤：

1. 在sql中需要传入参数的地方使用`?`
2. 将sql语句传入Connection对象的`prepareStatement()`方法得到当前的`PreparedStatement`对象
3. 使用`PreparedStatement`对象调用`setXxx()`方法依次对每一个`?`进行参数绑定，`?`从1开始
4. 调用`executeQuery()`完成sql执行并返回ResultSet结果集

~~~java
public static void main(String[] args) {
        //System.out.println(isLogin("admin","123' or '1' = '1"));
        System.out.println(isLogin("admin", "123456"));
    }

    public static boolean isLogin(String username, String password) {

        Connection conn = null;
        PreparedStatement pstat = null;
        ResultSet rest = null;
        int cou = 0;

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf8", "root", "123456");
            //pstat = conn.createStatement();
            String sql = "select count(*) cou from my_user u where u.username = ? \n" +
                    "and u.password = ? ";
            pstat = conn.prepareStatement(sql);
            pstat.setString(1, username);
            pstat.setString(2, password);
            rest = pstat.executeQuery();//不需要再传入sql
            while (rest.next()) {
                cou = rest.getInt("cou");
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (conn != null)
                    conn.close();
                if (pstat != null)
                    pstat.close();
                if (rest != null)
                    rest.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return cou > 0;
    }
~~~

## MD5加密

我们可以调用`DigestUtils.md5Hex(明文字符串)`  来得到对应的密文字符串

~~~java
public static void main(String[] args) {
        String s1 = "123456";
        s1 = DigestUtils.md5Hex(s1);
        System.out.println(s1);
    }
~~~

## Sha256加密

还可以调用`DigestUtils.shaHex(明文字符串)`来得到对应的密文字符串

~~~java
        String s2 = "123456";
        s2 = DigestUtils.sha256Hex(s2);
        System.out.println(s2);  
~~~

## 工具类(最终版)

~~~java
package com.iweb.test;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JdbcUtil {

    static Connection conn = null;
    static PreparedStatement pstat = null;
    static ResultSet rest = null;


    //获取数据库连接
    private static Connection getConnection() {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            conn = DriverManager.getConnection("jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf8", "root", "123456");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }


    //关闭资源
    private static void closeResource() {
        try {
            if (rest != null)
                rest.close();
            if (pstat != null)
                pstat.close();
            if (conn != null)
                conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    //查询的jdbc
    public static <E> List<Map<String, Object>> queryBySql(String sql, E... e) {
        getConnection();
        List<Map<String, Object>> list = new ArrayList<>();

        try {
            pstat = conn.prepareStatement(sql);
            for (int i = 0; i < e.length; i++) {
                pstat.setObject(i + 1, e[i]);
            }
            rest = pstat.executeQuery();
            ResultSetMetaData rsmd = rest.getMetaData();
            while (rest.next()) {
                Map<String, Object> map = new HashMap<>();
                for (int i = 0; i < rsmd.getColumnCount(); i++) {
                    map.put(rsmd.getColumnName(i + 1), rest.getObject(i + 1));
                }
                list.add(map);
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            closeResource();
            return list;
        }
    }


    //增删改的JDBC
    public static <E> int updateBySql(String sql, E... e) {
        getConnection();//获取连接
        int res = 0;

        try {
            pstat = conn.prepareStatement(sql);
            for (int j = 0; j < e.length; j++) {
                pstat.setObject(j + 1, e[j]);
            }
            res = pstat.executeUpdate();

        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            closeResource();
        }
        return res;
    }
}
~~~

~~~java
//测试查询
public static void main(String[] args) {
        String sql = "select * from fiction";
        List<Map<String, Object>> list = new ArrayList<>();
        list = JdbcUtil.quaryBySql(sql);
        System.out.println(list);
    }
~~~

~~~java
//测试增删改
    public static void main(String[] args) {
        String sql = "insert into my_user values(?,?,'123456')";
        int i = JdbcUtil.updateBySql(sql, "1008", "wangwu");
        System.out.println("成功操作：" + i + "条数据");
    }
~~~

### Oracle数据库的JDBC配置

1. jar:  ojdbc6_g.jar
2. 驱动类： oracle.jdbc.driver.OracleDriver
3. URL: jdbc.oracle:thin:@ip地址:1521:数据库名

~~~java
Class.forName("oracle.jdbc.driver.OracleDriver");
            conn = DriverManager.getConnection("jdbc:oracle:thin:@192.168.77.100:1521:helowin","scott","123456");
~~~

---
title:  笔记_006_HTML
tag: 
	- HTML
categories: 
	- java
---
- - **HTML ---- 超文本标记语言（毛坯）**
- **CSS ---- 层叠样式表（装潢）**
- **JavaScript ---- 页面脚本语言（布局）**

## HTML

### html结构

~~~~html
<html>标签是根标签，包含<head>和<body>
<head> </head>head部分是告诉浏览器如何展示内容
<body> </body>body部分是要展示的具体内容
   bgcolor属性 表示背景色
    我们可以使用 #六位十六进制数 表示一种颜色
    	前两位表示一种红
    	中间两位表示一种绿
    	后两位表示一种蓝
    	当前颜色就是它们叠加出来的颜色
    background属性表示背景图片的路径
<title> </title>表示浏览器选项卡上的标题
<h1></h1>到<h6></h6> 网页上的六级标题
<br/> 一个换行
&nbsp; 一个空格
<hr/> 换行并添加分割线
<P> </p> 表示一个段落
<a></a> 表示超链接，它的href属性表示目标页面的路径
    路径包括绝对路径和相对路径
    绝对路径：从根目录开始的路径<a href="绝对路径"></a>
    相对路径：从当前目录开始的路径
    			./ 表示在当前目录下寻找
    			../ 表示在当前目录的上层目录寻找
    			注意：./ 可以省略
<img> 图片，src属性表示某张图片的路径，路径可以是绝对或相对路径
    width表示图片的宽度，height表示图片的高度，单位是像素
<pre></pre> 保留代码中内容的原始格式
    
~~~~

~~~html
<table></table> 表示一个表格
	border属性表示边框的粗细，默认为0
	cellpadding属性表示内容和边框之间的距离
	cellspacing属性表示单元格之间的距离
<tr></tr>  <table></table>中的一行
<td></td> <tr></tr>中的一个单元格
<th></th> 表示表头，默认加粗和居中
	colspan="n" 表示跨n列
	rowspan属性表示跨行
	height属性表示高度
	width属性表示宽度
	align属性表示对齐方向
		left居左  right居右  center居中
<form></form> 表单，用于信息的录入，表单中有各种的表单控件
	action属性表示提交的目标路径
<input type="text"/> 文本框
<input type="password"/> 密码框
title属性表示鼠标旁边的提示信息
placeholder属性表示显示在控件中的提示信息
<input type="radio"/> 表示单选框
<input type="checkbox"/> 复选框
	name属性相同的为同一组
	checked="checked"表示默认选中
<select></select> 表示下拉框 里面包含若干<option></option>
	每个<option></option> 就是一个下拉选项
	注意：表单空间都包含value属性，表示“值”，随着表单提交传到后端的就是value值
<textarea></textarea> 文本域，可以用来输入一段文字
	rows和cols表示默认的宽度和高度
<input type="submit"/> 表示提交按钮
	value属性表示按钮上显示的文本内容
<input type="reset"/> 表示重置按钮，使得当前表单中所有内容恢复到默认状态
	value属性表示按钮上显示的文本内容
<input type="button" > 普通按钮
注意：<button></button> 在<form></form>之外 也表示普通按钮
~~~



---
title:  笔记_007_CSS
tag: 
	- CSS
categories: 
	- java
---

### css

层叠样式表，用来美化当前页面

格式：

~~~css
选择器{
	属性名1:属性值1;
	属性名2:属性值2;
}
~~~

我们可以将css代码写在`<style type="text/css">`标签中，表示内部样式表 通常写在title下一行

~~~css
		<style type="text/css">
			h2{
				color:red;
			}
		</style>
~~~

注意：在选择器中body和*都是选中全部元素，如果属性冲突，那么越具体的选择器优先级越高

多个选择器可以同时选中，它们以逗号分隔

~~~css
			h4,h5,h6{
				color:pink;
			}
~~~

#### id选择器

可以选择具体某一个元素节点

在任何元素节点中，都可以添加id属性

格式：

~~~css
#id值{
    ...
}
~~~

注意：id不能以数字开头

~~~css
常用属性：
font-size：字体大小
font-weight：字体粗细
~~~

~~~Css
绝对定位		从屏幕的左上角开始偏移
position:absolute;
left:距左边的偏移量 单位像素
top:距顶部的偏移量 单位像素
bottom:
right:
~~~

~~~css
相对定位  		从它初始的位置开始偏移
position:relative;
left:距左边的便宜量 单位像素
top:距顶部的偏移量 单位像素
~~~

~~~css
			#id1001{
				color:aqua;
				font-size:30px;
				font-weight: 900;
				position:relative;
				left:100px;
			}
~~~

#### div

~~~html
<div></div> 块级元素，默认<div></div>之间会换行 它可用来存放其他元素，进行页面的布局
	width 属性表示宽度
	height 属性表示高度
	background-color 表示背景色
	margin-left 表示左边距
	margin-top 表示顶部边距
	margin 表示上下左右的边距，其实就是左边距和上边距
	float 属性表示漂浮，可以使同级div水平排列
		left表示漂浮到左边 right表示漂浮到右边
~~~

~~~html
<head>
    <style>
        div{
			width:100px;
			height:100px;
			background-color:red;
			margin-left:200px;
			margin-top:200px;
        }
    </style>
</head>
<body>
	<div>
		1
	</div>
</body>
~~~

#### `<div>`的水平垂直居中

需要margin:auto 搭配绝对定位上下左右偏移0px来实现

~~~html
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			#d2 {
				width: 600px;
				height: 600px;
				background-color: blue;
				position: absolute;
				left:0px;
				right:0px;
				top:0px;
				bottom:0px;
				margin: auto;

			}
		</style>
	</head>
	<body>

		<div id="d2">
			2
		</div>
	</body>
~~~

#### 简单的页面布局

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			* {
				margin: 0px;
			}

			#top {
				height: 80px;
				background-color: aliceblue;
			}

			#body {
				position: absolute;
				top: 80px;
				left: 0px;
				right: 0px;
				bottom: 30px;
			}

			#bodyleft {
				float: left;
				width: 200px;
				height: 100%;
				/*占它父标签的100%*/
				background-color: antiquewhite;
			}

			#bodyright {
				position: absolute;
				float: right;
				right: 0px;
				left: 200px;
				height: 100%;
				background-color: #00FFFF;

			}

			#foot {
				position: absolute;
				height: 30px;
				left: 0px;
				right: 0px;
				bottom: 0px;
				background-color: burlywood;
				text-align: center;
				/*文字居中*/

			}
		</style>
	</head>
	<body>
		<div id="top">页头部分</div>
		<div id="body">
			<div id="bodyleft">左侧页面</div>
			<div id="bodyright">详细页面</div>
		</div>
		<div id="foot">页脚部分</div>
	</body>
</html>
~~~

#### 表格中的padding属性，用来控制表格内容的边距

~~~html
padding:值1 值2  表示垂直方向和水平方向各自的边距
~~~

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			#td1{
				padding:20px;
			}
			#td2{
				padding:20px 100px;
			}
		</style>
	</head>
	<body>
		<table border="1">
			<tr>
				<td id="td1">我是一个单元格</td>
			</tr>
			<tr>
				<td id="td2">我是一个单元格</td>
			</tr>
		</table>
	</body>
</html>
~~~

#### 表格

~~~html
border:1px black solid;  表格边框的粗细颜色形状
border-collapse:collapse;  合并内外边框
~~~

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			table,
			td {
				border: 1px black solid;
			}

			table {
				border-collapse: collapse;
			}

			td {
				padding: 10px;
			}
		</style>
	</head>
	<body>
		<table>
			<tr>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
			</tr>
			<tr>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
			</tr>
			<tr>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
			</tr>
			<tr>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
				<td>我是一个单元格</td>
			</tr>
		</table>
	</body>
</html>
~~~

#### id选择器的派生选择器

首先选中id值选中某个元素，然后在它里面选中指定的子元素

~~~html
格式：
#id值 元素名{
...
}



<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			#d1 p {
				color: red;
			}
		</style>
	</head>
	<body>
		<div id="d1">
			<p>我是一个段落</p>/*最终只有这个颜色改变*/
			<h1>我是一个标题</h1>
		</div>
		<div id="d2">
			<p>我是一个段落</p>
		</div>
		<p>我是一个段落</p>
	</body>
</html>

~~~

#### 类选择器

可以人为的定义一组元素节点为同一个类，

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			.c1 {
				text-align: center; <!-- 文本居中-->
			}
		</style>
	</head>
	<body>
		<p class="c1">我是一个段落</p>
		<h1 class="c1">我是一个标题</h1>
	</body>
</html>
~~~

类选择器也支持派生选择器的写法

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			.c1 {
				text-align: center;
			}

			.c1 p {
				color: blue;
			}
		</style>
	</head>
	<body>
		<p class="c1">我是一个段落</p>
		<h1 class="c1">我是一个标题</h1>
		<div class="c1">
			<p>我是一个段落</p>
			<h1>我是一个标题</h1>
		</div>
	</body>
</html>
~~~

注意：元素名.类名  表示元素基于类而被选择

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			h1.c1 {/*元素名.类名  表示元素基于类而被选择*/
				color: yellow;
			}
		</style>
	</head>
	<body>
		<p class="c1">我是一个段落</p>
		<h1 class="c1">我是一个标题</h1>
		<div class="c1">
			<p>我是一个段落</p>
			<h1>我是一个标题</h1>
		</div>
	</body>
</html>
~~~

注意：一个元素节点可以定义多个类，空格分割

格式： class = "类名1 类名2"

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			.c2 {
				color: orange;
			}

			.c3 {
				text-align: right;
			}
		</style>
	</head>
	<body>
		<p class="c2 c3">我是一个段落</p>
		<p class="c2">我是一个段落</p>
		<p class="c3">我是一个段落</p>
	</body>
</html>

~~~

#### 属性选择器

[属性名]  ----- 选中含有指定属性的元素

[属性名 = 属性值] ----- 选中指定属性值的元素

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			[title] {
				color: brown;
			}

			[title="百度"] {
				text-align: center
			}
		</style>
	</head>
	<body>
		<p title="百度">百度</p>
		<p title="这是个段落">我是一个段落</p>
	</body>
</html>
~~~

#### hover选择器

元素名:hover ---- 当鼠标移动到指定元素上时，元素将被选中

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			a:hover{
				color:white;
			}
		</style>
	</head>
	<body>
		<a href="https//www.baidu.com" title="百度">百度</a>
	</body>
</html>
~~~

#### 背景图片

background url("图片路径") ---- 设置背景图片

background-repeat:no-repeat; ---- 不重复显示

background-position: 50%; ---- 居中

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			body {
				background: url("../test20220722/rem.jpg");
				background-repeat: no-repeat;
				background-position: 50%;
			}
		</style>
	</head>
	<body>
	</body>
</html>

~~~

#### 行间距

line-height --- 行间距

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			.big {
				line-height: 30px;
			}

			.little {
				line-height: 5px;
			}
		</style>
	</head>
	<body>
		<p>秋天来临了天空像一块覆盖大地的蓝宝石。村外那个小池塘睁着碧澄澄的眼睛，凝望着这美好的天色。一对小白鹅侧着脑袋欣赏自己映在水里的影子。山谷里枫树的叶子，不知是否喝了过量的酒，红的像一团火似的。村前村后的稻子，低着头弯着腰，在秋风中默默地等待着人们去收割，半空中，排着“人”字形的雁群，高兴的唱着歌，告别人们，向天边慢慢飞去</p>
		<p class="big">秋天来临了天空像一块覆盖大地的蓝宝石。村外那个小池塘睁着碧澄澄的眼睛，凝望着这美好的天色。一对小白鹅侧着脑袋欣赏自己映在水里的影子。山谷里枫树的叶子，不知是否喝了过量的酒，红的像一团火似的。村前村后的稻子，低着头弯着腰，在秋风中默默地等待着人们去收割，半空中，排着“人”字形的雁群，高兴的唱着歌，告别人们，向天边慢慢飞去</p>
		<p class="little">秋天来临了天空像一块覆盖大地的蓝宝石。村外那个小池塘睁着碧澄澄的眼睛，凝望着这美好的天色。一对小白鹅侧着脑袋欣赏自己映在水里的影子。山谷里枫树的叶子，不知是否喝了过量的酒，红的像一团火似的。村前村后的稻子，低着头弯着腰，在秋风中默默地等待着人们去收割，半空中，排着“人”字形的雁群，高兴的唱着歌，告别人们，向天边慢慢飞去</p>

	</body>
</html>

~~~

#### 圆角边框

border-radius ---- 圆角边框

~~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			input{
				border-radius:10px;
			}
		</style>
	</head>
	<body>
		<input type="text" />
		<br /><br />
		<input type="text" />
		<br /><br />
		<input type="submit" value="提交" />
		<input type="reset" value="重置" />
		<br /><br />
	</body>
</html>
~~~~

#### 外部样式表

我们可以创建一个.css文件，里面只写css代码，使用`<link>`标签将其引入到html文件中，那么该文件的样式就会自动收到影响

固定格式：

~~~html
<link rel="stylesheet" type="text/css" href="css文件路径">
~~~

#### 内联样式表：

在当前元素节点的标签内使用style属性来编写样式，它只作用在当前元素节点上

注意：外部，内部，内敛三种样式表的优先级为  内联>内部>外部

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<link rel="stylesheet" type="text/css" href="mycss.css">	<!--外部样式表-->
	</head>
	<body>
		<p>我是一个段落</p>
		<p style="font-size:40px;">我又是一个段落</p> <!--内联样式表-->
	</body>
</html>
~~~

#### cursor

当鼠标移动到元素上时，鼠标的形状变化

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<link rel="stylesheet" type="text/css" href="mycss.css">
	</head>
	<body>
		<div style="cursor: help;">请把鼠标移上来</div>
	</body>
</html>

~~~

#### 无序列表

`<ul> ---- 无序列表，里面包含<li>节点，每个<li>节点都是一个列表项，<li>节点中还可以继续嵌套`

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<ul>
			<li>雪碧</li>
			<li>可乐</li>
			<ul>
				<li>可口可乐</li>
				<li>百事可乐</li>
				<li>无糖可乐</li>
				<ul>
					<li>111</li>
				</ul>
				<li>可口可乐</li>
			</ul>
			<li>冰红茶</li>
			<li>芬达</li>
		</ul>
	</body>
</html>

~~~

#### 有序列表

`<ol> ---- 无序列表，里面包含<li>节点，每个<li>节点都是一个列表项，<li>节点中还可以继续嵌套`

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<ol>
			<li>雪碧</li>
			<li>可乐</li>
			<ol>
				<li>可口可乐</li>
				<li>百事可乐</li>
				<li>无糖可乐</li>
				<ol>
					<li>111</li>
				</ol>
				<li>可口可乐</li>
			</ol>
			<li>冰红茶</li>
			<li>芬达</li>
		</ol>
	</body>
</html>

~~~

#### `<dl>`标题和描述的列表

`<dt>`表示标题，，每个`<dd>`表示一行描述

~~~html
		<dl>
			<dt>咖啡</dt>
			<dd>这是一种黑色饮料</dd>
			<dd>产自东南亚</dd>
		</dl>
~~~

#### `<span>`行级标签

可以用来修饰一行文本中的一部分，它和`<div>`的区别在于它不会换行

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		恭喜xxx，获得offer，年薪
		<span style="color:red;font-size:30px;">15万</span>
	</body>
</html>
~~~

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>

		<h2>笔记本电脑促销</h2>
		<dl>
			<dt><img src="../test20220722/rem.jpg" </dt> <dd>联想笔记本电脑</dd>
			<dd>酷睿i7处理器，16G内存，512G固态硬盘</dd>
			<dd>出家人不讲钱，只讲缘，<span style="color:red;font-size:30px;">1万8000元</span></dd>
		</dl>
	</body>
</html>

~~~

#### `<iframe> `

可以将指定的html页面合并到当前页面中，src指向指定页面的路径

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<h2>我是test10页面</h2>
		<iframe src="./test8.html" width="1000" height="1000"></iframe>
	</body>
</html>
~~~

`<iframe>`可以提供name属性 当我们在当前页面中点击`<a>`跳转的时候，会自动根据`<a>`的target属性对应的name属性进行子页面的跳转



---
title:  笔记_008_javaScript
tag: 
	- javaScript
categories: 
	- java
---

# JavaScript

JS的代码都是通过一系列的事件调用方法来执行的

方法通常写在`<script type="text/javascript">`中

定义方法格式：function 方法名(){....}



常用事件：

### onclick ---- 鼠标点击事件

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function hello() {
				alert("hello js!"); /*弹窗函数*/
			}
		</script>
	</head>
	<body>
		<input type="button" value="hello" onclick="hello()" />
	</body>
</html>
~~~

弹出一个对话框：alert(内容字符串)

### onload ---- 窗体加载事件

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function hello() {
				alert("hello js!"); /*弹窗函数*/
			}
		</script>
	</head>
	<body onload="hello()">		/*刷新页面自动触发事件*/
		<input type="button" value="hello"/>
	</body>
</html>

~~~

### onchange ---- 值发生修改事件

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function textChange(i) {
				alert("值已修改,新的值是：" + i);
			}
		</script>
	</head>
	<body>
		<input type="text" onchange="textChange(this.value)" />
	</body>
</html>
~~~

注意：在js中，this表示当前元素节点。`this.属性 ` 表示当前元素节点的属性值

### onkeydown ---- 键被按下

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function myFunction() {
				alert("键已按下");
			}
		</script>
	</head>
	<body>
		<input type="text" onkeydown="myFunction()">
	</body>
</html>
~~~

### onkeyup ---- 键被按下后松开

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function myFunction() {
				alert("键已按下,然后松开了");
			}
		</script>
	</head>
	<body>
		<input type="text" onkeyup="myFunction()">
	</body>
</html>
~~~

### onmouseenter ---- 鼠标移动到当前控件上

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function myFunction() {
				alert("鼠标移上来了");
			}
		</script>
	</head>
	<body>
		<input type="text" onmouseenter="myFunction()">
	</body>
</html>
~~~

### onmouseleave ---- 鼠标离开当前控件

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			function myFunction() {
				alert("鼠标离开了");
			}
		</script>
	</head>
	<body>
		<input type="text" onmouseleave="myFunction()">
	</body>
</html>
~~~

### window.onload=function(){} ---- 窗体已加载

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				alert("窗体已加载");
			}
		</script>
	</head>
	<body>
	</body>
</html>
~~~

在窗体加载事件中，我们可以通过获取的   `元素节点.事件=function(){....} ` 来完成指定操作

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {

				var btns = document.getElementsByTagName("button");
				btns[0].onclick = function() {
					alert("我是第一个按钮");
				};
				btns[1].onclick = function() {
					alert("我是第二个按钮");
				};

			}
		</script>
	</head>
	<body>
		<button>我是一个按钮</button>
		<button>我也是一个按钮啊啊啊啊</button>
	</body>
</html>

~~~

### 在js中获取元素节点的方法

1. document.getElementsByTagName(元素节点名) ---- 获取当前页面上某元素节点的数组

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var btns = document.getElementsByTagName("button");
				alert(btns.length);
			}
		</script>
	</head>
	<body>
		<button type="button">我是一个按钮</button>
		<button type="button">我也是一个按钮</button>
	</body>
</html>
~~~

注意：该方法可以由指定的某个元素节点来调用，那么得到的结果就是该元素节点下的指定子元素数组

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var lis = document.getElementsByTagName("li");
				alert(lis.length);

				var city = document.getElementById("city");
				var cityLis = city.getElementsByTagName("li");
				alert(cityLis.length);
			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li>英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
	</body>
</html>

~~~



2. document.getElementById(id值) ---- 根据id获取当前元素节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var btns = document.getElementsByTagName("button");
				// alert(btns.length);
				btns[0].onclick = function() {
					alert("我是第一个按钮");
				};
				btns[1].onclick = function() {
					alert("我是第二个按钮");
				};

				var btn3 = document.getElementById("btn3");
				btn3.onclick = function() {
					alert("我是第三个按钮");
				};
			}
		</script>
	</head>
	<body>
		<button>我是一个按钮</button>
		<button>我也是一个按钮</button>
		<button id="btn3">我也是三个按钮</button>
	</body>
</html>
~~~

3. document.getElementsByName(name值) ---- 根据name属性获取对应的元素数组

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var types = document.getElementsByName("type");
				alert(types.length);

			}
		</script>
	</head>
	<body>
		<p>请选择类型</p>
		城市<input type="radio" name="type" />
		游戏<input type="radio" name="type" checked="checked" />
	</body>
</html>

~~~

4. document.getElementByClassName(class值) ---- 根据class属性获取对应的元素数组

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var dels = document.getElementsByClassName("delete");
				alert(dels.length);
			}
		</script>
	</head>
	<body>
		<a href="#" class="delete">删除</a>
		<a href="#" class="delete">删除</a>
		<a href="#" class="delete">删除</a>
	</body>
</html>
~~~



我们可以通过  `元素节点.属性名`  获得属性值

我们可以通过  `元素节点.属性名=新值`  来改变属性值

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {				
				var textNode = document.getElementById("text1");
				alert(textNode.value);
				textNode.value = "abd";
			}
		</script>
	</head>
	<body>
		<input type="text"  id="text1" value="hello" />
	</body>
</html>
~~~

### childNodes ---- 获取某元素节点下的所有子节点，包括文本节点和元素节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var city = document.getElementById("city");
				var cityLis = city.getElementsByTagName("li");


				var cityChilds = city.childNodes;
				alert(cityChilds.length);
			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li>英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
	</body>
</html>

~~~

如何获取文本？

`元素节点.firstChild.nodeValue;`

注意：`元素节点.firstChild.nodeValue=新值`  可以改变文本内容

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var city = document.getElementById("city");
				var cityLis = city.getElementsByTagName("li");

				//var bjtext = cityLis[0].firstChild.nodeValue;
				var bjNode = cityLis[0];
				alert(bjNode);
				var bjTextNode = bjNode.firstChild;
				alert(bjTextNode);
				var bjText = bjTextNode.nodeValue;
				alert(bjText);
                  cityLis[0].firstChild.nodeValue = "hello 北京";
			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li>英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
	</body>
</html>

~~~

### 遍历

~~~html
				for (var i = 0; i < lis.length; i++) {
					var liNode = lis[i];
					alert(liNode.firstChild.nodeValue);
				}
~~~

~~~html
				for (var i = 0; i < lis.length; i++) {
					lis[i].onclick = function() {
						alert(this.firstChild.nodeValue);
					}
				}
~~~

### document.createElement(元素节点名) ---- 创建一个元素节点

`父节点.appendChild(新节点) `---- 将新创建的节点挂在某个父节点下

~~~html
				var myLi = document.createElement("li");
				city.appendChild(myLi);
~~~

### document.createTextNode(文本内容) --- 创建一个文本节点

我们需要使用   元素节点.appendChild(文本节点)  将新创建的文本节点挂在指定的元素节点下

~~~html
				var myText = document.createTextNode("南京");
				myLi.appendChild(myText);
~~~

对于单选框和复选框的选中状态，我们可以在js中使用check属性来获取，它是一个boolean值 true表示选中false表示未选中

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				
				var btn4 = document.getElementById("btn4");
				btn4.onclick=function(){
					var types = document.getElementsByName("type");
					for(var i=0;i<types.length;i++){
						alert(types[i].value+ ":" + types[i].checked);
					}
				}
				
			}
		</script>
	</head>
	<body>
		<p>请选择类型</p>
		城市<input type="radio" name="type" value="city"/>
		游戏<input type="radio" name="type" checked="checked" value="game"/>
		<br>
		<button id="btn4">检查选中状态</button>
	</body>
</html>

~~~

## 多选框

全选框  可复用

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				document.getElementById("checkedAll").onclick = function() {
					var hobbys = document.getElementsByName("hobby");
					for (var i = 0; i < hobbys.length; i++) {
						hobbys[i].checked = this.checked;
					}
				}


				var items = document.getElementsByName("hobby");
				for (var j = 0; j < items.length; j++) {
					items[j].onclick = function() {
						var num = 0;
						for (var k = 0; k < items.length; k++) {

							if (items[k].checked) {
								num++;
							}

						}
						document.getElementById("checkedAll").checked = (num == items.length);
					}
				}


			}
		</script>
	</head>
	<body>


		<p>请选择你的爱好：</p>
		全选<input type="checkbox" id="checkedAll" />
		足球<input type="checkbox" name="hobby" id="" value="football" />
		篮球<input type="checkbox" name="hobby" id="" value="basketball" />
		乒乓球<input type="checkbox" name="hobby" id="" value="pingpong" />
		羽毛球<input type="checkbox" name="hobby" id="" value="badminton" />

	</body>
</html>

~~~

# js第二天

### 删除元素节点

`父节点.removeChild(子节点)` ---- 删除指定的子节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var btn1 = document.getElementById("btn1");
				btn1.onclick = function() {
					var yxlmNode = document.getElementById("yxlm");
					var gameNode = document.getElementById("game");

					gameNode.removeChild(yxlmNode);
				}

			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<button type="button" id="btn1">删除节点</button>
	</body>
</html>
~~~

### 确认提示信息

confirm(字符串) ---- 弹出一个确认框

当用户点击确认时返回true

当用户点击取消时，返回false

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var btn1 = document.getElementById("btn1");
				btn1.onclick = function() {
					var yxlmNode = document.getElementById("yxlm");
					var gameNode = document.getElementById("game");

					var flag = confirm("确定删除" + yxlmNode.firstChild.NodeValue + "的元素消息吗？");

					if (flag) {
						gameNode.removeChild(yxlmNode);
					}
				}

			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<button type="button" id="btn1">删除节点</button>
	</body>
</html>

~~~

### parentNode

表示当前节点的父节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				var btn1 = document.getElementById("btn1");
				btn1.onclick = function() {
					var yxlmNode = document.getElementById("yxlm");
					var gameNode = document.getElementById("game");

					var myParent = yxlmNode.parentNode;
					var testNode = myParent.getElementsByTagName("li");
					alert(testNode[0].firstChild.nodeValue);
				}

			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<button type="button" id="btn1">删除节点</button>
	</body>
</html>
~~~

点谁删谁

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {

				var lis = document.getElementsByTagName("li");
				for (var i = 0; i < lis.length; i++) {
					lis[i].onclick = function() {
						if (confirm("确定删除" + this.firstChild.nodeValue + "节点吗？")) {
							this.parentNode.removeChild(this);
						}
					}
				}


			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<button type="button" id="btn1">删除节点</button>
	</body>
</html>

~~~

### 添加删除实例：员工管理系统

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			body {
				text-align: center;
			}

			table {
				border-collapse: collapse;
				margin: 0px auto;
			}

			table,
			td,
			th {
				boder: 1px black solid;
				padding: 10px;
			}
		</style>

		<script type="text/javascript">
			function removeTr(aNode) {
				var trNode = aNode.parentNode.parentNode; // td  tr
				var nameText = trNode.getElementsByTagName("td")[0].firstChild.nodeValue;
				var flag = confirm("确定要删除：" + nameText + " 的信息吗？");
				if (flag) {
					trNode.parentNode.removeChild(trNode);
				}
			}

			window.onload = function() {
				//删除原始数据
				var aNodes = document.getElementsByTagName("a");
				for (var i = 0; i < aNodes.length; i++) {
					aNodes[i].onclick = function() {
						removeTr(this);
					}
				}


				//新增一条记录
				document.getElementById("btn1").onclick = function() {
					var trNode = document.createElement("tr");
					document.getElementById("table1").appendChild(trNode);

					for (var i = 0; i < 4; i++) {
						//前三个td
						if (i <= 2) {
							var textNode = document.createTextNode(document.getElementsByTagName("input")[i].value);
							var tdNode = document.createElement("td");
							trNode.appendChild(tdNode);

							tdNode.appendChild(textNode);
						} else {
							//最后一个特殊的td
							var textNode = document.createTextNode("Delete");
							var tdNode = document.createElement("td");
							trNode.appendChild(tdNode);
							var aNode = document.createElement("a");
							aNode.href = "#";
							tdNode.appendChild(aNode);
							aNode.appendChild(textNode);
							aNode.onclick = function() {
								removeTr(this);
							}
						}
					}
				}
			}
		</script>
	</head>
	<body>

		员工管理系统
		<br><br>
		name:<input type="text" name="" id="name" value="Lucy" />&nbsp;&nbsp;
		email:<input type="text" name="" id="email" value="Lucy@qq.com" />&nbsp;&nbsp;
		salary:<input type="text" name="" id="salary" value="10000" />&nbsp;&nbsp;

		<br><br>
		<button type="button" id="btn1">新增</button>
		<br><br>
		<hr>
		<br><br>
		<table border="" id="table1">
			<tr>
				<th>name</th>
				<th>email</th>
				<th>salary</th>
				<th></th>
			</tr>
			<tr>
				<td>Tom</td>
				<td>abc@qqcom</td>
				<td>8000</td>
				<td><a href="#">Delete</a></td>
			</tr>
			<tr>
				<td>Jerry</td>
				<td>abdfafc@qqcom</td>
				<td>80dd00</td>
				<td><a href="#">Delete</a></td>
			</tr>
			<tr>
				<td>Mary</td>
				<td>abdsfsfc@qqcom</td>
				<td>80031310</td>
				<td><a href="#">Delete</a></td>
			</tr>
		</table>
	</body>
</html>
~~~



### 元素节点隐藏显示

`元素节点.style.display=""`可以控制元素节点是否显示

- 取值为none表示隐藏
- 取值为list-item表示以列表项的形式展示
- 取值为block 表示以块级元素的形式展示

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				document.getElementById("btn1").onclick = function() {
					document.getElementById("yxlm").style.display = "none";
				}

				document.getElementById("btn2").onclick = function() {
					document.getElementById("yxlm").style.display = "list-item";
				}

				var flag = true;
				document.getElementById("btn3").onclick = function() {
					flag = !flag;
					if (flag) {
						document.getElementById("yxlm").style.display = "list-item";
					} else {
						document.getElementById("yxlm").style.display = "none";
					}

				}
			}
		</script>
	</head>
	<body>
		<input type="hidden" name="" id="" value="100" />


		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<button type="button" id="btn1">隐藏英雄联盟</button>
		<button type="button" id="btn2">显示英雄联盟</button>
		<button type="button" id="btn3">显示/隐藏英雄联盟</button>
	</body>
</html>

~~~



### `<input type="hidden" value="xxx">` ---- 隐藏域

通常写在`<form>`中，他不显示，但会随着表单的提交而被提交

# js第三天

## 置灰

元素节点.disabled  属性表示是否置灰 ，它的取值为true和false，true表示置灰，false表示可用

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				document.getElementById("btn").onclick = function() {
					document.getElementById("t1").disabled = 										!document.getElementById("t1").disabled;
				}
			}
		</script>
		</script>
	</head>
	<body>

		<input type="text" name="" id="t1" value="" />
		<br>
		<button type="button" id="btn">置灰/取消置灰</button>
	</body>
</html>
~~~

## 只读

`元素节点.readOnly`  属性表示是否只读 ，它的取值为true和false，true表示只读，false表示可写

注意：disabled 和 readOnly 的本质区别在于disabled 中的value值无法随表单提交，而readOnly中的value值可以随表单提前交
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				document.getElementById("btn").onclick = function() {
					document.getElementById("t1").readOnly = !document.getElementById("t1").readOnly;
				}
			}
		</script>
		</script>
	</head>
	<body>

		<input type="text" name="" id="t1" value="" />
		<br>
		<button type="button" id="btn">只读/可写</button>
	</body>
</html>
~~~

## innerHTML

它可以获取当前节点的HTML代码
也可以使用元素节点.innerHTML=新的HTML代码 来改变当前元素节点的子元素

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			window.onload = function() {
				document.getElementById("btn3").onclick = function() {
					var city = document.getElementById("city");
					alert(city.innerHTML);
				}

				document.getElementById("btn4").onclick = function() {
					var game = document.getElementById("game");
					alert(game.innerHTML);
				}

				document.getElementById("btn5").onclick = function() {
					var game = document.getElementById("game");
					var city = document.getElementById("city");
					var temp = city.innerHTML;
					city.innerHTML = game.innerHTML;
					game.innerHTML = temp;
				}

			}
		</script>
	</head>
	<body>
		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<br><br>
		<button type="button" id="btn3">获取city的html代码</button>
		<br><br>
		<button type="button" id="btn4">获取game的html代码</button>
		<br><br>
		<button type="button" id="btn5">交换</button>
	</body>
</html>

~~~

## 外部js文件

我们可以单独编写独立的js文件，然后再当前html中使用`<script type="text/javascript" src="外部js文件路径"/>`来将其引入 

~~~js
function abc() {
	alert("我是abc");
}
~~~

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="./myJs.js"></script>
		<script type="text/javascript">
			window.onload = function() {

				abc();

            }
		</script>
	</head>
	<body>
	</body>
</html>
~~~

## my97Date日期控件

一般来讲 日期框的内容都是用户手动选择的，而不是输入的。我们可以引入my97Date日期控件中的WdatePicker.js 然后再文本框的onclick事件上调用WdatePicker()即可，

当用户选择某日期后，返回的是该日期的标准格式字符串

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="My97DatePicker/WdatePicker.js"></script>

	</head>
	<body>
		<input type="text" onclick="WdatePicker()" />
	</body>
</html>
~~~

## jQuery

这是一个流行的封装了js的前端框架

窗体加载事件

~~~css
			$(function() {
				alert("hello jquery");
			})
~~~

### jQuery 的选择器

$("元素名") ---- 元素选择器，选中指定元素
$("#id值") ---- id选择器
$(".class值") --- class选择器
$("*") ---- 选中所有元素
注意：多个选择器可以同时选中，在$("，，，")中以逗号分割
$("[属性名]") ---- 属性选择器
$("[属性名=属性值]") ---- 含有指定属性值的属性选择器
注意 ： 
- != 表示没有该属性值
- ^=  表示以属性值开头  
- $=  表示以属性值结尾  
- *=  表示含有属性值


注意：多个选择器中间没有逗号，表示取其交集

注意：jQuery的选择器选择到的对象，其实是一个数组类型

注意：jQuery对象不能直接调用js的属性和方法，但它可以通过数组下标转型成js对象，然后就可以调用js属性和方法

$(":表单控件类型") ---- 表单选择器
$(":控件状态") ---- 表示选中指定状态的元素
注意：如果选择器中间有空格，那么表示在其子元素中进行相应的选择

在单选框指定的列表下添加数据：
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				$("#sub").click(function() {
					var strValue = $("#str").val();
					strValue = $.trim(strValue);//取出两端空格
					if (strValue == null || strValue == "") {
						alert("请输入名称");
					} else {
						$("#" + $(":radio[name='type']:checked").val()).append($("<li> " + strValue + "</li>"));

					}
				})

			})
		</script>
	</head>
	<body>

		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li>英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<br>
		<p>请选择类型</p>
		城市<input type="radio" name="type" value="city" />
		游戏<input type="radio" name="type" checked="checked" value="game" />
		<br>
		<p>请输入名称</p>
		<input type="text" id="str" />
		<br><br>
		<button id="sub">提交</button>
	</body>
</html>
~~~

jQuery对象也可以通过get(下标)来转型js对象

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
                //以下三种输出都一样
				var jsNode = $("p")[0];
				alert(jsNode.firstChild.nodeValue);
                
				alert($("p")[0].firstChild.nodeValue);
                
				alert($("p").get(0).firstChild.nodeValue);
			})
		</script>
	</head>
	<body>
		<p>我是一个段落</p>
		<br><br>
		<p>我是第二个段落</p>
		<br><br>
		<p>我是第三个段落</p>
	</body>
</html>

~~~

js对象也不能直接调用`jQuery`的方法，但是它可以先转型为`jQuery`对象

我们只需要使用`$(js对象)`，就可以实现js对象转`jQuery`对象

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				var p1Node = document.getElementById("p1");
				alert($(p1Node).text());
			})
		</script>
	</head>
	<body>
		<p id="p1">我是一个段落</p>
		<br><br>
		<p>我是第二个段落</p>
		<br><br>
		<p>我是第三个段落</p>
	</body>
</html>

~~~



### jQuery 的方法

#### text() 

---- 获取指定元素节点中的文本内容

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				alert($("#p1").text());
			})
		</script>
		</script>
	</head>
	<body>
		<p id="p1">我是一个段落</p>
	</body>
</html>
~~~

#### click() 

---- onClick事件

#### css(属性值，属性名) 

---- 改变元素节点的css样式

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("button").click(function() {
					$("#p1").css("color", "red");//单击按钮使第一个段落变成红色
				});
			})
		</script>
	</head>
	<body>
		<p id="p1">我是一个段落</p>
		<br><br>
		<p>我是第二个段落</p>
		<br><br>
		<p>我是第三个段落</p>
		<br>
		<button type="button">改变段落的颜色</button>
	</body>
</html>

~~~

#### change() 

---- onChange事件

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$(".field1").change(function() {
					$(this).css("background-color", "red");
				})
			})
		</script>
	</head>
	<body>
		<input type="text" class="field1" />
		<br>
		<select class="field1">
			<option value="">北京</option>
			<option value="">上海</option>
			<option value="">广州</option>
			<option value="">深圳</option>
			<option value="">苏州</option>
		</select>
	</body>
</html>
~~~

#### mouseenter() 

---- onMouseenter事件

mouseleave() ---- onMouseleave事件

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("p").mouseenter(function() {
					$(this).css("background-color", "blue");
				})

				$("p").mouseleave(function() {
					$(this).css("background-color", "yellow");
				})
			})
		</script>
	</head>
	<body>
		<p id="p1">我是一个段落</p>
		<br><br>
		<p>我是第二个段落</p>
		<br><br>
		<p>我是第三个段落</p>
		<br>
		<button type="button">改变段落的颜色</button>
		<br>
		<input type="text" class="field1" />
		<br>
		<select class="field1">
			<option value="">北京</option>
			<option value="">上海</option>
			<option value="">广州</option>
			<option value="">深圳</option>
			<option value="">苏州</option>
		</select>
	</body>
</html>
~~~

#### hide() 

---- 隐藏指定元素节点

####  show() 

---- 显示隐藏的节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("p").click(function() {
					$(this).hide();
				})

				$("#btn1").click(function() {
					$("p").show();
				})

			})
		</script>
	</head>
	<body>
		<p id="p1">点我我就消失</p>
		<br><br>
		<p>俺也一样</p>
		<br><br>
		<p>俺也一样</p>
		<br>
		<button type="button" id="btn1">全部出现</button>
	</body>
</html>
~~~

#### is(":hidden") 

---- 判断当前控件是否隐藏，返回true和false

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				$("p").click(function() {
					$(this).hide();
				})
				$("#btn1").click(function() {
					$("p").show();
				})
				$("#btn2").click(function() {
					$("p").each(function() {
						alert($(this).is(":hidden"));
					})
				})
			})
		</script>
		</script>
	</head>
	<body>
		<p>点我我就消失</p>
		<p>点我我就消失2</p>
		<p>点我我就消失3</p>
		<button type="button" id="btn1">全部出来！</button>
		<button type="button" id="btn2">查看控件隐藏状态</button>
	</body>
</html>
~~~

#### find("元素节点") 

---- 在当前元素节点下的子节点中查找指定元素节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {


				$("#ul1").find("li").click(function() {
					$(this).hide();
				})

			})
		</script>
		</script>
	</head>
	<body>
		<ul id="ul1">
			<li>点我我就消失1</li>
			<li>点我我就消失2</li>
			<li>点我我就消失3</li>
		</ul>
		<ul id="ul2">
			<li>点我我不消失1</li>
			<li>点我我不消失2</li>
			<li>点我我不消失3</li>
		</ul>
	</body>
</html>

~~~
#### each() 

---- 遍历当前jQuery对象中的每一个元素节点

#### val()

---- 操作元素节点的value属性，如果无参，则是获取value值，如果传参数，则是改变value值

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				alert($("input").val());
				$("input").val("你好");
				alert($("input").val())
			})
		</script>
		</script>
	</head>
	<body>
		<input type="text" name="" id="" value="嗨嗨" />
	</body>
</html>
~~~

#### prop(属性名) 

---- 获取当前元素的某属性值

#### prop(属性名，新值)

---- 改变当前元素的某些属性

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="./jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				var myValue = $("#test1").prop("value");
				alert(myValue);
				$("#test1").prop("value", "zhangsan");

			})
		</script>
	</head>
	<body>
		<input type="text" name="hello" id="test1" value="abc" title="haha" />
	</body>
</html>
~~~

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="./jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("#btn1").click(function() {
					alert($("#c1").prop("checked"));
				})


				$("#btn2").click(function() {
					$("#c1").prop("checked", !$("#c1").prop("checked"))
				})
			})
		</script>
	</head>
	<body>
		<input type="text" name="hello" id="test1" value="abc" title="haha" />
		<br><br>
		<input type="checkbox" name="" id="c1" value="" />
		<button type="button" id="btn1">看看有没有选中</button>
		<br><br>
		<button type="button" id="btn2">选中</button>
	</body>
</html>
~~~

## 用jQuery写多选框
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				$("#checkedAll").click(function() {
					$("[name='hobby']").prop("checked", this.checked);
				})


				$("[name='hobby']").click(function() {
					$("#checkedAll").prop("checked", $("[name=hobby]").length == $("[name=hobby]:checked").length);
				})

			})
		</script>
	</head>
	<body>


		<p>请选择你的爱好：</p>
		全选<input type="checkbox" id="checkedAll" />
		<br><br>
		足球<input type="checkbox" name="hobby" id="" value="football" />
		篮球<input type="checkbox" name="hobby" id="" value="basketball" />
		乒乓球<input type="checkbox" name="hobby" id="" value="pingpong" />
		羽毛球<input type="checkbox" name="hobby" id="" value="badminton" />
	</body>
</html>

~~~

### html() 

---- 可以获取指定元素节点下的子节点的html代码，如果传参，则是改变它的子节点的html代码，相当于innerHTML

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				$("#btn").click(function() {
					alert($("div").html());
					$("div").html("<h1>我是一个标题</h1>");
				})


			})
		</script>

	</head>
	<body>
		<div id="">
			<p>我是一个段落</p>
		</div>
		<button type="button" id="btn">按钮</button>
	</body>
</html>
~~~

### empty() 

---- 清空指定元素节点下的所有子节点

### remove() 

---- 删除指定元素节点以及它下面的所有字节点

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				$("#btn").click(function() {
					alert($("div").html());
					$("div").html("<h1>我是一个标题</h1>");
				})

				$("#btn2").click(function() {
					$("div").empty();
				})

				$("#btn3").click(function() {
					$("div").remove();
				})

			})
		</script>
		<style type="text/css">
			div {
				height: 80px;
				width: 80px;
				background-color: red;
			}
		</style>
	</head>
	<body>
		<div id="">
			<p>我是一个段落</p>
		</div>
		<button type="button" id="btn">按钮</button>
		<br>
		<button type="button" id="btn2">清空</button>
		<br>
		<button type="button" id="btn3">删除</button>
		<br>
	</body>
</html>
~~~

## 用 jQuery写点谁删谁

~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("li").click(function() {
					if (confirm("确定删除" + $(this).text() + "的信息吗？")) {
						$(this).remove();
					}
				})
			})
		</script>
	</head>
	<body>

		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
	</body>
</html>

~~~

### $(html代码字符串) 

---- 创建一个新的节点

### 将新节点挂在指定父节点下的最后一个位置的方法：

> 新节点.appendTo(父节点)
> 父节点.append(新节点)
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("#btn1").click(function() {
					//$("<li>杭州</li>").appendTo($("#city"));
					$("#city").append($("<li>杭州</li>"));
				})

			})
		</script>
	</head>
	<body>

		<ul id="city">
			<li>北京</li>
			<li>上海</li>
			<li>广州</li>
			<li>南京</li>
		</ul>
		<br>
		<ul id="game">
			<li id="yxlm">英雄联盟</li>
			<li>星际争霸</li>
			<li>魔兽世界</li>
		</ul>
		<button type="button" id="btn1">新增一个城市</button>

	</body>
</html>
~~~

prependTo和prepend是挂在父节点的第一个子节点位置
insertBefore和before是挂在某个兄弟节点的前面
insertAfter和after是挂在某个兄弟节点的后面



### $.trim(字符串)
---- 去除字符串的前后空格



# js第四天
### parent() 
---- 找到指定节点的父节点

### find(元素名).eq(下标)
---- 找到指定元素数组的某个下标位置的元素
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("#btn1").click(function() {
					//$("#id33").parent().parent().css("background-color","red");
					$("#id33").parent().parent().find("tr").eq(1).find("td").eq(1).css("background-color", "red");
				})
			})
		</script>
		<style type="text/css">

		</style>
	</head>
	<body>
		<table border="" cellspacing="" cellpadding="">
			<tr>
				<td>11</td>
				<td>12</td>
				<td>13</td>
			</tr>
			<tr>
				<td>21</td>
				<td>22</td>
				<td>23</td>
			</tr>
			<tr>
				<td>31</td>
				<td>32</td>
				<td id="id33">33</td>
			</tr>
		</table>
		<br>
		<button type="button" id="btn1">选中父标签的父标签</button>
	</body>
</html>
~~~



#### jQuery员工管理系统
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			body {
				text-align: center;
			}

			table {
				border-collapse: collapse;
				margin: 0px auto;
			}

			table,
			td,
			th {
				boder: 1px black solid;
				padding: 10px;
			}
		</style>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			function removeTr(aNode) {
				//删除
				if (confirm("确定要删除：" + $(aNode).parent().parent().find("td").eq(0).text() + " 的信息吗"))
					$(aNode).parent().parent().remove();
			}
			$(function() {

				$("a").click(function() {
					removeTr(this);
				})

				//新增
				$("#btn1").click(function() {
					var trNode = $("<tr><td>" + $("#name").val() + "</td><td>" + $("#email").val() + "</td><td>" + $("#salary").val() + "</td><td><a href='#'>Delete</a></td></tr>");
					trNode.find("a").click(function() {
						removeTr(this);
					})
					$("#table1").append(trNode);
				})


			})
		</script>
	</head>
	<body>

		员工管理系统
		<br><br>
		name:<input type="text" name="" id="name" value="Lucy" />&nbsp;&nbsp;
		email:<input type="text" name="" id="email" value="Lucy@qq.com" />&nbsp;&nbsp;
		salary:<input type="text" name="" id="salary" value="10000" />&nbsp;&nbsp;

		<br><br>
		<button type="button" id="btn1">新增</button>
		<br><br>
		<hr>
		<br><br>
		<table border="" id="table1">
			<tr>
				<th>name</th>
				<th>email</th>
				<th>salary</th>
				<th></th>
			</tr>
			<tr>
				<td>Tom</td>
				<td>abc@qqcom</td>
				<td>8000</td>
				<td><a href="#">Delete</a></td>
			</tr>
			<tr>
				<td>Jerry</td>
				<td>abdfafc@qqcom</td>
				<td>80dd00</td>
				<td><a href="#">Delete</a></td>
			</tr>
			<tr>
				<td>Mary</td>
				<td>abdsfsfc@qqcom</td>
				<td>80031310</td>
				<td><a href="#">Delete</a></td>
			</tr>
		</table>
	</body>
</html>
~~~

## 正则表达式

用来校验某个字符串是否符合指定的规则

校验方法：
使用`正则对象.test(字符串)` 可以返回true 或者 false 表示校验是否通过

### 定义正则对象的语法：

1. 以`/^` 开始  以 `$/` 结尾
2. `new RegExp("^正则表达式$");`
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("#btn1").click(function() {
					//var reg = /^a$/;
					var reg = new RegExp("^a$");
					alert(reg.test($("#str").val()));

				})
			})
		</script>
	</head>
	<body>
		<input type="text" name="" id="str" value="" />
		<br>
		<button type="button" id="btn1">校验</button>
	</body>
</html>
~~~

### 正则的语法
#### []
---- 在多个字符中进行选择匹配，满足其一（单个字符）即可
例：`new RegExp("^[ab]$")` //a b   都是true  ab却是 false
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("#btn1").click(function() {
					//var reg = /^a$/;
					var reg = new RegExp("^[ab]$");//var reg = /^[ab]$/;
					alert(reg.test($("#str").val()));

				})
			})
		</script>
	</head>
	<body>
		<input type="text" name="" id="str" value="" />
		<br>
		<button type="button" id="btn1">校验</button>
	</body>
</html>
~~~
#### ^
---- 写在[]内表示取反
例：`new RegExp("^[^ab]$")` //a b ab  都是false

表示两个字符之间任意单个字符
例：`new RegExp("^[a-z]$")` 
注意：正则本身用到的特殊字符，如果要校验，得转义
注意：这些特殊字符如果在[]里面，那么无序转义，除了[]包[]，里面的[]仍需转义
使用  \  来转义
例：`var reg = /^\$$/;` // $ 为true

#### 元字符
小数点 ---- 除了换行符以外的任意单个字符
例：`var reg = /^.$/;`
\w ---- 任意单个字母数字下划线
例：`var reg = /^\w$/;`
\W ---- 任意单个 非 字母数字下划线 
例：`var reg = /^\W$/;`
\s ---- 单个空格
\S ---- 单个 非 空格
\d ---- 单个数字
\D ---- 单个 非 数字
#### 数量词
`?` ---- 0次或1次
`+` ---- 1次或多次
`*` ---- 任意次数
`{n}` ---- 指定n次
`{n,}` ---- 至少n次
`{n,m}` ---- n到m次

#### 组合
小括号()  可以将一个正则包起来，作为一个组合，它的后面使用数量词来修饰，表示该组合允许出现指定次数
例：编写正则，校验一个0-2位小数的正数或负数或0
`var reg = /^\-?\d+(\.\d{1,2})?$/;`
#### 字符串.length
---- 获取字符串的长度
#### return false
---- 表示阻止当前控件的默认行为  例如阻止表单提交
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {
				$("#btn1").click(function() {
					//var reg = /^a$/;
					//var reg = new RegExp("^[\w]$");
					//var reg = /^0\d{2,3}\-\d{8}$/;
					//var reg = /^\-?\d+(\.\d{1,2})?$/;
					var str = $("#str").val();
					if (str == null || str == "") {
						alert("内容不能为空");
						return false;
					}
					if (str.length > 10) {
						alert("内容过长");
						return false;
					}
					alert(reg.test($("#str").val()));

				})
			})
		</script>
		<!-- 		<script type="text/javascript">
			window.onload=function(){
				document.getElementById("btn1").onclick=function(){
					var reg= new RegExp("^a$");
					alert(reg.test(document.getElementById("str").value));
				}
			}
		</script> -->
	</head>
	<body>
		<form action="./success.html" method="post">
			<input type="text" name="" id="str" value="" />
			<br>
			<button type="submit" id="btn1">校验</button>
		</form>

	</body>
</html>
~~~

~~~html

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {



				$("#email").change(function() {
					var email = $.trim($(this).val());
					if (email.length > 15) {
						$("#message").html("  内容过长!给老子死！");
						$("#btn1").prop("disabled", true);
					} else {
						var reg = /^\w+@\w+\.\w+$/;
						if (reg.test(email)) {
							$("#message").empty();
							$("#btn1").prop("disabled", false);

						} else {
							$("#message").html("  格式错误!给老子死！");
							$("#btn1").prop("disabled", true);
						}

					}

				})
				$("#btn1").click(function() {
					if ($("#email").val() == null || $("#email").val() == "") {
						$("#message").html("  不能为空!给老子死！");
						$("#btn1").prop("disabled", true);
						return false;
					}
				})

				//alert($("#span2").text());
				//$("#span2").html("123412");

			})
		</script>

	</head>
	<body>
		<form action="./success.html" method="post">
			Email:<input type="text" name="" id="email" value="" />
			<span style="color:red" id="span1">*</span><span id="message" style="color:red"></span>
			<br>
			<button type="submit" id="btn1">校验</button>
		</form>

	</body>
</html>

~~~

# js第五天
## bookstrap控件
### 栅格系统
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type='text/javascript' src="js/jquery-1.11.3.min.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap/3.3.6/bootstrap.min.css">
		<script type="text/javascript" src="js/bootstrap/3.3.6/bootstrap.min.js"></script>
		<style type="text/css">
			div.container div.row div {
				margin: 5px 0px;
				background-color: red;
				border: 1px solid blue;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="row">
				<div class="col-lg-12">一共十二列，我独占12列</div>
			</div>
			<div class="row">
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
				<div class="col-lg-1">一共十二列，我独占1列</div>
			</div>
		</div>
	</body>
</html>

~~~

### 图片轮播
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type='text/javascript' src="js/jquery-1.11.3.min.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap/3.3.6/bootstrap.min.css">
		<script type="text/javascript" src="js/bootstrap/3.3.6/bootstrap.min.js"></script>
		<style type="text/css">
			div.container div.row div {
				margin: 5px 0px;
				background-color: red;
				border: 1px solid blue;
				text-align: center;
			}

			div.item img {
				width: 100%;
			}

			div #lunbo {
				width: 80%;
				margin: 0 auto;
			}
		</style>
	</head>
	<body>
		<div id="lunbo" class="carousel slide" data-ride="carousel" data-interval="1000">
			<ol class="carousel-indicators">
				<li data-target="lunbo" data-slide-to="0" class="active"></li>
				<li data-target="lunbo" data-slide-to="1"></li>
				<li data-target="lunbo" data-slide-to="2"></li>
				<li data-target="lunbo" data-slide-to="3"></li>
			</ol>
			<div class="carousel-inner">
				<div class="item active">
					<img src="./img/lunbo/1.jpg">
				</div>
				<div class="item">
					<img src="./img/lunbo/2.jpg">
				</div>
				<div class="item">
					<img src="./img/lunbo/3.jpg">
				</div>
				<div class="item">
					<img src="./img/lunbo/4.jpg">
				</div>
			</div>
		</div>
	</body>
</html>

~~~

### BootStrap 的 日期控件
1. 解压日期控件的zip包
2. 将解压的文件夹拷贝到当前项目中
3. 打开 sample in bootstrap v3 文件夹中的index.html 拷贝其中的某个`<div>`到自己的项目中
4. 加载bootstrap-datatimepicker.min.css
5. 在`<div>`的下方加载 bootstrap-datatimepicker.js 和 bootstrap-datetimepicker.zh_CN.js
6. 拷贝 index.html中的 $('form_date').datetimepicker({}) 到当前的项目文件中
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type='text/javascript' src="js/jquery-1.11.3.min.js"></script>
		<link rel="stylesheet" type="text/css" href="css/bootstrap/3.3.6/bootstrap.min.css">
		<script type="text/javascript" src="js/bootstrap/3.3.6/bootstrap.min.js"></script>
		<style type="text/css">
			div.container div.row div {
				margin: 5px 0px;
				background-color: red;
				border: 1px solid blue;
				text-align: center;
			}

			div.item img {
				width: 100%;
			}

			div #lunbo {
				width: 80%;
				margin: 0 auto;
			}
		</style>
		<link href="./bootstrap-datetimepicker-master/css/bootstrap-datetimepicker.min.css" rel="stylesheet" media="screen">
		<script type="text/javascript" src="./bootstrap-datetimepicker-master/js/bootstrap-datetimepicker.js" charset="UTF-8"></script>
		<script type="text/javascript" src="./bootstrap-datetimepicker-master/js/locales/bootstrap-datetimepicker.zh-CN.js"
		 charset="UTF-8"></script>
		<script type="text/javascript">
			$(function() {
				$('.form_date').datetimepicker({
					language: 'zh-CN',
					format: 'yyyy-mm-dd',
					weekStart: 1,
					todayBtn: 1,
					autoclose: 1,
					todayHighlight: 1,
					startView: 2,
					minView: 2,
					forceParse: 0
				});
			})
		</script>
	</head>
	<body>
		<div class="form-group">
			<label for="dtp_input2" class="col-md-2 control-label">Date Picking</label>
			<div class="input-group date form_date col-md-5" data-date="" data-date-format="dd MM yyyy" data-link-field="dtp_input2"
			 data-link-format="yyyy-mm-dd">
				<input class="form-control" size="16" type="text" value="" readonly>
				<span class="input-group-addon"><span class="glyphicon glyphicon-remove"></span></span>
				<span class="input-group-addon"><span class="glyphicon glyphicon-calendar"></span></span>
			</div>
			<input type="hidden" id="dtp_input2" value="" /><br />
		</div>
		<hr>

		<div id="lunbo" class="carousel slide" data-ride="carousel" data-interval="1000">
			<ol class="carousel-indicators">
				<li data-target="lunbo" data-slide-to="0" class="active"></li>
				<li data-target="lunbo" data-slide-to="1"></li>
				<li data-target="lunbo" data-slide-to="2"></li>
				<li data-target="lunbo" data-slide-to="3"></li>
			</ol>
			<div class="carousel-inner">
				<div class="item active">
					<img src="./img/lunbo/1.jpg">
				</div>
				<div class="item">
					<img src="./img/lunbo/2.jpg">
				</div>
				<div class="item">
					<img src="./img/lunbo/3.jpg">
				</div>
				<div class="item">
					<img src="./img/lunbo/4.jpg">
				</div>
			</div>
		</div>
	</body>
</html>

~~~

# 问题

//只要有一个消失就会输出true  这输出的是哪一个？
~~~html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript" src="jquery-1.11.3.min.js"></script>
		<script type="text/javascript">
			$(function() {

				$("p").click(function() {
					$(this).hide();
				})
				$("#btn1").click(function() {
					$("p").show();
				})
				$("#btn2").click(function() {
					// $("p").each(function() {
					// 	alert($(this).is(":hidden"));
					// })
					alert($("p").is(":hidden"));
				})
			})
		</script>
		</script>
	</head>
	<body>
		<p>点我我就消失</p>
		<p>点我我就消失2</p>
		<p>点我我就消失3</p>
		<button type="button" id="btn1">全部出来！</button>
		<button type="button" id="btn2">查看控件隐藏状态</button>
	</body>
</html>

~~~
---
title:  笔记_009_JavaEE
tag: 
	- javaEE
categories: 
	- java
---
**`J2EE     JAVAEE     Java web`**

# JavaEE
http://127.0.0.1:8088  测试TomCat首页

## servlet
Servlet ---- 是个接口
servlet ---- 是一个实现了Servlet接口的Java类，他可以接收浏览器的请求，返回给浏览器响应

servlet生命周期的相关方法：
1. 构造方法：用来创建当前servlet对象
2. init方法：用来初始化当前servlet对象
3. service方法：用来处理一个前端的请求
4. destroy方法：销毁当前servlet对象

servlet核心配置文件
所有的请求和java类都是靠 `web.xml`对应的
每一个`<servlet>`标签表示一 个servlet，它包含`<servlet-name>` 和 `<servlet-class>`

- `<servlet-name> `是我们自己起的servlet名字
- `<servlet-class>` 是我们自己写的servlet类的全类名

每个`<servlet>` 都有`<servlet-mapping>` 与之对应
` <servlet-mapping>` 中包含`<servlet-name> `和 `<url-pattern>`

- `<servlet-mapping>`中的`<servlet-name> `与 `<servlet>`中的`<servlet-name>` 对应  值相等就完事了
- `<url-pattern>`指的是请求名 通常以`/`开头

当我们启动tomcat之后，我们的javaEE项目就发布了，它等待着前端发起以下格式的请求：
http://ip地址:端口/web应用名/请求名

~~~java
package com.iweb.homework;

import javax.servlet.*;
import java.io.IOException;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-01/0001
 * 描述：测试Servlet生命周期
 */

public class Test2 implements Servlet {
    public Test2() {
        System.out.println("构造Test2");
    }

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("初始化Test2");
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("Test2收到一个请求");
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.iweb.homework.Test2</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/my1threquest</url-pattern>
    </servlet-mapping>

</web-app>

//  运行后在弹出页面的地址栏后面补上my1threquest 回车 即可构造初始化Servlet并接收到请求
~~~



### `<load-on-startup>`
在`<servlet>`中，表示当前servlet对象被创建和初始化的时机，如果取值为0 或正整数，则随着tomcat启动，自动完成创建和初始化
注意：数值越小(>=0)的`<load-on-startup>` 它的`<servlet>`越先被创建和初始化
~~~xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.iweb.homework.Test2</servlet-class>
        <load-on-startup>0</load-on-startup>
    </servlet>

~~~

注意：一个`<servlet>`可以对应多个`<servlet-mapping>`，只需要`<servlet-name> `一致即可，它们的`<url-pattern>`不一样，所以接收到不同的请求，可以进入同一个方法

~~~xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.iweb.homework.Test2</servlet-class>
        <load-on-startup>0</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/my1threquest</url-pattern>
    </servlet-mapping>

    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/my2ndrequest</url-pattern>
    </servlet-mapping>
    
    // 运行后在弹出页面的地址栏后面补上my1threquest或者my2ndrequest 回车 都会使test2收到一个请求
~~~

注意：在`<servlet-mapping>`中，可以使用通配符表示任意请求，通配符的格式：
1. /*
2. /
3. *.后缀名(后缀名随便写)
~~~xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.iweb.homework.Test2</servlet-class>
        <load-on-startup>0</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
    
    // 运行后在弹出页面的地址栏后面随便补上点什么 回车 都会使test2收到一个请求
~~~

~~~xml
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>*.do</url-pattern>
    </servlet-mapping>
    // 运行后在弹出页面的地址栏后面 补上 随便什么.do 回车 都会使test2收到一个请求

~~~

### servletConfig
这是当前servlet的大管家，它可以获取servlet方方面面的信息
例如：

#### 1. `<init-param>`

表示servlet的初始化参数

我们可以通过  该对象.getInitParameter(参数名)  获取参数值

#### 2. getServletName() 

---- 获取当前servlet名字

~~~java
 @Override
 public void init(ServletConfig servletConfig) throws ServletException {
     System.out.println("初始化Test2");
     String str = servletConfig.getInitParameter("username");
     System.out.println(str);
     String servletName = servletConfig.getServletName();
     System.out.println(servletName);

 }
~~~
~~~xml
    <servlet>
     <servlet-name>hello</servlet-name>
     <servlet-class>com.iweb.homework.Test2</servlet-class>
     <init-param>
         <param-name>username</param-name>
         <param-value>root</param-value>
     </init-param>
     <load-on-startup>0</load-on-startup>
 </servlet>
 // 在初始化Servlet时 输出 :
 // root
 // hello 
~~~

#### 3. getServletContext() 

---- 获取当前web应用的对象

注意：ServletContext对象表示当前web应用的对象，它可以获取当前web应用方方面面的信息

~~~java
    @Override
 public void init(ServletConfig servletConfig) throws ServletException {
     ServletContext sc = servletConfig.getServletContext();
     String user = sc.getInitParameter("username");
     System.out.println(user);
 }
~~~
~~~xml
    <context-param>
     <param-name>username</param-name>
     <param-value>Admin</param-value>
 </context-param>
 // 在初始化Servlet时 输出 :
 //Admin
~~~

### ServletContext对象的相关信息：
`<context-param>` ---- 当前web应用的初始化参数
我们可以通过ServletContext对象调用
getInitParameter(参数名) 来获取它的参数值
getRealPath(文件的类路径) ---- 获取到该文件部署后的绝对路径
~~~java
	    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("初始化Test2");
        ServletContext sc = servletConfig.getServletContext();
        String path = sc.getRealPath("/hi.html");
        System.out.println(path);
    }
~~~
getContextPath() ---- 获取的是当前web应用的根目录

### 浏览器页面向后端java类发请求的方式：

1. 地址栏直接写url
2. `<a>`标签超链接
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1 style="color:gold;">我是一个标题</h1>
<a href="abc.do?age=18">发一个请求</a>
</body>
</html>


```java

    @Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println("Test2收到一个请求");
    String age = servletRequest.getParameter("age");
    System.out.println(age);
}
//点一下超链接发一个请求
//输出参数值18
```

3. `<form>`表单提交

请求的url可以携带参数，格式：
1. url?参数名1=参数值1&参数名2=参数值2
2. 在`<form>`中的表单控件上，name属性对应参数名，value属性对应参数值

### ServletRequest
后端Java类中，我们可以使用  ServletRequest对象.getParameter(参数名)  来获取参数值

### 面试题：提交方式get和post的区别
get请求 ---- 请求参数是跟在url地址后面的
	所有的`<a>`都是get请求
post请求 ---- 请求参数是封装在消息体中的

`<form>`的method属性可以指定其为post，如果不指定，则默认为get

注意：get请求的参数的长度不能超过1k，post请求没有长度限制

### ServletResponse
返回响应
我们可以通过该对象调用getWrite()得到PrintWriter对象，然后再调用PrintWriter对象的print()方法往浏览器打印需要返回的内容

~~~java
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("Test2收到一个请求");
        PrintWriter pw = servletResponse.getWriter();
        pw.print("hello");
    }
~~~

HttpServletRequest
它是ServletRequest的子接口，我们在实际发送请求的过程中，前端传递给后端的全部都是HttpServletRequest对象，所以我们可以将ServletRequest向下转型为HttpServletRequest对象，然后可以调用它新增加的方法：
getMethod() ---- 获取当前请求的请求方式，返回GET或POST
getServletContext() ---- 直接获取当前web应用的ServletContext
getServletPath() ---- 获取当前请求的请求名
getContextPath() ---- 获取的是当前web应用的根目录

# 日期：2022-08-02

## HttpServlet

这是一个抽象类，它实现了Servlet接口，并且将ServletRequest和ServletResponse转型成了HttpServletRequest和HttpServletResponse

然后调用HttpServletRequest的getMethod方法判断当前请求是GET还是POST，从而为我们提供了doGet()和doPost()方法

对于我们编程来讲，我们只需要继承HttpServlet类并重写doXxx方法即可，我们可以专注于我们的业务逻辑

~~~java
public class Test1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了一个get请求");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了一个post请求");
    }
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>test1</servlet-name>
        <servlet-class>com.iweb.test.Test1</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>test1</servlet-name>
        <url-pattern>/test1</url-pattern>
    </servlet-mapping>

</web-app>
~~~

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<a href="test1">我是test1</a>
<br/>
<form action="test1" method="post">
    <button>提交</button>
</form>
</body>
</html>
~~~

## JSP

JavaServer Pages

将前后端混合编写的一种技术，混合编写的代码写在.jsp的文件中，页面上静态展示的内容使用html编写，动态展示的数据使用java编写。java代码在jsp页面上需要用<%%>包起来
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: lenovo
  Date: 2022-08-02/0002
  Time: 10:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h3>这是我的以一个jsp页面</h3>
<%
    System.out.println("hello jsp!");
%>
</body>
</html>
~~~
### out.print();
---- 将指定内容打印在浏览器页面上
~~~jsp
<%@ page import="java.util.Date" %><%--
  Created by IntelliJ IDEA.
  User: lenovo
  Date: 2022-08-02/0002
  Time: 10:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h3>这是我的以一个jsp页面</h3>
<%
    Date date = new Date();
    out.print(date);
%>
</body>
</html>
~~~

### jsp的本质

本质是servlet 是后端技术

### jsp九大隐含对象

隐含对象指的是在jsp中没有定义而可以直接使用的对象

1. request ---- HttpServletRequest的对象,它表示当前JSP页面打开的这次请求
2. response ---- HttpServletResponse的对象
3. pageContext ---- PageContext的对象，它表示当前页面，它可以获取其他8个隐含对象
4. session ---- HttpSession的对象，它表示一次会话（浏览器的打开到关闭）
5. application ---- ServletContext的对象，它表示当前的web应用
6. config ---- ServletConfig对象，它表示当前jsp翻译出来的那个servlet中的ServletConfig对象
7. out ---- JspWriter的对象，可以直接把字符串打印在浏览器上
8. page ---- 表示当前JSP翻译出来的那个servlet类的对象
9. exception ---- 表示jsp中发生的各种异常

### JSP表达式

<%=表达式内容%> ---- 可以直接将java变量或表达式打印在页面上

~~~jsp
<%@ page import="java.util.Date" %><%--
  Created by IntelliJ IDEA.
  User: lenovo
  Date: 2022-08-02/0002
  Time: 10:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h3>这是我的以一个jsp页面</h3>
<%
    Date date = new Date();
    out.print(date);
%>
<br/>
<br/>
<%=date%>
<br/>
<br/>
<%
    String age = request.getParameter("age");
    out.print(age);
%>

<%
    int intage = Integer.valueOf(age);
    if (intage > 18) {
        out.print("您已成年");
    } else {
        out.print("未成年人给爷死！");
    }

%>
</body>
</html>

~~~

需要打印的内容以静态页面的方式呈现：（效果同上面一样）
~~~jsp
<%@ page import="java.util.Date" %><%--
  Created by IntelliJ IDEA.
  User: lenovo
  Date: 2022-08-02/0002
  Time: 10:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h3>这是我的以一个jsp页面</h3>
<%
    Date date = new Date();
    out.print(date);
%>
<br/>
<br/>
<%=date%>
<br/>
<br/>
<%
    String age = request.getParameter("age");
    out.print(age);
%>

<%
    int intage = Integer.valueOf(age);
    if (intage >= 18) {
%>

您已成年
<%
} else {
%>
未成年人给爷死！
<%
    }

%>
</body>
</html>
~~~

### JSP的注释
以`<%--`开头   以`--%>`结尾

### 域对象
pageContext, request, session, application 四个隐含对象称为域对象，它们可以调用setAttribute(键，值)   进行存值
getAttribute(键)   进行取值
removeAttribute(键)    进行删除
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 11:22
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>test2.jsp</h1>
<%
    pageContext.setAttribute("pageKey", "pageValue");
    request.setAttribute("requestKey", "requestValue");
    session.setAttribute("sessionKey", "sessionValue");
    application.setAttribute("applicationKey", "applicationValue");
%>

<%
    application.removeAttribute("applicationKey");
%>



<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("requestKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>

</body>
</html>
~~~

### 域对象的作用范围：
pageContext ---- 当前页面
request ---- 一次请求
session ---- 一次会话
application ---- 整个web应用

test2：
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 11:22
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>test2.jsp</h1>
<%
    pageContext.setAttribute("pageKey", "pageValue");
    request.setAttribute("requestKey", "requestValue");
    session.setAttribute("sessionKey", "sessionValue");
    application.setAttribute("applicationKey", "applicationValue");
%>

<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("requestKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>

<br/>
<a href="test3.jsp">跳转到test3页面</a>

</body>
</html>
~~~

test3：
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 11:40
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("requestKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>

</body>
</html>
~~~
### 请求转发和重定向
这是两种用来实现java类跳转到下一个目标的资源的技术
#### 第一种：请求转发的步骤
1. 定义一个String 存放目标资源的路径
2. 通过当前request对象调用getRequestDispatcher(路径) 获取RequestDispatcher对象
3. 使用RequestDispatcher对象调用forward(request,response)完成转发
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 13:34
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>测试请求转发和重定向</h1>
<br/>
<a href="testForward">请求转发</a>

</body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 13:35
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>成功页面</h1>
</body>
</html>
~~~
~~~java
public class TestForward extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始请求转发");
        String path = "/success.jsp";
        RequestDispatcher rd = req.getRequestDispatcher(path);
        rd.forward(req, resp);//完成转发
    }
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>testForward</servlet-name>
        <servlet-class>com.iweb.test.TestForward</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>testForward</servlet-name>
        <url-pattern>/testForward</url-pattern>
    </servlet-mapping>

</web-app>
~~~
#### 第二种：重定向
1. 定义一个String 存放目标资源的路径 (路径要从web站点根目录开始)
2. 利用当前response对象调用sendRedirect(路径) 完成重定向
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 13:34
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>测试请求转发和重定向</h1>
<br/>
<a href="testForward">请求转发</a>
<br/>
<a href="testRedirect">重定向</a>
</body>
</html>
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>testRedirect</servlet-name>
        <servlet-class>com.iweb.test.TestRedirect</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testRedirect</servlet-name>
        <url-pattern>/testRedirect</url-pattern>
    </servlet-mapping>

</web-app>
~~~
~~~java
public class TestRedirect extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始重定向");
        String path = "/test20220802/success.jsp";
        resp.sendRedirect(path);


    }
}
~~~

##### 请求转发和重定向的区别：
- 请求转发在转发前和转发后，是同一次请求
- 重定向在重定向前和重定向后是两次不同的请求

###### 细节上的区别：
1. 目标路径的斜杠含义不同
	转发的时候，/ 表示web应用的根目录
	重定向的时候，/ 表示web站点的根目录
	

**注意**：http请求的格式：
http://ip:端口  ---- web站点的根目录
web站点的根目录 + web应用的名字 ---- web应用的根目录
web应用的根目录 + 请求名 ---- 完整的http请求

2. url地址栏显示的内容不同：
	转发的时候显示的是初次发起的请求名
	重定向的时候显示的是最终目标资源的文件名
	
3. 转发前和转发后是同一个request对象
	重定向前和重定向后是两个不同的request对象
~~~java
public class TestForward extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始请求转发");
        req.setAttribute("myKey01","myValue01");
        String path = "/success.jsp";
        RequestDispatcher rd = req.getRequestDispatcher(path);
        rd.forward(req, resp);//完成转发
    }
}
~~~
~~~java
public class TestRedirect extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始重定向");
        req.setAttribute("myKey02", "myValue02");
        String path = "/test20220802/success.jsp";
        resp.sendRedirect(path);
    }
}
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 13:34
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>测试请求转发和重定向</h1>
<br/>
<a href="testForward">请求转发</a>
<br/>
<a href="testRedirect">重定向</a>
</body>
</html>
~~~

4. 转发只能转到当前web应用以内的资源
	重定向可以重定向到任何资源
~~~java
public class TestForward extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始请求转发");
        req.setAttribute("myKey01","myValue01");
        String path = "http://www.bing.com";
        RequestDispatcher rd = req.getRequestDispatcher(path);
        rd.forward(req, resp);//完成转发
    }
}
~~~
~~~java
public class TestRedirect extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始重定向");
        req.setAttribute("myKey02", "myValue02");
        String path = "http://www.bing.com";
        resp.sendRedirect(path);
    }
}
~~~

注意：请求转发和重定向 不仅仅可以跳转到下一个页面，它还可以跳转进入下一个servlet
~~~java
public class TestForward extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始请求转发");
        req.setAttribute("myKey01","myValue01");
        String path = "/test";
        RequestDispatcher rd = req.getRequestDispatcher(path);
        rd.forward(req, resp);//完成转发
    }
}
~~~
~~~java
public class TestRedirect extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将开始重定向");
        req.setAttribute("myKey02", "myValue02");
        String path = "/test20220802/test";
        resp.sendRedirect(path);
    }
}
~~~
~~~xml
    <servlet>
        <servlet-name>test</servlet-name>
        <servlet-class>com.iweb.test.Test</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>test</servlet-name>
        <url-pattern>/test</url-pattern>
    </servlet-mapping>
~~~
~~~java
public class Test extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是下一个java类");
    }
}
~~~

### 发请求的路径问题
我们通过`<a>`的href属性和`<form>`的action属性发请求，最好写成以下路径格式：
`<%=request.getContextPath()%>/请求名`
否则有可能会带来路径的错误

~~~java
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-02/0002
  Time: 13:34
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>测试请求转发和重定向</h1>
<br/>
<a href="<%=request.getContextPath()%>/testForward">请求转发</a>
<br/>
<a href="<%=request.getContextPath()%>/testRedirect">重定向</a>
<form action="<%=request.getContextPath()%>/testRedirect">

</form>
</body>
</html>
~~~
### 表单提交中文乱码问题
在request.getParameter(""); 之前添加：
request.setCharacterEncoding("utf-8"); 即可

~~~java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        String username = req.getParameter("username");
        System.out.println(username);
    }
~~~

### MVC开发模型
Model View Controller
#### 最典型的MVC就是jsp+servlet+javabean模式
- JavaBean作为模型，既可以作为数据模型来封装业务数据，又可以作为业务逻辑模型来包含应用的业务操作。其中，数据模型用来存储或传递业务数据，而业务逻辑模型接收到控制器传过来的模型更新请求后，执行特定的业务逻辑处理，然后返回相应的执行结果。

- JSP作为视图层，负责提供页面为用户展示数据，提供相应的表单（Form）来用于用户的请求，并在适当的时候（点击按钮）向控制器发出请求来请求模型进行更新。

- Serlvet作为控制器，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图。
---
title:  笔记_010_EL
tag: 
	- 前端
categories: 
	- java
---


# 2022-08-08

## EL

（Expression Language）

---- 这是页面上用来获取数据的表达式 

`${}`

1. `${param.参数名} ---- 从请求参数中获取参数值，如果参数值是null，则保留空字符串`

~~~jsp
        <tr>
            <td align="right" style="width:40%;">类别名称 :</td>
            <td align="left">&nbsp;<input type="text" id="categoryName"
                                          value="${param.categoryname}"
                                          name="categoryname"/><span
                    style="color: red"> *</span><span id="message0" style="color: red;" class="message"></span></td>
        </tr>
~~~

2. `${requestScope.键} ---- 从request域对象里获取指定键对应的值，如果值是null则返回空字符串`

~~~jsp
            var message = "${requestScope.message}";
            if (message != null && message != "") {
                alert(message);
            }
~~~
注意：`requestScope.`可以省略
~~~jsp
            var message = "${message}";
            //alert(message)
            if (message != null && message != "") {
                alert(message);
            }
            
~~~
3. `${sessionScope.键} ---- 从session域对象里获取指定键对应的值，如果值是null则返回空字符串`
4. `${applicationScope.键} ---- 从application域对象里获取指定键对应的值，如果值是null则返回空字符串`
**注意**：`xxxScope`可以省略，当它省略时，EL表达式会按照域对象作用范围从小到大的顺序，依次查找，中途找到了就不再往下寻找，直接返回
5. **注意**：在EL表达式中，如果是域对象的取值，取到值之后再写小数点，表示该对象的get方法，它可以获取该对象成员变量的值
~~~jsp
<%@ page import="com.iweb.model.Category" %>
<%@ page import="com.iweb.model.Fiction" %><%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>AAA</h1>
<%
    session.setAttribute("sessionKey", "sessionValue");
    application.setAttribute("applicationKey", "applicationValue");

%>
<%

    Category category = new Category(1001, "玄幻小说", "2022-08-08", "描写中土大陆的奇闻异事");
    session.setAttribute("category", category);

%>

<%

    Fiction fiction = new Fiction(500, "射雕英雄传", "", "", "", false, false, "", "", category);
    session.setAttribute("fiction", fiction);


%>

<a href="./B.jsp">BBB</a>
</body>
</html>

~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>BBB</h1>
${sessionScope.sessionKey}
<br/>
${applicationScope.applicationKey}

<hr/>
${sessionScope.category.categoryid}
<br/>
${sessionScope.category.categoryname}
<br/>
${sessionScope.category.createtime}
<br/>
${sessionScope.category.description}
<br/>
<hr/>
${sessionScope.fiction.category.categoryname}


</body>
</html>
~~~
**注意：**如果域对象的键值对的键本身含有小数点，那么我们在EL表达式中可以使用`[""]`来取代小数点
~~~jsp
<%@ page import="com.iweb.model.Category" %>
<%@ page import="com.iweb.model.Fiction" %><%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>AAA</h1>


<%
session.setAttribute("com.iweb.test.A","A");
%>

<a href="./B.jsp">BBB</a>
</body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>BBB</h1>


${sessionScope["com.iweb.test.A"]}

</body>
</html>
~~~
**注意：**EL表达式的值在做算数运算时可以自动转型
~~~jsp
<%@ page import="com.iweb.model.Category" %>
<%@ page import="com.iweb.model.Fiction" %><%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>AAA</h1>
<a href="./B.jsp?score=89">BBB</a>
</body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>BBB</h1>


<%=request.getParameter("score") + 11%>
<br/>
${param.score+11}
</body>
</html>
~~~

### 使用EL表达式获取当前web应用的根目录：
`${pageContext.request.contextPath}`
它等同于
`<%=request.getContextPath()%>`

## JSTL 

Jsp Standard Tag Library
它可以搭配EL表达式，让我们的页面代码更加的简单和强大

使用方法：
- 导入jar包：jstl.jar 和 standard.jar  缺一不可
- 在需要使用的页面上 添加  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>

~~~jsp
<%@ page import="com.iweb.model.Category" %>
<%@ page import="com.iweb.model.Fiction" %><%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>AAA</h1>


<a href="./B.jsp?score=89&book=<<java>>">BBB</a>
</body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>BBB</h1>

<br/>
${param.score+11}
<br/>

${pageContext.request.contextPath}
<br/>
<%=request.getContextPath()%>
<br/>
<c:out value="${param.book}"></c:out>
</body>
</html>
~~~

### `<c:forEach>`标签
用来循环遍历一个域对象中的集合
items属性表示通过EL表达式获取域对象中的集合
var属性表示定义一个遍历集合的对象
**注意**：在该标签对中，直接使用`${对象.属性}`来展示遍历到的每一个对象的属性值

~~~jsp
        <c:forEach items="${requestScope.categories}" var="category">
            <tr>
                <td>${category.categoryid}
                </td>
                <td>${category.categoryname}
                </td>
                <td>${category.createtime}
                </td>
                <td class="desc">${category.description}
                </td>
                <td>
                    <a href="<%=request.getContextPath()%>/toAdd.category?categoryid=${category.categoryid}&categoryname=${category.categoryname}&description=${category.description}">编辑</a>
                </td>
                <td><a href="<%=request.getContextPath()%>/delete.category?categoryid=${category.categoryid}"
                       class="del">删除</a></td>
            </tr>
        </c:forEach>
~~~

### `<c:if>`标签
用来条件判断
test属性编写一个EL表达式从域对象或者请求参数中取值，进行判断，如果满足条件，则展示该标签对中的内容，否则不展示
**注意**：没有对应的else标签
~~~jsp
<%@ page import="com.iweb.model.Category" %>
<%@ page import="com.iweb.model.Fiction" %><%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>AAA</h1>

<a href="./B.jsp?score=89&book=<<java>>">BBB</a>
</body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 9:25
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>BBB</h1>

<br/>
${param.score+11}
<br/>

${pageContext.request.contextPath}
<br/>
<%=request.getContextPath()%>
<br/>
<c:out value="${param.book}"></c:out>
<br/>
<c:if test="${param.score>=90}">
    考得很好！
</c:if>
<c:if test="${param.score<90}">
    继续努力！
</c:if>
</body>
</html>
~~~
### `<c:redirect url="目标路径">`
---- 重定向到目标路径
`/`表示web应用的根目录

### `<c:import url="目标路径">` 
---- 将目标路径的页面合并到当前页面中
~~~jsp
<!-- 在B页面的<body>中写 将BC页面合并 -->
<c:import url="/test/C.jsp"></c:import>
~~~
**注意**：`<%@ include file="目标路径"%>` ---- 也可以实现页面合并
**注意**：`<%@ include %>`只能合并当前web应用以内的页面,`<c:import url="目标路径">` 可以合并任何资源（例如：百度）

### errorPage属性
---- 在page指令中，表示错误页面的路径，如果当前页面报错，就会自动跳转到错误页面，给出友好性的提示
~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" errorPage="/error.jsp" %>
~~~

如果在错误页面添加isErrorPage="true"的提示，那么该页面上可以使用隐含对象exception来展示简要的错误消息
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 13:37
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" isErrorPage="true" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>对不起了，网站正在维护</h1>
<%=exception%>
</body>
</html>
~~~

## cookie 
----这是一个容器，里面存放各种键值对，其中包括JSession，服务器正是通过cookie判断一系列请求是否来自同一个浏览器
当浏览器第一次发请求的时候，没有携带cookie，服务器创建cookie对象，创建JSession字符串，并随响应带回浏览器，浏览器将其存储在硬盘，再次发送请求时，请求携带该数据到服务器，服务器完成比对，以此证明不同的请求来自相同的浏览器

### 获取cookie信息
通过request.getCookies() 可以得到cookie数组
我们可以循环遍历Cookie数组中的每一个Cookie对象，再由Cookie对象调用getName() 和 getValue() 来获取其中的键值对

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 15:41
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

<%
    Cookie[] cookies = request.getCookies();
    if (cookies == null || cookies.length == 0) {
        out.print("第一次发请求");
    } else {
        for (int c = 0; c < cookies.length; c++) {
            out.println(cookies[c].getName() + "....." + cookies[c].getValue());
        }
    }

%>

</body>
</html>
~~~

创建Cookie ---- new Cookie(键，值);
将创建的Cookie对象绑定到response中 
response.addCookie(cookie对象)

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-08/0008
  Time: 15:41
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

<%
    Cookie[] cookies = request.getCookies();
    if (cookies == null || cookies.length == 0) {
        out.print("第一次发请求");
        Cookie cookie = new Cookie("myCookieName", "myCookieValue");
        response.addCookie(cookie);
    } else {
        for (int c = 0; c < cookies.length; c++) {
            out.println(cookies[c].getName() + "....." + cookies[c].getValue());
            out.print("<br/>");
        }
    }

%>

</body>
</html>
~~~

cookie的默认级别是会话级别，它会随着浏览器的关闭而消失，我们可以手动地将其置为持久级别，只需要调用setMaxAge(秒数)  ，那么该cookie对象就会在指定的时间到达后消失
**注意**：如果传入的秒数为0 那么该cookie对象立即消失，如果传入负数，那么还是会话级别的cookie

### cookie和session区别
cookie在浏览器 session在服务器

## Session
表示一次会话，它是HttpSession类的对象，是JSP的隐含对象
### 常用方法：
#### getId() 
---- 当前会话的JSessionid
#### isNew()
---- 判断当前会话是否是新创建的
#### getMaxInactiveInterval()
---- 使当前会话失效的两次请求间隔的时间(session过期时间 默认1800秒)
#### getCreationTime()
---- 当前会话的创建时间

#### getLastAccessedTime()
---- 当前会话上一次请求的时间
#### invalidate()
---- 使当前会话失效

### 利用Session我们可以有效防止表单的重复提交
我们在提交表单的时候，在session放一个标记位，请求到达后端，删除该标记位并走一次业务逻辑，如果后端判断没有该标记位，则不走业务逻辑，并跳转到提示页面
#### 以下情况算重复提交
1. 多次点击“提交”
2. 在成功页面上刷新页面（前提是转发到成功页面）
3. 在成功页面上点击后退再点击提交

**注意**：在成功页面上点击后退，再刷新页面，再点击提交，不算重复提交
---
title:  笔记_011_Ajax
tag: 
	- java
categories: 
	- java
---

# Ajax

Asynchronous JavaScript And Xml

无需刷新页面，而使前后端通信的技术，在用户不知情的情况下，前端向后端发送请求，得到后端的响应，局部地更新页面的一种技术

Ajax总是在JS的事件中发请求

原生态的Ajax代码是围绕XMLHttpRequest对象展开的，我们可以
1. 调用它的open方法装载数据
2. 调用它的send方法发送请求
3. 调用它的onreadystatechange()方法接收来自后端的响应

原生态的Ajax写法
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-10/0010
  Time: 8:55
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>$Title$</title>
    <script type="text/javascript">
        window.onload = function () {
            var helloText = document.getElementById("hello");
            helloText.onkeyup = function () {
                var req = new XMLHttpRequest();
                var url = "<%=request.getContextPath()%>/helloajax";
                var method = "GET";
                req.open(method, url);
                req.send(null);//get请求不用传参
                req.onreadystatechange = function () {
                    if (req.readyState == 4) {
                        //已经接收到了后端来的反馈
                        if (req.status == 200 || req.status == 304) {
                            document.getElementById("message").innerHTML = req.responseText;
                        }
                    }
                }
            }
        }
    </script>
</head>
<body>
<input type="text" id="hello"/><span id="message" style="color:red;"></span>
</body>
</html>
~~~

~~~jsp
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">


    <servlet>
        <servlet-name>helloajax</servlet-name>
        <servlet-class>com.iweb.test.HelloAjax</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>helloajax</servlet-name>
        <url-pattern>/helloajax</url-pattern>
    </servlet-mapping>


</web-app>
~~~
~~~java
package com.iweb.test;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;



public class HelloAjax extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("Hello Ajax");
        PrintWriter pw = resp.getWriter();
        pw.print("Hello Ajax");
    }


}
~~~

# JSON
---- 这是一种数据格式，经常用于前后端交互的时候，来封装传递的数据，格式：
以`{`开头，以`}`结尾，中间是键值对，键和值以冒号分割，键值对之间以逗号分割
在js中，`Json对象.键 ` 可以得到值
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-10/0010
  Time: 9:32
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function () {
            var obj = {
                "name": "Tom", "age": 18,
                "address": {"city": "nanjin", "school": "南信大"},
                "teach": function () {
                    alert("java");
                }
            };
            alert(obj.name);
            alert(obj.age);
            alert(obj.address.school);
            obj.teach();
            
        }
    </script>
</head>
<body>

</body>
</html>

~~~
**注意**：Json中，值可以是任何类型，也可以是一个json，还可以是一个函数

# eval函数

---- 这是一个js的函数，它可以将字符串中的js代码解析出来

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-10/0010
  Time: 9:32
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function () {
         
            var testEval = "alert(\"Hello\")";
            eval(testEval);
            
            var testJsonStr = "{\"name\":\"iweb\"}";
            var jsonObj = eval("(" + testJsonStr + ")");
            alert(jsonObj.name);
        }
    </script>
</head>
<body>

</body>
</html>
~~~

**注意**：如果使用eval函数解析JSON字符串，则需要在左右两边分别拼上 `"("`  和 `")"`

~~~jsp
            var testJsonStr = "{\"name\":\"iweb\"}";
            var jsonObj = eval("(" + testJsonStr + ")");
            alert(jsonObj.name);
~~~

## JSON字符串转字符对象

使用`JSON.parse(json字符串) ` 即可

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-10/0010
  Time: 9:32
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function () {
            var obj = {
                "name": "Tom", "age": 18,
                "address": {"city": "nanjin", "school": "南信大"},
                "teach": function () {
                    alert("java");
                }
            };
          
            var testJsonStr = "{\"name\":\"iweb\"}";
            // var jsonObj = eval("(" + testJsonStr + ")");
            // alert(jsonObj.name);
            var jsonObj = JSON.parse(testJsonStr);
            alert(jsonObj.name);


        }
    </script>
</head>
<body>

</body>
</html>

~~~

# `JQuery`框架将原生态的Ajax代码封装成一个叫作`$.ajax()`

然后它再次对$.ajax()进行二次封装，提供给我们以下三个函数：
1. load() ---- 由某元素节点调用，返回值自动填充在该元素节点的子元素位置,它如果传一个url，则发起get请求，如果传一个url和一个json格式的参数对象，则发起post请求
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-10/0010
  Time: 10:35
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/jquery-3.2.1.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#hello").keyup(function () {
                var str = $(this).val();
                var param = {
                    "name": str
                };
                $("#message").load("<%=request.getContextPath()%>/helloajax", param);
            })
        })
        <%--$(function () {--%>
        <%--    $("#hello").keyup(function () {--%>
        <%--        var str = $(this).val();--%>
        <%--            $("#message").load("<%=request.getContextPath()%>/helloajax?name=" + str);--%>
        <%--    })--%>
        <%--})--%>
    </script>
</head>
<body>
<input type="text" id="hello"/><span id="message" style="color:red;"></span>

</body>
</html>
~~~
~~~java
package com.iweb.test;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-10/0010
 * 描述：
 */

public class HelloAjax extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        System.out.println("Hello Ajax");
        String name = req.getParameter("name");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");//设置发送到客户端的响应的内容类型
        PrintWriter pw = resp.getWriter();
        pw.print("Hello " + name);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是一个post请求");
        req.setCharacterEncoding("utf-8");//请求转码  ----- 中文请求不乱码
        String name = req.getParameter("name");//获取
        resp.setCharacterEncoding("utf-8");//响应转码  ----- 打印中文不乱码
        resp.setContentType("text/html");//设置发送到客户端的响应的内容类型
        PrintWriter pw = resp.getWriter();
        pw.print("hello " + name);
    }
}
~~~

2. $.get(url,json参数,function回调方法) ---- 它只能发起get请求，后端的响应封装在回调方法的参数中
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-10/0010
  Time: 10:35
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/jquery-3.2.1.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#hello").keyup(function () {
                var str = $(this).val();
                var param = {
                    "name": str
                };
                var url = "<%=request.getContextPath()%>/helloajax";
                <!--$("#message").load("
                <%=request.getContextPath()%>/helloajax", param);-->
                $.get(url, param, function (data) {
                    $("#message").html(data);
                })
            })
        })
        <%--$(function () {--%>
        <%--    $("#hello").keyup(function () {--%>
        <%--        var str = $(this).val();--%>
        <%--            $("#message").load("<%=request.getContextPath()%>/helloajax?name=" + str);--%>
        <%--    })--%>
        <%--})--%>
    </script>
</head>
<body>
<input type="text" id="hello"/><span id="message" style="color:red;"></span>

</body>
</html>
~~~

3. $.post(url,json参数,function回调方法) ---- 它只能发起post请求，后端的响应封装在回调方法的参数中
**注意**：如果ajax返回的内容带有中文，那么请在返回之前添加：
~~~java
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
~~~

## fastjson
这是由阿里巴巴公司提供的，将java对象转json字符串的框架，我们只需要使用
JSONObject.toJSONString(json对象);   ---- 就可以得到该对象对应的JSON字符串

使用方法：
-  导入fastjson-1.2.53.jar包
~~~java
    public static void main(String[] args) {
        Student s = new Student("1001", "张三", "20", "男");
        String json = JSONObject.toJSONString(s);
        System.out.println(json);
        //输出
        //{"gender":"男","sage":"20","sname":"张三","sno":"1001"}

    }
~~~
**注意**：如果有一个集合对象，那么fastjson将提供一个JSON数组字符串来表示
~~~java
    public static void main(String[] args) {
        Student s = new Student("1001", "张三", "20", "男");
        String json = JSONObject.toJSONString(s);
        //System.out.println(json);

        Student s2 = new Student("1002", "张三", "20", "男");
        Student s3 = new Student("1003", "李四", "20", "男");
        Student s4 = new Student("1004", "王五", "20", "男");
        List<Student> list = new ArrayList<>();
        list.add(s);
        list.add(s2);
        list.add(s3);
        list.add(s4);
        String json2 = JSONObject.toJSONString(list);
        System.out.println(json2);


    }
~~~

~~~java
    public static void main(String[] args) {
        Student s = new Student("1001", "张三", "20", "男");
        String json = JSONObject.toJSONString(s);
        //System.out.println(json);

        Student s2 = new Student("1002", "张三", "20", "男");
        Student s3 = new Student("1003", "李四", "20", "男");
        Student s4 = new Student("1004", "王五", "20", "男");
        List<Student> list = new ArrayList<>();
        list.add(s);
        list.add(s2);
        list.add(s3);
        list.add(s4);
        String json2 = JSONObject.toJSONString(list);
        //System.out.println(json2);

        Teacher teacher = new Teacher("5000", "王小明", "30", list);
        String json3 = JSONObject.toJSONString(teacher);
        System.out.println(json3);


    }
~~~

在项目中，我们首先迅速打开页面，展示静态内容，然后我们可以使用Ajax发起二次请求，查询数据库，将数据库填充在静态页面上，缓解因为性能问题造成用户长时间等待空白页面的焦虑
~~~java
package com.iweb.test;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-11/0011
 * 描述：
 */

public class Student {
    private String sno;
    private String sname;
    private String sage;
    private String gender;


    public Student() {
    }

    public Student(String sno, String sname, String sage, String gender) {
        this.sno = sno;
        this.sname = sname;
        this.sage = sage;
        this.gender = gender;
    }

    public String getSno() {
        return sno;
    }

    public void setSno(String sno) {
        this.sno = sno;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getSage() {
        return sage;
    }

    public void setSage(String sage) {
        this.sage = sage;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}
~~~
~~~java
package com.iweb.test;

import com.alibaba.fastjson.JSONObject;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-11/0011
 * 描述：
 */

public class StudentServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String path = req.getServletPath();
        switch (path) {
            case "/toEdit.student":
                req.getRequestDispatcher("/edit.jsp").forward(req, resp);
                break;
            case "/queryDate.student":
                query(req, resp);
                break;
            default:
                break;

        }
    }

    protected void query(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        String sno = req.getParameter("sno");
        System.out.println("根据学号：" + sno + "开始查询数据库");
        Student s = new Student("1001", "张三", "20", "男");
        String res = JSONObject.toJSONString(s);
        resp.setCharacterEncoding("utf-8");
        resp.getWriter().print(res);

    }

}
~~~
~~~xml
    <servlet>
        <servlet-name>student</servlet-name>
        <servlet-class>com.iweb.test.StudentServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>student</servlet-name>
        <url-pattern>*.student</url-pattern>
    </servlet-mapping>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-11/0011
  Time: 11:55
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<script type="text/javascript" src="<%=request.getContextPath()%>/jquery-3.2.1.js"></script>
<script type="text/javascript">
    $(function () {
        var url = "<%=request.getContextPath()%>/queryDate.student";
        var param = {
            "sno": ${param.sno}
        };
        $.post(url, param, function (data) {
            var jsonObj = JSON.parse(data);
            $("#sno").val(jsonObj.sno);
            $("#sname").val(jsonObj.sname);
            $("#sage").val(jsonObj.sage);
            $("#gender").val(jsonObj.gender);
        })
    })


</script>
<h1>我是编辑页面</h1>
学号：<input id="sno" name="sno" value=""/>
<br/><br/>
姓名：<input id="sname" name="sname" value=""/>
<br/><br/>
年龄：<input id="sage" name="sage" value=""/>
<br/><br/>
性别： <input id="gender" name="gender" value=""/>
<br/><br/>
<input type="submit" value="提交">

</body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-11/0011
  Time: 9:46
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>
<a href="<%=request.getContextPath()%>/toEdit.student?sno=1001">编辑</a>
</body>
</html>
~~~
以上代码实现分布式加载页面，先显示静态布局，再等两秒后加载数据

---
title:  笔记_012_Filter过滤器
tag: 
	- java
categories: 
	- java
---

# Filter

通常来讲，过滤器指的是一个实现Filter接口（Tomcat中的）的java类，它可以通过web.xml来配置所拦截的资源
过滤器有生命周期相关的方法：
init() ---- 初始化
doFilter() ---- 拦截到一个请求
destory() ---- 销毁

**注意**：在web.xml 中需要配置过滤器拦截怎样的请求
`<filter>`下包含`<filter-name>`和`<filter-class>`
`<filter-class>`指向过滤器类的全类名
`<filter-mapping>`下包含`<filter>`对应的`<filter-name>`和需要拦截的`<url-pattern>`

~~~java
package com.iweb.test;


import javax.servlet.*;
import java.io.IOException;
import java.util.logging.LogRecord;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-12/0012
 * 描述：
 */

public class HelloFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("当前过滤器初始化了");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了一个去test1的请求！");
    }

    @Override
    public void destroy() {
        System.out.println("当前过滤器销毁了");
    }
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/test1.jsp</url-pattern>
    </filter-mapping>

</web-app>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-12/0012
  Time: 8:45
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
  <a href="<%=request.getContextPath()%>/test1.jsp">test1</a>
  </body>
</html>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-12/0012
  Time: 8:46
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>test1页面</h1>
</body>
</html>
~~~
## 放行
如果在doFilter()方法拦截到请求之后需要放行，则可以调用它的参数FilterChain对象的doFilter(request,response)方法进行放行
~~~java
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了一个去test1的请求！");
        filterChain.doFilter(servletRequest, servletResponse);//放行

    }
~~~

**注意**：过滤器可以拦截一个去往servlet的请求

过滤器的初始化参数：在`<filter>`中，可以配置`<init-param>`，其中包含`<param-name>`和`<param-value>`我们在init方法中可以使用filterConfig对象调用getInitParameter(参数名)得到参数值

**注意**：servlet 能干的事情，filter都能干，过滤器可以取代servlet，除此之外，它还善于过滤
~~~java
package com.iweb.test;

import javax.servlet.*;
import java.io.IOException;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-12/0012
 * 描述：
 */

public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String username = filterConfig.getInitParameter("username");
        System.out.println(username);

        ServletContext sc = filterConfig.getServletContext();
        String user = sc.getInitParameter("user");
        System.out.println(user);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截MyServlet");
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {

    }
}
~~~
~~~java
package com.iweb.test;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-12/0012
 * 描述：
 */

public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了一个请求");
    }


}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <context-param>
        <param-name>user</param-name>
        <param-value>root</param-value>
    </context-param>

    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/test1.jsp</url-pattern>
    </filter-mapping>


    <filter>
        <filter-name>myfilter</filter-name>
        <filter-class>com.iweb.test.MyFilter</filter-class>
        <init-param>
            <param-name>username</param-name>
            <param-value>admin</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>myfilter</filter-name>
        <url-pattern>/myServlet</url-pattern>
    </filter-mapping>


    <servlet>
        <servlet-name>myServlet</servlet-name>
        <servlet-class>com.iweb.test.MyServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>myServlet</servlet-name>
        <url-pattern>/myServlet</url-pattern>
    </servlet-mapping>


</web-app>
~~~
~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-12/0012
  Time: 8:45
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>$Title$</title>
</head>
<body>
<a href="<%=request.getContextPath()%>/test1.jsp">test1</a>
<br/>
<a href="<%=request.getContextPath()%>/myServlet">发个请求</a>
</body>
</html>
~~~

过滤器支持多层过滤，多个过滤器可以拦截同一个请求，每个过滤器放行会放行到下一层过滤器，如果当前是最后一层，则放行到目标资源
注意：多层过滤的时候，先后顺序是由web.xml中的`<filter-mapping>`配置的先后顺序决定的

# 练习

创建两个web应用的初始化参数，分别记录用户名和密码，画一个登录页面，再画一个成功页面，输入账号密码，点击登录直接跳转到成功页面

创建两个过滤器，第一个专门过滤账号对不对，对就放行，不对就转发回登录页面，提升账号错误

如果放行，那就来到第二个过滤器，校验密码，对就放行，不对就转发回登录页面，提升密码错误

~~~java
package com.iweb.test;

import javax.servlet.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-12/0012
 * 描述：
 */

public class UsernameFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        ServletContext sc = request.getServletContext();
        String user = sc.getInitParameter("user");//配置文件中存储的账号信息 项目中用数据库数据替代
        String username = request.getParameter("username");//前端传入的账号
        if (user.equals(username)) {
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            request.setAttribute("message", "账号错误");
            request.getRequestDispatcher("/index.jsp").forward(servletRequest, servletResponse);
        }
    }

    @Override
    public void destroy() {

    }
}

~~~

~~~java
package com.iweb.test;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-12/0012
 * 描述：
 */

public class PasswordFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        String password = servletRequest.getParameter("password");
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        ServletContext sc = request.getServletContext();
        String user = sc.getInitParameter("passwd");
        if (user.equals(password)) {
            filterChain.doFilter(servletRequest, servletResponse);

        } else {
            request.setAttribute("message", "密码错误");
            request.getRequestDispatcher("/index.jsp").forward(servletRequest, servletResponse);
        }
    }

    @Override
    public void destroy() {

    }
}

~~~

~~~xml

    <context-param>
        <param-name>user</param-name>
        <param-value>root</param-value>
    </context-param>

    <context-param>
        <param-name>passwd</param-name>
        <param-value>123456</param-value>
    </context-param>


    <filter>
        <filter-name>usernameFilter</filter-name>
        <filter-class>com.iweb.test.UsernameFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>usernameFilter</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>

    <filter>
        <filter-name>passwordFilter</filter-name>
        <filter-class>com.iweb.test.PasswordFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>passwordFilter</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-12/0012
  Time: 8:45
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>$Title$</title>

    <%
        String username = request.getParameter("username");
        String password = request.getParameter("username");

    %>
</head>
<body>
<h1>登录页面</h1>
<form action="<%=request.getContextPath()%>/success.jsp" method="post">

    账号：<input type="text" name="username" value=""/>
    <br/>
    密码：<input type="password" name="password" value=""/>
    <br/>
    <input type="submit" value="登录">
    <br/>
    <br/>
    <span style="color:red;">${message}</span>

</form>
</body>
</html>

~~~

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2022-08-12/0012
  Time: 10:43
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>登录成功！</h1>
</body>
</html>

~~~

# Maven
项目管理工具
Maven的两大核心

1. 依赖管理：对Jar包统一管理，jar存放在仓库中，项目中只要配置坐标信息即可，坐标信息包括公司名+项目名+版本号
2. 项目构建：编码完成后，它可以对项目进行自动的编译，打包，部署等一系列操作

mvn help:system  ----- **显示平台详细信息的列表**

Maven项目的核心配置文件是pom.xml,它主要配置了当前项目所需要的jar包依赖
我们添加`<dependencies>`表示一组依赖，它包含一组`<dependency>`，每个`<dependency>`就是一个依赖
每个`<dependency>`中包含：
`<groupId>公司名</groupId>`
`<artifactId>项目名</artifactId>`
`<version>版本号</version>`


以下代码放pom.xml 中解决控制台打印中文乱码问题
~~~xml
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>
    </properties>

~~~

---
title:  笔记_013_框架
tag: 
	- 框架
categories: 
	- java
---

# MyBatis

这是一个持久层的框架，是一个ORM的框架 

ORM ---- 对象关系映射 Object Relational Mapping

**对应关系**:

|  一个java类  |      一张表      |
| :----------: | :--------------: |
| 一个成员变量 |     一个字段     |
|   一个对象   | 数据库内一行记录 |

## 搭建MyBatis过程

1. 创建一个Maven工程，在pom.xml中添加数据库驱动包和MyBatis的jar包

2. 数据库中准备一张表，java中准备一个实体类，它们之间进行ORM对象关系映射

3. 配置MyBatis总的配置文件，通常在resources文件夹下mybatis-config.xml，从官方文档中考入模板，修改驱动类，url,username,password等属性

4. 配置sql语句的配置文件，注意

   1. 每个sql语句文件具有唯一的namespace

   2. 每个sql语句的标签中具有id属性，parameterType属性表示传入参数的类型，resultType属性表示返回值的类型

   3. sql语句中的参数使用#{参数名}来接收

5. 将sql语句配置文件的路径添加到总的配置文件下`<mappers>`中

6. 在pom.xml中添加`<build>`,里面包含`<resources>`,其中各个`<resource>`分别指向总的配置文件和sql配置文件的文件夹路径

7. 编写测试类，在测试类中，使用SqlSessionFactoryBuilder对象调用build(inputStream)来建造SqlSessionFactory,注意：inputStream 为指向总的配置文件的输入流 然后使用SqlSessionFactory调用openSession()得到SqlSession对象； 最后使用SqlSession对象调用sql语句的方法传入命名空间.id和参数执行sql语句

pom.xml:
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.iweb</groupId>
    <artifactId>MyBatis</artifactId>
    <version>1.0-SNAPSHOT</version>


    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>

        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.6</version>
        </dependency>
    </dependencies>


    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
        </resources>


    </build>


    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>
    </properties>

</project>
~~~

resourses文件夹下 mybatis-config.xml
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.77.100:3306/mysql"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="com/iweb/dao/MyUser.xml"/>
    </mappers>
</configuration>
~~~

## MyBatis 中的查询
所有select语句都是写在`<select>`中
selectOne() ---- 查询单条记录
selectList() ---- 查询多条记录
**注意**：在没有ORM的时候，我们可以使用：
List<Map<String,Object>>类型的结果集接收查询结果
select语句的resultType定义为java.util.Map即可

**注意**：我们可以手动添加orm：
使用`<resultMap>`可以创建一个对象关系映射 type属性指向某java类
每一个`<result>`指向一个字段的对应关系
property表示成员变量名，column表示字段名
在`<select>`中，我们不再使用resultType 而使用 resultMap定义返回值类型

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：MyUser的model类
 */

public class MyUser {

    private int userid;
    private String loginname;
    private String passwd;

    public MyUser() {
    }

    public MyUser(int userid, String loginname, String passwd) {
        this.userid = userid;
        this.loginname = loginname;
        this.passwd = passwd;
    }

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getLoginname() {
        return loginname;
    }

    public void setLoginname(String loginname) {
        this.loginname = loginname;
    }

    public String getPasswd() {
        return passwd;
    }

    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

    @Override
    public String toString() {
        return "MyUser{" +
                "userid='" + userid + '\'' +
                ", loginname='" + loginname + '\'' +
                ", passwd='" + passwd + '\'' +
                '}';
    }
}
~~~
dao文件夹下的MyUser.xml
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="myuser">
    <select id="selectOne" parameterType="int" resultType="com.iweb.model.MyUser">
 select * from myuser where userid = #{userid}
 </select>
    <select id="selectList" resultType="com.iweb.model.MyUser">
        select * from myuser
    </select>
    <select id="selectList2" resultType="java.util.Map">
        select f.fictionid,f.fictionname,f.author,c.categoryname from category c,fiction f
where f.categoryid = c.categoryid
    </select>

<!--手动映射-->
    <resultMap id="myorm" type="com.iweb.model.MyUser">
        <result property="userid" column="id"></result>
        <result property="loginname" column="username"></result>
        <result property="passwd" column="password"></result>
    </resultMap>
    <select id="selectList3" resultMap="myorm">
        select * from my_user
    </select>


</mapper>
~~~

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：测试类
 */

public class HelloMyBatis {
    public static void main(String[] args) {
        InputStream inputStream = null;
        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //MyBatis的二级缓存
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //生产MyBatis一级缓存
        SqlSession sqlSession = sqlSessionFactory.openSession();
        MyUser myUser1 = sqlSession.selectOne("myuser.selectOne", 1);
        MyUser myUser2 = sqlSession.selectOne("myuser.selectOne", 2);
        System.out.println(myUser1);
        System.out.println(myUser2);
        System.out.println("---------------------------------------------");

        List<MyUser> users = sqlSession.selectList("myuser.selectList");
        System.out.println(users);
        System.out.println("---------------------------------------------");

        List<Map<String, Object>> list = sqlSession.selectList("myuser.selectList2");
        System.out.println(list);

        System.out.println("手动映射---------------------------------------------");
        List<MyUser> users3 = sqlSession.selectList("myuser.selectList3");
        System.out.println(users3);



    }
}
~~~


## 增删改
新增需要使用`<insert>`标签来编写insert into 语句
可以传入对象作为参数 在语句中使用#{成员对象} 获取对象中的属性值
调用sqlSession的insert()方法完成对`<insert>`标签中的语句的调用
**注意**：增删改操作需要提交事物，使用sqlSession对象.commit()方法来提交

MyUser.xml
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="myuser">
    <insert id="saveOne" parameterType="com.iweb.model.MyUser">
        insert into myuser(userid,loginname,passwd) values(null,#{loginname},#{passwd})
    </insert>
</mapper>
~~~
测试类
~~~java
 /**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：
 */

public class HelloMyBatis {
    public static void main(String[] args) {
        InputStream inputStream = null;
        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //MyBatis的二级缓存
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //生产MyBatis一级缓存
        SqlSession sqlSession = sqlSessionFactory.openSession();


        System.out.println("---------------------------------------------");
        MyUser myUser = new MyUser(0, "zhangsan", "123456");
        sqlSession.insert("myuser.saveOne", myUser);
        System.out.println("插入成功");
        sqlSession.commit();//提交事务

    }
}
~~~

**注意** ：在没有ORM的时候，我们可以使用map传值给sql语句，在sql中，接收参数的格式：#{map中的键}
~~~java
package com.iweb.test1;

import com.iweb.model.MyUser;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：
 */

public class HelloMyBatis {
    public static void main(String[] args) {
        InputStream inputStream = null;
        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //MyBatis的二级缓存
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //生产MyBatis一级缓存
        SqlSession sqlSession = sqlSessionFactory.openSession();

        String username = "lisi";
        String password = "123456";
        Map<String,Object> map = new HashMap();
        map.put("username",username);
        map.put("password",password);
        sqlSession.insert("myuser.saveOne2",map);
        System.out.println("插入成功");
        sqlSession.commit();


    }
}
~~~

~~~xml
    <insert id="saveOne2" parameterType="java.util.Map">
                insert into myuser(userid,loginname,passwd) values(null,#{username},#{password})
    </insert>
~~~

修改的sql语句标签是` <update>`方法是 update

删除的sql语句标签是`<delete>`方法是delete

无论是增删改，传参都可以是对象，Map或者其他类型

## MyBatis面向接口进行编程

1. 我们定义Dao的接口，我们提供sql配置文件，接口名，配置文件名保持一致，配置文件中的namespace和接口的全类名保持一致
2. 接口中自定义一些方法，配置文件中的增删改查标签id值和方法名一致
3. 我们使用SqlSession对象调用getMapper(接口名.class)来获取接口实现类的对象，当我们调用接口中的方法时，将自动执行对应的sql语句

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：dao接口
 */

public interface UserDao {

    public void saveOne(MyUser myUser);

    public List<MyUser> selectAll();

    public MyUser selectById(int userid);

    public void updateOne(MyUser myUser);

    public void deleteById(int userid);
}
~~~

UserDao.xml
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.UserDao">

    <insert id="saveOne" parameterType="com.iweb.model.MyUser">
        insert into myuser(userid,loginname,passwd) values(null,#{loginname},#{passwd})
    </insert>


    <select id="selectAll" resultType="com.iweb.model.MyUser">
        select * from myuser
    </select>


    <select id="selectById" parameterType="int" resultType="com.iweb.model.MyUser">
 select * from myuser where userid = #{userid}
 </select>

    <update id="updateOne" parameterType="com.iweb.model.MyUser">
    update myuser set loginname = #{loginname},passwd = #{passwd} where userid = #{userid}
</update>

    <delete id="deleteById" parameterType="java.lang.Integer">
        delete from myuser where userid = #{userid}
    </delete>


</mapper>

~~~

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：测试类
 */

public class Test2 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //MyBatis的二级缓存
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //生产MyBatis一级缓存
        SqlSession sqlSession = sqlSessionFactory.openSession();


        UserDao userDao = sqlSession.getMapper(UserDao.class);

        System.out.println("插入数据--------------------------------------");
        MyUser myUser1 = new MyUser(0, "云胡不归", "121212");
        userDao.saveOne(myUser1);
        System.out.println("数据插入成功");


        System.out.println("查询全部--------------------------------------");
        List<MyUser> myUsers = userDao.selectAll();
        System.out.println(myUsers);


        System.out.println("按照id查询--------------------------------------");
        int userid = 10;
        MyUser myUser2 = userDao.selectById(userid);
        System.out.println(myUser2);


        System.out.println("修改一条记录--------------------------------------");
        MyUser myUser3 = new MyUser(10, "HeartWardrum", "3232323");
        userDao.updateOne(myUser3);
        System.out.println("修改成功");


        System.out.println("按照id删除数据--------------------------------------");
        int userid2 = 11;
        userDao.deleteById(userid2);
        System.out.println("删除完成！");


        sqlSession.commit();

    }
}
~~~


mybatis-config.xml
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.77.100:3306/mysql"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="com/iweb/dao/MyUser.xml"/>
        <mapper resource="com/iweb/dao/UserDao.xml"/> <!--新建的xml文件要在这里添加映射-->
    </mappers>
</configuration>
~~~

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：模型类
 */

public class MyUser {

    private int userid;
    private String loginname;
    private String passwd;

    public MyUser() {
    }

    public MyUser(int userid, String loginname, String passwd) {
        this.userid = userid;
        this.loginname = loginname;
        this.passwd = passwd;
    }

    public int getUserid() {
        return userid;
    }

    public void setUserid(int userid) {
        this.userid = userid;
    }

    public String getLoginname() {
        return loginname;
    }

    public void setLoginname(String loginname) {
        this.loginname = loginname;
    }

    public String getPasswd() {
        return passwd;
    }

    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

    @Override
    public String toString() {
        return "MyUser{" +
                "userid='" + userid + '\'' +
                ", loginname='" + loginname + '\'' +
                ", passwd='" + passwd + '\'' +
                '}';
    }
}

~~~

## MyBatis的动态sql

在sql语句中，我们可以使用`<if test="表达式">`来判断它是否成立，如果成立，会自动执行`<if>`标签中的代码，否则就不会拼上该代码
表达式中的值来源于传入的参数，可以是一个对象中的属性，或者是Map中的键值对
~~~xml
    <select id="selectByParam" parameterType="java.util.Map" resultType="com.iweb.model.MyUser">
        select * from myuser where 1=1
        <if test="userid!=null">
            and userid = #{userid}
        </if>
        <if test="loginname!=null">
            and loginname = #{loginname}
        </if>
        <if test="passwd!=null">
            and passwd = #{passwd}
        </if>
    </select>
~~~
~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：
 */

public interface UserDao {

    public List<MyUser> selectByParam(Map<String,Object> map);
}
~~~
~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：测试类
 */

public class Test2 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //MyBatis的二级缓存
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //生产MyBatis一级缓存
        SqlSession sqlSession = sqlSessionFactory.openSession();


        UserDao userDao = sqlSession.getMapper(UserDao.class);

        Map<String, Object> map = new HashMap<String, Object>();
        map.put("passwd", "123456");
        List<MyUser> users = userDao.selectByParam(map);
        System.out.println(users);

        sqlSession.commit();

    }
}
~~~

## MyBatis的级联查询
查询主表的时候，如果需要带出从表信息，那么在主表的resultMap中使用`<association>`关联查询从表的sql语句 
property属性表示成员变量名
column属性表示关联字段
select属性表示从表的sql语句
javaType属性表示从表sql语句的返回类型

~~~java
/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-19/0019
 * 描述：dao文件夹下
 */

public interface CardDao {

    //根据身份证的id查询身份证信息
    public Card queryCardById(String cardid);
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.CardDao">

    <!-- 根据身份证的id查询身份证信息 -->
    <select id="queryCardById" parameterType="java.lang.String" resultType="com.iweb.model.Card">
        select cardid,address,pname,date_format(starttime,'%Y-%m-%d') starttime from card where cardid = #{cardid}
    </select>

</mapper>
~~~
~~~java
package com.iweb.dao;

import com.iweb.model.Person;

import java.util.List;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-19/0019
 * 描述：dao文件夹下
 */

public interface PersonDao {
    //根据id查询人员信息，以及它的身份证信息
    public Person queryPersonById(String pid);
    
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.PersonDao">

    <select id="queryPersonById" parameterType="java.lang.String" resultMap="myresult">
    select * from person where pid = #{pid}
</select>

    <resultMap id="myresult" type="com.iweb.model.Person">
        <result property="pid" column="pid"></result>
        <result property="pname" column="pname"></result>
        <result property="age" column="age"></result>
        <result property="gender" column="gender"></result>
        <association property="card" column="cardid" select="com.iweb.dao.CardDao.queryCardById"
                     javaType="com.iweb.model.Card"></association>
    </resultMap>

</mapper>
~~~
~~~java
package com.iweb.model;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-19/0019
 * 描述：model文件夹下
 */

public class Card {
    private String cardid;
    private String address;
    private String pname;
    private String starttime;

    @Override
    public String toString() {
        return "Card{" +
                "cardid='" + cardid + '\'' +
                ", address='" + address + '\'' +
                ", pname='" + pname + '\'' +
                ", starttime='" + starttime + '\'' +
                '}';
    }

    public Card(String cardid, String address, String pname, String starttime) {
        this.cardid = cardid;
        this.address = address;
        this.pname = pname;
        this.starttime = starttime;
    }


    public Card() {
    }


    public String getCardid() {
        return cardid;
    }

    public void setCardid(String cardid) {
        this.cardid = cardid;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public String getStarttime() {
        return starttime;
    }

    public void setStarttime(String starttime) {
        this.starttime = starttime;
    }
}
~~~
~~~java
package com.iweb.model;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-19/0019
 * 描述：model文件夹下
 */

public class Person {

    private String pid;
    private String pname;
    private int age;
    private String gender;
    private Card card;


    @Override
    public String toString() {
        return "Person{" +
                "pid='" + pid + '\'' +
                ", pname='" + pname + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                ", card=" + card +
                '}';
    }

    public Person() {
    }

    public Person(String pid, String pname, int age, String gender, Card card) {
        this.pid = pid;
        this.pname = pname;
        this.age = age;
        this.gender = gender;
        this.card = card;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Card getCard() {
        return card;
    }

    public void setCard(Card card) {
        this.card = card;
    }
}
~~~
~~~java
package com.iweb.test1;

import com.iweb.dao.PersonDao;
import com.iweb.dao.UserDao;
import com.iweb.model.MyUser;
import com.iweb.model.Person;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @Author HearWardrum
 * 联系方式：tianxiayifan@qq.com
 * @Date 2022-08-18/0018
 * 描述：测试类
 */

public class Test2 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        } catch (IOException e) {
            e.printStackTrace();
        }
        //MyBatis的二级缓存
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //生产MyBatis一级缓存
        SqlSession sqlSession = sqlSessionFactory.openSession();


        UserDao userDao = sqlSession.getMapper(UserDao.class);


        PersonDao pd = sqlSession.getMapper(PersonDao.class);
        Person p = pd.queryPersonById("p001");
        System.out.println(p);

    }
}
~~~

~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.77.100:3306/mysql"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="com/iweb/dao/MyUser.xml"/>
        <mapper resource="com/iweb/dao/UserDao.xml"/>
        <!-- 新添加 -->
        <mapper resource="com/iweb/dao/PersonDao.xml"/>
        <mapper resource="com/iweb/dao/CardDao.xml"/>
    </mappers>
</configuration>
~~~



如果需要查询当前业务中关联的其他模块的多条记录
那么在resultMap中使用`<collection>`关联对方的sql语句
property属性表示成员变量名
column属性表示关联字段
select属性表示从表的sql语句
javaType属性表示一个集合list
offType属性表示集合中的泛型


## 监听器Listener

它监听着request，session，application域对象什么时候被创建，什么时候被销毁

ServletContextListener接口 ---- 表示application对象的监听器，
当web应用启动的时候创建 application对象，自动调用该接口实现类中重写的contextInitialized()
当web应用关闭的时候，销毁application对象，自动调用该接口实现类中重写的contextDestoryed()

**注意**：在创建监听器的时候，web.xml中需要配置<listener>标签，里面包含<listener_class>子标签，指向监听器类

~~~java
public class HelloListener implements ServletContextListener {


    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        //初始化
        System.out.println("创建了一个Application对象");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        //销毁
        System.out.println("销毁了一个Application对象");
    }
}
~~~
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <listener>
        <listener-class>com.iweb.test.HelloListener</listener-class>
    </listener>

</web-app>
~~~



ServletRequestListener接口 ---- 表示request对象的监听器，当一个请求创建的时候，创建request对象，自动调用该接口实现类中重写的requestInitialized()
当请求结束的时候，销毁request对象，自动调用该接口实现类中重写的requestDestoryed()
~~~java
public class HelloListener implements ServletContextListener, ServletRequestListener {


    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        //初始化
        System.out.println("创建了一个Application对象");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        //销毁
        System.out.println("销毁了一个Application对象");
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        System.out.println("创建了一个请求");
    }

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        System.out.println("销毁了一个请求");
    }
}
~~~

HttpSessionListener接口 ---- 表示session对象的监听器，当一个会话创建的时候，创建session对象，自动调用该接口实现类中重写的sessionCreated()
当会话结束的时候，销毁session对象，自动调用该节后实现类中重写的sessionDestroyed()
~~~java
public class HelloListener implements ServletContextListener, ServletRequestListener, HttpSessionListener {


    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        //初始化
        System.out.println("创建了一个Application对象");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        //销毁
        System.out.println("销毁了一个Application对象");
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        System.out.println("创建了一个请求");
    }

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        System.out.println("销毁了一个请求");
    }


    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        System.out.println("创建了一个会话");
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        System.out.println("销毁了一个会话");
    }
}
~~~
**注意**：当关闭浏览器时，会话不会立即销毁，而是等到有效期结束才会销毁
如果在jsp页面调用session.invalidate()可以立即销毁session
我们可以调用session.setMaxInactiveInterval(秒数);来手动改变会话的有效期


## 多模块的Maven项目
为了更好地实现解耦和优化性能，我们可以在Maven下创建多个模块，每个模块可以独立运行，他们之间还可以相互依赖
各个模块有自己独立的坐标和pom.xml文件
在pom.xml中
   ` <packaging>pom</packaging>`表示当前为父工程
~~~xml
<modules>
	<module>maven-a</module>
	<module>maven-b</module>
</modules>
表示包含那些子模块
~~~
~~~xml
    <parent>
        <artifactId>test20220902框架</artifactId>
        <groupId>com.iweb</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
	表示当前模块的父工程坐标 
~~~

**注意**：在多模块项目中，依赖具有传递性

maven-a的pom.xml

~~~xml
    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
    </dependencies>
~~~

maven-b的pom.xml中

~~~xml
    <dependencies>
        <dependency>
            <groupId>com.iweb</groupId>
            <artifactId>maven-a</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
~~~

maven-b依赖maven-a maven-a依赖jstl  ===》 maven-b也依赖jstl

**注意**：在依赖的模块中使用<exclusions>来指定若干<exclusion>，每一个<exclusion>表示排除所依赖的模块中的jar包

## 父工程对版本号统一管理

在父工程的pom.xml中，我们使用<dependencyManagement>来管理其中所有子模块的依赖版本，它并不下载，仅仅用来统一坐标中的版本号

~~~xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>
    </dependencies>
</dependencyManagement>
~~~

# spring

这是一个框架，一个IOC框架，一个AOP框架

IOC(翻转控制，也称为依赖注入) ---- 原本对象是由我们自己调用构造方法，现在由spring推送给我们

AOP(面向切面的编程) ---- 将项目中每个模块都要用到的与业务逻辑无关的代码抽取出来，做成横切面，切入每个模块

## 搭建spring框架的步骤：

1. 下载spring的基础jar包：
   1. spring-core
   2. spring-beans
   3. spring-context
2. 配置spring容器:
   1.  我们在<beans>中添加<bean>,每个<bean>表示以一个对象
   2. 在<bean>中包含id属性，还有class属性指向全类名
   3. 在<bean>中包含<property>表示对象的属性，name表示属性名，value表示属性值
3. 使用ApplicationContext对象调用getBean(id值)获取对象



在spring容器加载的过程中，就已经调用构造方法将对象全部创建，并调用set方法给对象赋值

在spring容器中,<property>中的name属性对应java类中的set方法的方法名去掉set，剩下的部分首字母转小写

我们可以使用ApplicationContext对象调用getBean(类名.class)获取spring容器中该类的唯一对象

当某个<bean>对象的某个属性值是另外一个bean对象时，我们在<property>中不能使用value赋值，而应该使用ref来引入另外那个<bean>的id进行赋值

我们在spring容器中，可以使用有参的构造方法创建对象并赋属性值
在<bean>中使用<constructor-arg>表示构造方法的参数，name表示方法的参数名,value表示方法的参数值

## 扫描器
使用扫描器自动创建对象
1. 去spring.io 网站 打开projects - spring Framwork - Learn - 某个版本的文档 - Data Access 中搜索到的xmlns:contxt的命名空间和验证文件，将其拷贝到自己的spring容器中
2. 使用<context:component-scan>来对指定的包进行扫描，base-package属性指向包名
3. 在该包中，需要创建对象的类，添加@Component注解 那么spring默认调用无参的构造方法创建该单例对象。我们自己手动赋属性值完成对象的获取


spring可以对工厂类进行管理
我们在spring容器中，使用<bean>class指向工厂类，factory-method属性指向工厂方法
<constructor-arg>的name属性指向工厂方法的参数名，value指向参数值
当我们使用spring获取对象时，就可以获取工厂所创建的产品对象

spring可以对实例工厂模式进行管理
我们在spring容器中，使用<bean>class指向工厂类，再创建一个<bean>factory-bean指向工厂的<bean>id值 factory-method属性指向工厂方法
<constructor-arg>的那么属性指向工厂方法的参数名，value指向参数值
当我们使用spring获取对象时，就可以获取实例工厂所常见的产品对象

使用spring提供的FactoryBean接口来完成工厂模式
步骤：
1. 讲工厂类实现FactoryBean接口并重写其中的getObject()用来返回产品对象  重写其中的getObjectType()返回产品的类型 重写isSingleton()返回产品对象是否单例
2. 配置spring容器，添加一个<bean>指向该工厂类即可

### 搭建AOP环境的步骤：
1. 提供纯净版的业务逻辑类
2. 再pom.xml中添加spring-aop和spring-aspects依赖
3. 在spring容器中添加aop的命名空间和验证文件
4. 在spring容器中添加<aop:config>其中包括<aop:pointcut>表示切点，其中的expression用来描述切点表达式
5. 提供前置通知的类，实现MethodBeforeAdvice接口重写before方法，spring传入的Method就是当前正在执行的方法，Object[]就是当前方法的参数数组
6. 在spring容器中编写一个<bean>


