瀑布模型：

- 需求规格说明书
- 概要设计（包括数据库设计）
- 详细设计（伪代码之类的）
- 编码
- 测试

----------------------

小厂一般使用敏捷开发



2023年7月3日

# 数据库

设计基本步骤：

>1. 找名词
>2. 把名词分两类（实体，属性）
>3. 一个实体一张表
>     一个属性一个字段
>4. 确定表和表之间的关系:
>   - 1对1：主表中添加从表的编号作为关联字段
>   - 1对多：在多的一端中添加1的一端的编号作为关联字段
>   - 多对多：再添加一张关系表用来记录两边的编号

### **ER图**：

### 辅助我们进行数据库表结构设计的工具

在ER图中

> 矩形：实体
> 椭圆：属性
> 菱形：关系

![ER图](https://res.cloudinary.com/dvqgs9esp/image/upload/v1688353564/ER图_q01tnx.png)

### 范式：

### ————判断数据库中某张表设计的好坏的规范

> 1. 第一范式：列不可分（每一个字段都是不可再分的最小原子单位）
> 2. 第二范式：要有主键，不存在部分依赖
>    （主键：某个字段非空唯一）
>    （联合主键：多个字段的组合作为主键）
>    （所有非主键字段必须完全依赖联合主键）
> 3. 第三范式：不存在传递依赖
>    （所有非主键字段必须直接依赖主键）

## Oracle

sql	---- 标准的查询语言
DDL ---- 数据定义语言：针对数据库对象操作的
DML ---- 数据操纵语言：针对数据操作的

~~~sql
-- 查询服务器时间
select sysdate from dual;
~~~

关于dual：

1. dual不是缩写词，本身就是完整的单词
2. Oracle中的dual表是一个单行单列的虚拟表
3. Dual表是oracle与数据字典一起创建的一个表，这个表只有1列：DUMMY，数据类型为VERCHAR2(1)，dual表中只有一个数据：‘X’，Oracle有内部逻辑保证dual表中永远只有一条数据。
4. Dual表主要用来选择系统变量或求一个简单的例子：
   SELECT sysdate FROM daul
   而Oracle的SELECT语法限制为：
   SELECT * FROM table
   所以，没有表名就没有办法查询，而时间日期并不存放在任何表中，于是这个dual虚拟表的概念就被引入了。
5. dual表的用途：
   dual是Oracle中的一个实际存在的表，任何用户均可读取，常用在没有目标表的SELECT语句块中

### 创建一张表：

~~~sql
CREATE TABLE 表名(
字段1 类型，
字段2 类型，
    ...
)
~~~

例如：
~~~sql
CREATE TABLE comifo20230703(
pno VARCHAR2(32),
pname VARCHAR2(32),
gender VARCHAR2(6),
birthday DATE,
phone NUMBER(32)
);
~~~

### 事务

数据库中保证数据准确性，完整性，一致性和原子性的一种机制，当我们增删改数据后，需要提交事务，事务不仅可以被提交，还可以被回滚。

### 修改一张表

1. 添加字段：

~~~sql
ALTER TABLE 表名 ADD(
字段名 类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 ADD(
qq number(32)
);
~~~

2. 修改字段名

~~~sql
ALTER TABLE 表名 RENAME 旧字段名 TO 新字段名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME COLUMN qq TO wechat;
~~~

3. 修改字段类型

~~~sql
ALTER TABLE 表名 MODIFY(
字段名 新类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 MODIFY(
wechat varchar2(32)
);
~~~

4. 删除字段

~~~sql
ALTER TABLE 表名 DROP(字段名);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 DROP(wechat);
~~~

5.修改表名

~~~sql
ALTER TABLE 旧表名 RENAME TO 新表名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME to comifo0703;
~~~

### 删除一张表

~~~sql
DROP TABLE 表名;
~~~

例如：

~~~sql
DROP TABLE comifo0703;
~~~

### 插入一条记录

~~~sql
INSERT INTO 表名(字段1,字段2,...)
VALUES('值1','值2',...);
~~~

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname, phone)
VALUES
  ('1001', '张三', '18112923121');
~~~

语句执行完成后要手动提交事务

注意：当对表中所有字段插入数据时，values前面的小括号可以省略



### 字符串转日期函数

to_date(日期字符串，日期格式)

注意：在格式中，y表示年，m表示月，d表示日，hh表示12小时制，hh24表示24小时制，mi表示分钟，ss表示秒。

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname,gender,birthday, phone) 
VALUES
  ('1002', '李四','男',to_date('2001-06-15','yyyy-mm-dd'),'13944572390');
~~~

~~~sql
INSERT INTO comifo703
  (pno, pname, gender, birthday, phone)
VALUES
  ('1004',
   '荀一',
   '男',
   TO_DATE('2000-07-31 13：23：32', 'yyyy-mm-dd hh24:mi:ss'),
   '1391221390');
~~~



### 修改字段

~~~sql
UPDATE 表名 SET 字段名 = 字段值 WHERE　条件语句; 
~~~

例如：

~~~sql
UPDATE comifo703 SET phone = '5542278383' WHERE pno = '1002';
~~~

### 删除语句

~~~sql
DELETE FROM 表名 WHERE 条件语句;
~~~

例如：

~~~sql
DELETE FROM comifo703 WHERE pno = '1001';
~~~

### 查询语句

~~~sql
SELECT 字段1,字段2,... FROM 表名 WHERE 条件;
~~~

例如：

~~~sql
 SELECT pno,pname,phone FROM comifo703 WHERE pno = '1002';
~~~

### 日期型转字符串型

to_char()

例如：

~~~sql
SELECT pno, pname, to_char(birthday, 'yyyy-mm-dd'), phone
  FROM comifo703
 WHERE pno = '1002';
~~~

### 约束

1.非空 ---- NOT NULL

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL	-- 非空
);
~~~

2.唯一 ---- UNIQUE

注意：如果非空并且唯一，那么UNIQUE需要单独编写：
~~~sql
CONSTRAINT 约束名 UNIQUE(字段)
~~~

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL,
CONSTRAINT uk703 UNIQUE(phone) -- 唯一
);
~~~

注意：小括号中如果有多个字段，则表示他们的组合不能重复。此外，如果要为组合添加约束，则必须使用constraint语句，而不能将unique挂在字段类型的后面

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

3.主键约束 ---- PRIMARY KEY

自带非空唯一的功能

例如：

~~~sql
DROP TABLE comifo703;

CREATE TABLE comifo703(
pno varchar2(32) PRIMARY KEY, -- 主键约束
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

主键约束也可以使用constraint编写
constraint 约束名 primary key(字段)

注意：小括号内如果有多个字段，则表示他们是联合主键。
例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname),
constraint pk703 primary key(pno,pname) -- 联合主键
);
~~~

# 2023年7月4日

### 外键

将某张表中的主键字段添加到另一张表中作为关联字段，那么该字段称为外键

外键约束两层含义：

1、当添加子表数据时，外键值必须是主表主键中已存在的值。
2、当删除父表数据时，主键值必须没有被子表关联使用。

例如：

~~~sql
create table class0704(
cno varchar2(32) primary key,
cname varchar2(32),
ccount number (10)
);

select * from class0704;

insert into class0704 
values
(1001,'A班',32);

create table student0704(
sno varchar2(32) primary key,
sname varchar2(32),
sage number(10),
cno varchar2(32) references class0704(cno) -- 外键
);

select * from student0704;

insert into student0704 
values 
(201801,'李四',12,1001); -- 插入的班级必须是已存在的
~~~

### 别名

我们在sql语句中可以给表或者字段起别名，方便我们带出字段名和展示结果集的表头

例如：

~~~sql
select t.tno 编号,t.tname 姓名, t.tsex 性别, t.tage 年龄 from teacher t;
-- 或
select t.tno as 编号,t.tname as 姓名, t.tsex as 性别, t.tage 年龄 from teacher as t;
-- 建议加as(2023.7.16修正：给表名起别名不能加as)
~~~

### 排重

在select子句部分的字段名前面添加distinct

### 排序

在查询语句最后添加order by子句，用来排序，格式：

~~~sql
order by 字段名 asc/desc
-- desc表示降序，asc表示升序，asc可以省略
~~~

例如：

~~~sql
select distinct t.tno, t.tname from teacher t order by t.tno desc;
~~~

```sql
select distinct t.tno, t.tname, t.tsex
  from teacher t
 order by t.tsex, t.tname, t.tno desc;
```

注意：汉字的大小顺序是unicode编码中的先后顺序

按照薪水高低查询所有男教师信息：

```sql
select * from teacher t where t.tsex = '男' order by t.sal desc;
```

### 常用的比较运算符

```sql
> 大于
>= 
<
<=
!=   -- 只在Oracle数据库中有效
<>
=
between 上限a and 下限b  -- 在[a,b]范围内
is null
is not null
```

### 多条件查询

and ---- 并且
or ---- 或者

```sql
select *
  from teacher t
 where t.tage > 45
   and t.tsex = '男';

select *
  from teacher t
 where t.birplace = '江苏'
    or t.birplace = '浙江';
    
    -- 注意多种逻辑运算符共存的时候，建议使用小括号把先算的部分括起来。
    -- 查询所有女教师和薪水大于9000的男教师
 select *
  from teacher t
 where t.tsex = '女'
    or (t.tsex = '男' and t.sal > 9000);
```

### in 和 not in

in  在指定的范围内筛选

not in  在指定范围以外筛选

格式：`in (值1,值2)`

例如：

```sql
select * from teacher t where t.birplace not in ('北京', '上海', '江苏');
```

### like

模糊查询

格式：

```sql
-- 全匹配 '%关键字%'
select * from teacher t where t.birplace like '%江%';
-- 左匹配 '关键字%'
-- 右匹配 '%关键字'
```

### 聚合分析函数

avg(字段) ---- 求平均值

sum(字段) ---- 求和

max(字段) ---- 求最大值

min(字段) ---- 求最小值

count(字段) ---- 计数

### 数值截取函数

round(数值，小数位) ---- 以四舍五入的方式截取数值

trunc(数值，小数位) ---- 以直接丢弃的方式截取数值

```sql
select round(avg(t.sal),2) 平均工资 from teacher t;
select trunc(avg(t.sal),2) 平均工资 from teacher t;
```

### 分组语句

group by

例如：

```sql
select trunc(avg(t.sal),2) ,t.tsex from teacher t
group by t.tsex;
```

注意：select后面只能添加group by的非函数字段，否则报错。

### having

如果需要在函数的结果上进行判断，不能使用where，只能使用having，having子句需要写在group by子句的后面。

例如：

```sql
select count(*), s.sex from student s group by s.sex having count(*) > 3;
```

```sql
-- 统计哪些籍贯不止一个老师
select count(*), t.birplace
  from teacher t
 group by t.birplace
having count(*) > 1;
```

### 子查询

一个查询语句的结果是另一个查询语句的条件，这样的select语句称为子查询语句

例如：

```sql
-- 查询和李树标同一系别的教师信息
select *
  from teacher t1
 where t1.dno = (select t.dno from teacher t where t.tname = '李树标')
   and t1.tname <> '李树标';
```

```sql
-- 统计学生表中系别和赵静想同，但是年龄比赵静大的同学的信息
select *
  from student s1
 where s1.dno = (select s.dno from student s where s.sname = '赵静')
   and s1.birthday <
       (select s2.birthday from student s2 where s2.sname = '赵静');
```

注意：如果子查询返回的结果集条数大于一条，那么外层查询只能使用in进行关联。

```sql
select *
  from student s1
 where s1.classid in
       (select s.classid
          from student s
         where s.birthday between to_date('1983-01-01', 'yyyy-mm-dd') and
               to_date('1984-12-31', 'yyyy-mm-dd'));
```



### for update

在select语句后面添加for update；可以实现图形化界面的增删改操作。

```sql
select * from student s for update;
```

### 多表关联

`select 字段 from 表1,表2,... where 关联条件`
注意：如果关联条件不够，则会出现笛卡尔乘积的问题
正确写法如下：

```sql
-- 统计每个教师的编号、姓名、系别名称
select t.tno, t.tname, d.dname
  from teacher t, department d
 where t.dno = d.dno;
```

注意：子查询也能实现多表关联

```sql
select t.tno, t.tname
  from teacher t
 where t.dno = (select d.dno from department d where d.dname = '计算机系')
```



### left join

左外关联
左边的表中所有记录全部展示，右边的表中的记录有则展示，无则留空。

格式：
`select 字段 from 左表 left join 右表 on 关联条件`

例如：

```sql
select * from teacher t left join department d on t.dno = d.dno;
```

注意：Oracle中的关联查询可以实现(+)的另一边全部展示

例如：

```sql
-- 和以上代码功能一样，
select * from teacher t ,department d where t.dno = d.dno(+);
```

### inner join

等于用等号进行两表关联，inner可以省略

例如：

```sql
select * from teacher t inner join department d on t.dno = d.dno;
```

### union

在两个select语句中实现并集，要求两个select语句字段类型和个数相同，union自带排重功能，union all 不会排重

例如：

```sql
-- 找出所有男老师和男学生的名字
select s.sname from student s where s.sex = '男'
union all
select t.tname from teacher t where t.tsex = '男';
```

```sql
-- 统计所有男学生选的课程名
-- 以及所有男老师教授的课程名
-- 以及所有课时>40的课程名
select c.cname from course c,student s,s_course sc
where c.cno = sc.cno and sc.sno = s.sno and s.sex = '男'
union 
select c1.cname from course c1, t_course tc,teacher t
where c1.cno = tc.cno and tc.tno = t.tno and t.tsex = '男'
union 
select c2.cname from course c2 where c2.ctime > 40;
```

### intersect

交集

```sql
-- 统计韩信和赵汗青选修了哪些相同的课程，展示课程名
select c.cname
  from course c, s_course sc, student s
 where c.cno = sc.cno
   and sc.sno = s.sno
   and s.sname = '韩信'
intersect
select c1.cname
  from course c1, s_course sc1, student s1
 where c1.cno = sc1.cno
   and sc1.sno = s1.sno
   and s1.sname = '赵汗青';
```

### minus

差集

由生日计算年龄

```sql
select s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age -- 由生日计算年龄
  from student s
 where s.sno in (select sc.sno from s_course sc where sc.mark < 60);

```

```sql
-- 查询不存在挂科人的信息
select distinct s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s,s_course sc
 where s.sno = sc.sno and  s.sno not in (
 select sc.sno from s_course sc where sc.mark < 60 
 );
 
 -- 另一种思路，把最低分大于等于六十的查出来
 select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in ( select sc.sno
                   from s_course sc
                  group by sc.sno
                 having min(sc.mark) >= 60);
```

```sql
-- 查询至少有2门成绩在65以上的同学的信息
select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in (
select sc.sno from s_course sc 
where sc.mark >=65 
group by sc.sno
having count(sc.sno)>=2);
```

练习：

```sql
 -- 对于emp中有管理者的员工，列出姓名，管理者姓名（MGR表示管理者）
 -- 实现了自己关联自己
 select e1.ename as 姓名,e2.ename as 管理者姓名
 from emp e1,emp e2
 where e1.mgr is not null and e1.mgr = e2.empno;
```

```sql
-- 查询同时选修java基础和高等数学两门课，的同学，
-- 并且他的java基础的分数要比高等数学的分数要高，
-- 展示这样的学生信息
select * from student s where s.sno in(
select sc1.sno from s_course sc1 ,s_course sc2 
where sc1.sno = sc2.sno    -- 同一个人
and sc1.cno = (            -- 这个人选修了java基础
select c.cno from course c where c.cname = 'java基础')
and sc2.cno = (            -- 这个人选修了高等数学
select c1.cno from course c1 where c1.cname = '高等数学')
and sc1.mark > sc2.mark    -- java基础分数比高等数学高
);

-- 用临时表改写
-- 造两张临时表
-- 一张表：展示所有选修java基础的同学的信息，以及java基础的分数
-- 另一张：展示所有选修高等数学的同学的信息，以及高等数学的分数
 with t1 as(select s.sno,s.sname ,s.sex,sc.mark  -- 这里不能将写成select * 的原因：如果使用select * 则t1表内有两列字段名都叫sno，在进行总查询的时候，t1.sno就无法确定是哪一列sno，产生未明确定义列错误
            from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = 'java基础'
 ),
 t2 as (select s.sno,s.sname ,s.sex,sc.mark 
        from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = '高等数学'
 )
 select t1.sno,t1.sex,t1.sname from t1,t2 where t1.sno = t2.sno and t1.mark > t2.mark;
```

# 2023年7月5日

### 临时表

它可以辅助我们编写select语句
把临时需要的一些数据先统计出来，形成临时表，执行完查询语句后，该临时表不会保存在数据库中。
格式：

```sql
with 表名1 as(select语句),
表名2 as(select语句)
总的查询语句
```

```sql
-- 查询所有偏科的同学
-- 偏科：
-- 个人总均分大于所有人所有课的总均分
-- 存在挂科
with t1 as
 (select sc.sno, avg(sc.mark) as peravg from s_course sc group by sc.sno)
select s.*
  from student s, s_course sc, t1
 where s.sno = sc.sno
   and s.sno = t1.sno
   and t1.peravg > (select avg(sc1.mark) from s_course sc1)
   and sc.mark < 60;

```

### substr

`substr(字符串,从第几位开始,截取几位)` ---- 从左往右截取字符串

例如：

```sql
select substr('this is a String',6,2) from dual; -- 结果为is
```

length(字符串) ---- 查询这个字符串的长度

从右往左截取方式：
`substr(字符串,-截取位数)` 
`substr(字符串,length(字符串)-截取位数+1,截取位数)`

### case语句

用来做分支判断，然后造一个字段

格式1：

```sql
case when 条件1 then 结果1
	when 条件2 then 结果2
	...
	else 结果n
	end as 别名
```

例如：

```sql
select sc.sno,
       sc.cno,
       sc.mark,
       case
         when sc.mark < 60 then
          '差'
         when sc.mark < 80 then
          '中'
         when sc.mark < 90 then
          '良'
         when sc.mark <= 100 then
          '优'
         else
          '其他'
       end as 等级
  from s_course sc;
```

格式2：

~~~plsql
case 字段名 when 值1 then 值2
			when 值1 then 值2
			...
			else 结果n
			end as 别名
~~~

例如：

~~~plsql
select s.sno,
       s.sname,
       case s.sex
         when '男' then
          'boy'
         when '女' then
          'girl'
         else
          'others'
       end as 性别
  from student s;
~~~

注意：格式2可以使用decode函数取代

`decode(字段,值1,结果1,值2,结果2,...)`

例如：

~~~plsql
select s.sno,
       s.sname,
       decode(s.sex, '男', 'boy', '女', 'girl', 'others') as 性别
  from student s;
~~~

#### 列转行

~~~plsql
  select t.student, 
  sum(case when t.course = '语文' then t.score else null end) as 语文,
  sum(case when t.course = '数学' then t.score else null end) as 数学,
  sum(case when t.course = '英语' then t.score else null end) as 英语,
  sum(case when t.course = '物理' then t.score else null end) as 物理
  from test t
  group by t.student;
~~~

~~~plsql
select student ,
sum(decode(course ,'语文',score)) as 语文,
sum(decode(course ,'数学',score)) as 数学,
sum(decode(course ,'英语',score)) as 英语,
sum(decode(course ,'物理',score)) as 物理
from test group by student;
~~~

最难的sql题（列转行）工作已完全够用，不用钻研更深

~~~plsql
/*2、按部门汇总emp表中五个职位的各自的薪资汇总以及部门汇总，例：

    DEPTNO  ANALYST CLERK MANAGER PRESIDENT SALESMAN  总和
    10      0       1300  2450    5000      0         8750
    20      6000    1900  2975    0         0         10875
    30      0       5950  2850    0         5600      14400
    总和    6000    9150  8275    5000      5600      34025*/
    with t1 as ( 
select 
      to_char(e.deptno)                    AS deptno  ,
      sum(case e.job when 'ANALYST' then sal else 0 end)   AS ANALYST,
      sum(case e.job when 'CLERK' then sal else 0 end)     AS  CLERK,
      sum(case e.job when 'MANAGER' then sal else 0 end)   AS MANAGER,
      sum(case e.job when 'PRESIDENT' then sal else 0 end) AS  PRESIDENT,
      sum(case e.job when 'SALESMAN' then sal else 0 end)  AS SALESMAN ,
      sum(e.sal) AS  总和
from  emp e 
group by e.deptno 
order by e.deptno
),
t2 AS (
select '总和', 
       sum(ANALYST), 
       sum(CLERK), 
       sum(MANAGER), 
       sum(PRESIDENT), 
       sum(SALESMAN) ,
       sum(总和) from t1 )
select * from t1 
union all 
select * from t2 ;
~~~

# 2023年7月6日

## 视图

存储下来的select 语句

创建视图：

~~~plsql
create or replace view 视图名 as 
select 语句;
~~~

查询视图：

~~~plsql
select 字段 from 视图名 ;
~~~

视图的好处：

1. 简化查询
2. 它可以和背后的基表同步(这一点体现了它和备份表的区别)
3. 它可以控制访问权限

视图在创建的时候，可以使用 as 字段别名 来重新定义视图中的字段名

视图的修改和新增是同一条语句：无则新增，有则替换

视图中的字段如果不是表中的原始字段（这样的视图称作复杂视图），则无法对该视图进行增删改操作
如果视图字段全是表中的字段（简单视图），它允许进行增删改操作，实际操作的是它背后的基表

一般不建议对视图进行增删改
在创建视图的语句最后添加 `with read only`可以屏蔽增删改操作
例如：

~~~plsql
create or replace view  emp070601 as 
select * from emp where deptno = 30
with read only;
~~~

所有的数据库的对象的删除都是drop语句

删除视图名：`drop view 视图名`

例如：

~~~plsql
drop view emp070601;
~~~

我们可以像创建视图那样去创建一张表，记录下查询语句中的结果集

格式：

~~~plsql
-- 创建备份表
create table 表名 as
select语句
~~~

## rownum 

行号

用来统计指定条数的记录

例如：

~~~plsql
select e.* ,rownum from emp e where rownum <= 10; -- 显示前十条记录
~~~

注意：rownum的条件过滤是针对原始数据，如果需要排序，那么得先用子查询来排序，在排序的结果集上加rownum

格式：

~~~plsql
select 字段 from (
	select 字段 from 表 where 条件 order by 排序字段 asc/desc
)
where rownum <= 数值
~~~

例如：

~~~plsql
 select * from ( select * from emp order by sal desc) where rownum <= 10; -- 工资最高的前十人
~~~

rownum的条件判断只支持`<`和`<=`，我们可以在当前结果集查询的时候给它起别名，相当于造了一个普通字段，这个普通字段支持各种比较运算符，然后再外层对别名进行条件判断。

例如：

~~~plsql
select *
  from (select a.*, rownum rn from (select * from emp order by sal desc) a 
        )  b
 where b.rn > 5
   and b.rn <= 10;
~~~

注意：在oracle中给表名起别名不能加as

## 分页查询

1. 每页条数是程序中写死的

2. 页数是前端传过来的

3. 分页公式（Oracle）： ---- 固定格式（重要！）
   ~~~plsql
   select * from (
   	select a.*,rownum rn from (
       	select * from 表名 order by 排序字段 desc) a ) b
       	where b.rn > 每页条数 * (页数 - 1) and b.rn <= 每页条数 * 页数;
   ~~~

## 序列

这是一种用来产生唯一数值的数据库对象

创建序列：

~~~plsql
create sequence 序列名
start with 起始值
increment by 递增值
maxvalue 最大值;
~~~

使用序列：

~~~plsql
序列名.nextval
~~~

查询当前值：

~~~plsql
序列名.currval
~~~

修改序列：

~~~plsql
alter sequence 序列名
increment by 递增值
maxvalue 最大值 ;
-- 注意：起始值不能修改
~~~

删除序列：

~~~plsql
drop sequence 序列名
~~~

例如：

~~~plsql
   -- 创建序列
   create sequence myseq0706
   start with 100
   increment by 1
   maxvalue 9999999999999999999999999999;
   -- 使用序列
   select myseq0706.nextval from dual;
   -- 查看序列进行到哪了  新序列创建后必须使用了一次才能查看，否则会出现序列尚未在此会话中定义的cuo'w
   select myseq0706.currval from dual;
~~~

## 索引

这是一种用来提高查询速度的数据库对象，它是添加在数据库表的某个字段上的，当以该字段作为查询条件，会提高查询速度

创建索引：

1. 自动创建 ---- 当表中字段是主键或者唯一约束时，该字段自带索引。
   ~~~~~plsql
   create table mytable0706(
   sno varchar2(32) primary key, -- 自带索引
   sname varchar2(32) ,
   sphone number unique 	-- 自带索引
   );
   ~~~~~

   

2. 手动添加 ---- create index 索引名 on 表名(字段名)
   ~~~~~plsql
   create index my_index0706 on mytable0706(sname);
   ~~~~~

索引的缺点：它会降低增删改的速度，因为在维护数据的同时，还需要花费额外的时间来维护数据上的索引，同时它还会占用资源空间

#### 面试题：

以下下情况不加索引：

1. 表中数据量不大的时候：少于几百万条
2. 该字段不经常被当作where条件
3. 该表中的数据经常被增删改
4. 该字段上的取值范围比较窄

删除索引：

`drop index 索引名`

## 同义词

保存下来的表或视图的别名

创建语法：

~~~plsql
create synonym 同义词名 for 表名或视图名
~~~

例如：

~~~plsql
create synonym s for student;

select * from s; -- 相当于 select * from student
~~~

删除：

~~~plsql
drop synonym  同义词名;
~~~

## PL/SQL语言

这是一门数据库开发语言，用来帮助我们对数据库进行各种复杂的操作

### PL/SQL语法结构：

~~~plsql
declare
声明部分
begin
程序体
exception
异常处理部分
end;
~~~

### 打印语句

~~~plsql
dbms_output.put_line(打印内容);
~~~

例如：

~~~plsql
begin 
  dbms_output.put_line('hello world');
end;
~~~

### 赋值语句

1、查询赋值：

~~~plsql
select 字段名 into 变量名 from 表 where 条件...
~~~

例如：

~~~plsql
declare 
  v_sal number(10,2);
begin
  select e.sal into v_sal from emp e where e.empno = '7369';
  dbms_output.put_line(v_sal);
end;
~~~

~~~plsql
declare
  v_sal number(10,2);
  v_eno number(4);
  v_ename varchar2(10);
  begin
    select e.empno,e.ename,e.sal
    into v_eno,v_ename,v_sal
    from emp e where e.empno = '7369';
    dbms_output.put_line(v_eno||','||v_ename||','||v_sal);
end;
-- 输出结果：7369,SMITH,800
~~~

### 表名.字段名%type

定义变量的时候，类型可以使用`表名.字段名%type`表示当前变量类型和该字段的类型保持一致

例如：

~~~plsql
declare
  v_sal number(10,2);
  v_eno number(4);
  v_ename emp.ename%type; -- 和表中字段类型保持一致
  begin
    select e.empno,e.ename,e.sal
    into v_eno,v_ename,v_sal
    from emp e where e.empno = '7369';
    dbms_output.put_line(v_eno||','||v_ename||','||v_sal);
end;
-- 结果和上面一致
~~~

### 记录

### 记录类型

将一组逻辑相关的变量整合到一块，做成一个类型，再由该类型定义一个变量，那么该变量就可以接收一组值，使用的时候，使用`变量名.属性`即可
定义格式：

~~~plsql
type 记录类型名 is record(
属性1 类型1,
属性2 类型2,
    ...
)
~~~

例如：

~~~plsql
declare 

type my_record is record(
v_eno emp.empno%type,
v_ename emp.ename%type,
v_sal emp.sal%type
);

v_emp my_record;

begin
  select e.empno,e.ename,e.sal
  into v_emp
  from emp e where e.empno = '7369';
  
  dbms_output.put_line(v_emp.v_eno||','||
  v_emp.v_ename||','||
  v_emp.v_sal);
end;

~~~

2、手动赋值：

~~~plsql
declare
v_temp number(10);
begin
  v_temp:=100;
  dbms_output.put_line(v_temp);
end;
~~~

### 变量名 表名%rowtype

定义变量可以声明位一张表中的整行类型

格式：

~~~plsql
变量名 表名%rowtype
~~~

赋值的时候可以将表中整行数据查询赋值给它，使用的时候： `变量名.字段`即可

例如：

~~~plsql
declare 
  v_emp emp%rowtype;
begin
  select * into v_emp from emp where empno = 7369;
  dbms_output.put_line(v_emp.empno||','||v_emp.ename||','||v_emp.sal);
end;
~~~

### commit

在增删改的时候用来提交事务

~~~plsql
declare
v_dname department.dname%type;
begin
  v_dname:='自动化';
  insert into department values (myseq0706.nextval,v_dname,30);
  commit;
end;
~~~

### if语句

格式：

~~~plsql
if 条件1 then
结果1
elsif 条件2 then
结果2
...
else
结果n
end if;
~~~

例如：

~~~plsql
declare
  v_emp   emp%rowtype;
  v_grade varchar2(20);
begin
  select * into v_emp from emp where empno = 7369;
  if v_emp.sal < 1000 then
    v_grade := '拖后腿';
  elsif v_emp.sal < 2000 then
    v_grade := '马马虎虎';
  else
    v_grade := '高薪';
  end if;
  dbms_output.put_line(v_emp.empno || ':' || v_emp.sal || ',' || v_grade);
end;
-- 7369:800,拖后腿
~~~

~~~plsql
-- case when 的写法
declare
  v_emp   emp%rowtype;
  v_grade varchar2(20);
begin
  select * into v_emp from emp where empno = 7369;
  v_grade := case trunc(v_emp.sal / 1000, 0)
               when 0 then
                '拖后腿'
               when 1 then
                '马马虎虎'
               else
                '高薪'
             end;
  dbms_output.put_line(v_emp.empno || ':' || v_emp.sal || ',' || v_grade);
end;

~~~



### 循环

循环四要素：

1. 初始化表达式
2. 布尔值测试表达式
3. 循环体
4. 更改表达式

#### loop循环

~~~plsql
初始化 
loop 
循环体
更改表达式
exit when 
end loop;
~~~

例如：

~~~plsql
-- 正序打印1——100
declare
  v_n number(4);
begin
  v_n := 1;
  loop
    dbms_output.put_line(v_n);
    v_n := v_n + 1;
    exit when v_n > 100;
  end loop;
end;
~~~

#### while 循环

~~~plsql
初始化
while 布尔值测试表达式 loop
循环体
更改表达式
end loop;
~~~

例如：

~~~plsql
declare
  v_n number(4);
begin
  v_n := 1;
  while v_n <= 100 loop
    dbms_output.put_line(v_n);
    v_n := v_n + 1;
  end loop;
end;
~~~

#### for循环

~~~plsql
for 变量 in 下限 .. 上限 loop
循环体
end loop;
end;
~~~

例如：

~~~plsql
declare
begin
  for v_n in 1 .. 100 loop
    dbms_output.put_line(v_n);
  end loop;
end;
~~~

### 游标

它是用来储存一组记录的集合，我们可以使用游标来逐条遍历查询结果集中的数据

在数据库中，游标（Cursor）是一个用于处理查询结果集的数据库对象。它提供了一种机制，可以逐行访问和操作查询结果集中的数据。

操作步骤：
1、定义游标：`cursor 游标名 is select语句`
2、打开游标： `open 游标名`
3、不停地提取游标中的下一条数据：`fetch 游标名 into 变量 ` 并通过 `%found ` 判断是否提到数据，如果提到数据则使用
4、关闭游标：`close 游标名`

~~~plsql
-- 原生态游标写法
declare
  v_ename emp.ename%type;
  v_sal   emp.sal%type;
  -- 定义游标
  cursor my_cur is
    select e.ename, e.sal from emp e;
begin
  -- 打开游标
  open my_cur;
  -- 提取第一条数据到变量中
  fetch my_cur
    into v_ename, v_sal;
  while my_cur%found loop
    dbms_output.put_line(v_ename || ',' || v_sal);
    -- 提取下一条数据到变量中
    fetch my_cur
      into v_ename, v_sal;
  end loop;
  -- 关闭游标
  close my_cur;
end;
~~~

#### 使用for循环操作游标

~~~plsql
for 变量名 in 游标名 loop 
使用 变量名.字段 来操作数据
end loop;
~~~

例如：

~~~plsql
declare
  --定义游标
  cursor my_cur is
    select e.ename, e.sal from emp e;
begin
  for c in my_cur loop
    dbms_output.put_line(c.ename || ',' || c.sal);
  end loop;
end;
~~~

综合题：

~~~plsql
--备份emp表
drop table my_emp;
create table my_emp as select * from emp;

-- 修改my_emp 给员工涨工资
-- <1000 up 20%
-- 1000-1900 up 15%
-- >= 2000 up 10%
declare
  cursor cur_emp is
    select * from my_emp;
  v_temp number(4, 2); -- 涨幅变量
begin
  for c in cur_emp loop
    if c.sal < 1000 then
      v_temp := 0.2;
    elsif c.sal < 2000 then
      v_temp := 0.15;
    else
      v_temp := 0.1;
    end if;
    update my_emp me
       set me.sal = me.sal * (1 + v_temp)
     where me.empno = c.empno;
  end loop;
  commit;
end;
-- 测试看看
select * from my_emp;
select * from emp;
~~~

# 2023年7月7日

## exception

当begin代码块报错的时候，就会跳转到exception代码块进行处理，

格式：

~~~plsql
exception
when 异常名 then 打印提示语句
~~~

### 预定义异常：

对于一些常见的异常，Oracle给它们定义好了异常名，我们直接使用

例如：

~~~plsql
declare
  v_emp emp%rowtype;
begin
  select * into v_emp from emp;
  dbms_output.put_line(v_emp.empno || ',' || v_emp.ename || ',' ||
                       v_emp.sal);
exception
  when TOO_MANY_ROWS then
    dbms_output.put_line('当前sql语句查询到多条数据，无法赋值给一个变量');
end;
~~~

### 非预定义异常

对于一些非常见异常，我们自己定义异常名，它的类型是exception，然后使用 `pragma exception_init(异常名,异常编号)`将该异常名和异常编号绑定。这时，就可以在exception中进行捕获和处理

例如：

~~~plsql
declare
  v_dno dept.deptno%type;
  v_exception_del exception;
  pragma exception_init(v_exception_del, -02292);
begin
  v_dno := 20;
  delete from dept where deptno = v_dno;
  dbms_output.put_line('部门号删除成功');
exception
  when v_exception_del then
    dbms_output.put_line('当前部门下还存在员工，无法删除部门！');
end;
~~~

### 自定义异常

这时我们业务逻辑中不符合某个要求而出现的异常，对于数据库来说没有问题。
我们只需要定义异常变量，然后在抛出的地方，使用 `raise 异常变量名`即可对其捕获和操作

~~~plsql
declare
  v_sal emp.sal%type;
  v_exception_sal exception;
begin
  select sal into v_sal from emp where empno = '7839';
  if v_sal > 4000 then
    raise v_exception_sal;
  else
    dbms_output.put_line(v_sal);
  end if;
exception
  when v_exception_sal then
    dbms_output.put_line('对不起，你吃得太多了，公司决定开除你');
end;
~~~

## 函数

function，我们将PL/SQL代码保存到函数中，可以用来被调用，函数必须有返回值

创建函数：

~~~plsql
create or replace function 函数名(参数列表)
return 返回值类型
is
声明部分
begin
程序体
exception 
异常处理
end;
~~~

注意：函数可以被select语句直接调用，也可以被PL/SQL代码调用

例如：

~~~plsql
-- 无参数版本
create or replace function myfun1 return varchar2 is
begin
  return 'hello world';
end;

-- 调用1
select myfun1 from dual;
-- 调用2
begin
dbms_output.put_line(myfun1);
end;
~~~

~~~plsql
-- 有参数版本
create or replace function myfun2(v_pra varchar2) return varchar2 is
begin
return 'hello:' || v_pra;
end;
-- 调用1
select myfun2('Tom') from dual;
-- 调用2
begin
dbms_output.put_line(myfun2('Tom'));
end;
~~~

~~~plsql
   -- 编写函数，输入一个部门编号，返回该部分薪资总和
  create or replace function myfunc4(v_deptno emp.deptno%type) return number is
    v_totalsal number(10,2);
  begin
    select sum(e.sal)
      into v_totalsal
      from emp e
     where e.deptno = v_deptno;
    return v_totalsal;
  end;
  
  select myfunc4(10) from dual;
~~~

## 存储过程

procedure, 我们将PL/SQL代码保存到存储过程中，可以用来调用，存储过程没有return语句，创建存储过程：

~~~plsql
create or replace procedure 存储过程名(参数列表)
is
声明部分
begin
程序体
exception
异常处理
end;
~~~

存储过程能被PL/SQL代码调用

~~~plsql
-- 创建存储过程：向dept表中插入数据
create or replace procedure mypro1(v_deptno dept.deptno%type,
                                   v_dname  dept.dname%type,
                                   v_loc    dept.loc%type) is
begin
  insert into dept values (v_deptno, v_dname, v_loc);
  commit;
end;
-- 使用存储过程
begin
mypro1(50, '开发部', '上海');
end;
~~~

~~~plsql
  -- 编写存储过程，输入一个部门编号，删除该部门
  -- 如果输入的部门编号不存在，则抛出自定义异常，提示部门号不存在
  -- 如果输入的部门编号被员工关联，则抛出非预定义异常，提示存在员工
  -- 如果可以正常删除，则打印“xxx删除成功”
  create or replace procedure del_dept(v_dno dept.deptno%type) is
    e_noresult   exception;
    e_contentemp exception;
    pragma exception_init(e_contentemp, -02292);
    v_count number;
  begin
    select count(*) into v_count from dept d where d.deptno = v_dno;
    if v_count > 0 then
      delete from dept where deptno = v_dno;
      dbms_output.put_line('已删除编号为' || v_dno || '的部门');
      commit;
    else
      raise e_noresult;
    end if;
  exception
    when e_noresult then
      dbms_output.put_line('对不起，该部门编号不存在');
    when e_contentemp then
      dbms_output.put_line('对不起，该部门存在员工，无法删除');
  end;
~~~

~~~plsql
-- 给my_emp 涨工资，1982年以前入职的，涨20%
-- 1982 - 1985年入职的 涨15%
-- 1985年以后入职的  涨10%


drop table my_emp;
create table my_emp as select * from emp;
-- 创建存储过程
create or replace procedure pro_emp is
v_up  number(4,2);  -- 工资涨幅
cursor my_cur is select *  from my_emp ;  
begin
  for c in my_cur loop
if c.hiredate < to_date('1982-01-01','yyyy-mm-dd') then
  v_up := 0.2;
  elsif c.hiredate < to_date('1986-01-01','yyyy-mm-dd') then 
    v_up := 0.15;
    else v_up := 0.1;
    end if;
    c.sal := c.sal * (1 + v_up);
    update my_emp me set me.sal = c.sal where me.empno = c.empno;
end loop;
commit;
end;
-- 运行存储过程
begin 
  pro_emp;
  end;

-- 查看结果
select * from my_emp;
~~~

### 存储过程的参数形式

1、in ---- 只能接收输入参数，它不能改变传入的值，也不能输出
2、默认  ---- 相当于 in
3、out ---- 不能接收输入的参数，可以改变值，并且输出返回
4、in out ---- 既能接收输入参数，又能改变值并且输出返回。

~~~plsql
create or replace procedure my_pro(v1 number,
                                   v2 in number,
                                   v3 out number,
                                   v4 in out number) is
begin
  dbms_output.put_line('v1:' || v1 || ',' || 'v2:' || v2 || ',' || 'v3:' || v3 || ',' ||
                       'v4:' || v4);
  -- v1 := 101;
  -- v2 := 201;
  v3 := 301;
  v4 := 401;
end;

declare v1_t number(10); v2_t number(10); v3_t number(10); v4_t number(10);
begin
v1_t := 100; v2_t := 200; v3_t := 300; v4_t := 400;

my_pro(v1_t, v2_t, v3_t, v4_t); dbms_output.put_line('v1:_t' || v1_t || ',' || 'v2_t:' || v2_t || ',' || 'v3_t:' || v3_t || ',' || 'v4_t:' || v4_t);
end;
-- 打印结果：
--v1:100,v2:200,v3:,v4:400
--v1:_t100,v2_t:200,v3_t:301,v4_t:401

~~~

注意：在函数和存储过程中，如果需要做模糊查询，那么左%和右%是单独拼写在条件字符串中的。

~~~plsql
create or replace procedure my_pro(likevalue varchar2) is cursor my_cur is
  select * from emp e where e.ename like '%' || likevalue || '%';
begin
  for c in my_cur loop
    dbms_output.put_line(c.empno || ',' || c.ename || ',' || c.sal);
  end loop;
end;

begin
  my_pro('A');
end;
~~~

## 删除函数和存储过程

~~~plsql
-- 删除函数
drop function 函数名;
drop procedure 存储过程名;
~~~

## trigger

触发器：它监控着数据库中的某张表上的数据的增删改操作，当发生指定的操作时，自动出发PL/SQL代码执行

语法：

~~~plsql
create or replace trigger 触发器名
before/after
insert/update/delete
on	表名
for each row
声明部分
begin
执行部分
end;
~~~

注意： for each row表示行级触发器，每更新一行触发一次，如果不写，，则是语句级触发器，每执行一条语句触发一次。

~~~plsql
create or replace trigger my_tri1
after
update 
on my_emp
for each row
  begin
    dbms_output.put_line('hello world');
    end;
~~~

`:old.字段名` ---- 在触发器中可以获取该字段增删改操作之前的值

~~~plsql
-- 创建备份表
create table my_emp_bak as select * from my_emp where 1=2; 

-- 实时对被删除的数据进行备份的触发器
create or replace trigger my_tri2
  before delete on my_emp
  for each row
begin
  insert into my_emp_bak
  values
    (:old.empno,
     :old.ename,
     :old.job,
     :old.mgr,
     :old.hiredate,
     :old.sal,
     :old.comm,
     :old.deptno);
end;


select * from my_emp;
select * from my_emp_bak;

delete from my_emp ; 
-- 当my_emp表中数据被删除时，会立刻往my_emp_bak中添加相同数据
~~~

## 键盘输入

~~~plsql
变量名 := '&变量名';
~~~

~~~plsql
declare
  v_1 number;
  v_2 varchar2(255);
begin
  v_1 := '&v_1';
  v_2 := '&dsfsdfsd'; -- '&后面随便写点啥都行
  dbms_output.put_line(v_1);
  dbms_output.put_line(v_2);
end;
~~~

## 对一张表的增删改查存储过程

~~~plsql
select * from dept;

create or replace procedure addOne(v_deptno dept.deptno%type,
                                   v_dname  dept.dname%type,
                                   v_loc    dept.loc%type) is
begin
  insert into dept values (v_deptno, v_dname, v_loc);
  commit;
end;

  create or replace procedure deleteOne(v_deptno dept.deptno%type) is
  begin
    delete from dept where dept.deptno = v_deptno;
  end;
  
  create or replace procedure updateOne(v_deptno dept.deptno%type,
                                        v_dname  dept.dname%type,
                                        v_loc    dept.loc%type) is
  begin
    update dept
       set dept.dname = v_dname, loc = v_loc
     where deptno = v_deptno;
  end;
  
  
  create or replace procedure findALL is
    cursor v_depts is
      select * from dept;
  begin
    for c in v_depts loop
      dbms_output.put_line(c.deptno || ',' || c.dname || ',' || c.loc);
    end loop;
  end;
      
      create or replace procedure findById(v_deptno dept.deptno%type) is
        v_dept dept%rowtype;
      begin
        select * into v_dept from dept where deptno = v_deptno;
        dbms_output.put_line(v_dept.deptno || ',' || v_dept.dname || ',' ||
                             v_dept.loc);
      end;
        
        -- 查询所有
        declare
        begin
          findAll;
        end;
          
          -- 查询一条
          declare
          begin
            findById('40');
          end;
        
        -- 删除一条
        declare
        begin
          deleteOne('50');
        end;
          
          -- 增加一条
          declare
          begin
            addOne('50', '测试部', '背景');
          end;
        -- 修改一条
        declare
        begin
          updateOne('50', '轻音部', '日版');
        end;

~~~




# 2023年7月8日

java之父 ：James Gosling 詹姆斯·高斯林

## java -- 面向对象

`JavaSE `： Java标准版

`JavaEE`：Java企业版

`JavaME`：Java移动版（用于塞班系统，已经接近淘汰）

### java的特性

1、跨平台：一次编译到处运行
java是运行在虚拟机（JVM）上的，虚拟机跨平台，shell语言和python语言都是运行在操作系统上的
JRE ---- Java运行环境（包含了JVM，还包含了别人写好的代码）
JDK ---- Java开发工具包

2、垃圾回收
在内存中释放没用的变量

### 环境变量

1、`JAVA_HOME` ---- java安装程序的根目录

2、`path` ---- 根目录下的bin文件夹，使得当前系统能够直接找到bin文件夹中的所有开发工具

3、`CLASSPATH` ---- 首先在当前目录寻找java代码，然后在根目录下的`lib`中寻找java代码

### 命令行运行java

java文件后缀是`.java`，这是原文件我们需要通过`javac`命令对它进行编译，得到编译后文件，也就是.class文件

运行java程序，使用`javac名` + 类名

~~~shell
javac Hello.java

java Hello
~~~

### java规范

1、类名首字母大写，并且和文件名同名
2、多写注释：

~~~java
/* 开头
xxxx
xxx
*/结尾 它能注释一段
    
    //它能注释一行
~~~

### 标识符

字母数字下划线和$，不能以数字开头

所有标识符必须遵循见名知意和驼峰原则

变量名和方法名：首字母小写，后面单词首字母大写   lowerCamelCase

类名：所有单词首字母大写											UpperCamelCase

包名：全小写	

常量名：全大写

### 整型的取值范围

byte ---- -2^7 到 2^7- 1

short ---- -2^15 -> 2^15 -1

int ---- -2^31 -> 2^31-1

long ---- -2^63 -> 2^63-1

默认整型为int型

### 浮点型

float ---- -2^128 -> 2^127

double ---- -2^1024 -> 2^1023

默认浮点型为double型

### 字符型char

### 布尔型boolean

注意：\表示转义字符，它有特殊的含义

\n ---- 换行

\t ---- 缩进（水平制表符）

\\\ ---- 打印反斜杠

注意：局部变量的作用范围是它所定义的语句所在的当前的一对大括号

### 自动类型转换

容量小的数据类型和容量大的数据类型作运算时，会自动将容量小的类型转容量大的类型，然后再运算。

当容量小的数据类型的值赋给容量大的数据类型的变量时，也会自动将类型转大，再赋值。

容量的大小问题：
1、byte,short,char  这三种并列最小，当它们之间进行运算时，统一转成int，然后运算
注意：这三者哪怕是相同的类型在进行运算，也会转为int

~~~java
		short s5 = 200;
		short s6 = 300;
		short s7 = s5 + s6;//s5 + s6还是会转换成int进行运算，因此报错
~~~

注意：char型在运算的时候，使用的是UNICODE编码

2、除此以外，从小到大的顺序：int->long->float->double

### 强制类型转换 

---- 容量大的数据类型转容量小的数据类型需要使用一对小括号（目标类型）来完成

强制类型转换可能会有精度的溢出

# 2023年7月10日

## String --- 字符串

字符串在跟其他任何数据类型运算的时候，只有加号+，加号的含义不是加法，而是字符串的拼接

~~~java
	String s3 = "hello";
	int i3 = 12;
	char c1 = 'a';
	System.out.println(s3 + i3 + c1);//hello12a
	System.out.println(i3 + c1 + s3);//109hello
	System.out.println(c1 + s3 + i3);//ahello12
~~~

## ++和--

++a : 先自增再使用变量
a++ ：先使用变量再自增 

if语句的条件判断必须传入boolean值，否则编译报错

赋值运算符“=”，本身也是有值的，它的值就是等号右边的值。

## 逻辑运算符

单&时，左边无论真假，右边都进行运算
双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算

`|`和`||`区别同理

## 位运算符

n >> m ---- n右移m位，相当于n除以2的m次方

n << m ---- n左移m位，相当于乘以2的m次方

## 三元运算符

条件表达式?值1：值2 ---- 条件表达式成立则位值1，否则为值2

注意：当多种运算符并存的时候，不用考虑优先级的高低，只需要使用一对小括号把自己认为先算的括起来即可

## 分支语句

注意：在if语句中，如果某个分支只有一行代码，那么该分支的一对大括号可以省略。

~~~java
class Test4 {
	public static void main(String[] args){
		int x = 4,y = 1;
		if(x>2){
			if(y>2)
				System.out.println(x + y);//if语句只管这一行
			System.out.println("ss");//这一行不会报错
		}else
			System.out.println("x = " + x);
		System.out.println("hello world");
	}
}
~~~

## 键盘输入Scanner

~~~java
import java.util.Scanner;

class Test4 {
	public static void main(String[] args){
		/*
		控制台打印：请输入一个年份
		打印该年份是不是闰年
		闰年条件：
		1.如果该年份能被4整除，但不能被100整除，那么就是软年
		2.如果该年份能被400整除，也是
		*/
		
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个年份");
		int year = sc.nextInt();
		if((0 == year%4 && 0 != year%100)||0 == year%400){
			System.out.println("是闰年");
		}else{
			System.out.println("不是闰年");
		}
		sc.close();//关闭流	
	}
}
~~~

## switch

~~~java
switch(变量名){
    case 值1:
        代码块1;
        break;
    case 值2:
        代码块2;
        break;
        ...
    default:
        代码块n;
    break;
}
~~~

注意：多个case可以公用一个代码块。

### 面试题

switch语句允许传入哪些数据类型的变量？

byte short int char Enum 
1.7及以后版本的jdk中允许传入String

## 循环四要素

1.初始化表达式
2.布尔值测试表达式
3.循环体
4.更改表达式

### 嵌套循环

一个循环是另外一个循环的循环体，那么该循环就是内层循环，另一个就是外层循环。
内层循环执行结束，外层循环才执行一次
外层循环执行结束，内层循环执行了内层*外层的次数

## break 

结束当前循环，
注意：在嵌套循环中，它结束当前这一层循环

## 无限循环

循环的布尔值测试表达式为true，循环一直执行

while(true)

for(;;){}

## continue

结束当前这一次循环，开启下一次循环

## return

用来结束当前这个方法

注意：当被调用的方法有指定的返回值类型时，该方法中必须写`return 该类型对象`  给调用者，当执行到return语句时，方法也会提前结束。

# 2023年7月11日

## 数组

这是一个容器，可以用来存放指定类型的数值。

定义数组：
1.动态初始化：

~~~java
数组类型[] 数组名 = new 数组类型[长度];
int[] arr = new int[3];
~~~

2.静态初始化：

~~~java
int[] arr = new int[]{1,2,3,4};
//注意：还可以简写
 int[] arr2 = {1,2,3,4};
~~~

~~~java
数组名.length ---- 获取数组长度
~~~

注意：数组一旦初始化，那么它的长度就不能被修改

数组的遍历：

~~~java
int[] arr = new int[]{1,2,3,4};
//1.for循环遍历
for(int i = 0;i < arr.length;i++){
    System.out.println(arr[i]);
}

//2.forEach遍历
for(int j:arr){
	System.out.println(j);
}
~~~

注意：forEach的缺点在于，它只要遍历，就一次性直接遍历完，中途无法获取当前遍历元素的下标

### 冒泡排序

相邻两个数进行比较，如果需要，那么就交换位置，一轮结束，最小的数就排到了第一位，第二轮结束，第二小的数排到了第二位

~~~java
   public static void bubbleSort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {5, 2, 8, 12, 1, 6, 4};
        bubbleSort(array);
        for (int i : array) {
            System.out.print(i + " ");
        }
    }
~~~

## 快速排序

1. 选定Pivot中心轴
2. 将大于Pivot的数字放在Pivot的右边
3. 将小于Pivot的数字防在Pivot的左边
4. 分别对左右子序列重复前三步的操作



注意：实际项目中如果需要排序，则直接调用`java.util.Arrays`包中的`Arrays.sort(数组名)`即可

~~~java
Arrays.toString(数组名); //将数组转成字符串
System.out.println(Arrays.toString(arr));//可以打印数组所有内容
~~~

## 二维数组

一个一维数组中的每个小格子装的都是一个一维数组，那么这就是二维数组

动态初始化：

~~~java
数组类型[][] 数组名 = new 数组类型[长度][长度];
		int[][] arr = new int[3][2];
		arr[0][0] = 101;
		arr[0][1] = 102;
		arr[1][0] = 201;
		arr[1][1] = 202;
		arr[2][0] = 301;
		arr[2][1] = 302;
		
		for(int[] childArr:arr){
			for(int i: childArr){
				System.out.println(i+" ");
			}
			System.out.println();
		}
~~~

静态初始化：

~~~java
		int[][] arr = {{101,102},{201,202},{301,302}};

		System.out.println(arr.length);//3
		for(int i = 0;i < arr.length;i++){
			for(int j = 0;j < arr[i].length;j++){
				System.out.print(arr[i][j] + " ");
			}
			System.out.println();
		}
~~~



### 面试题

动态初始化和静态初始化的区别：

动态初始化的初始化语句和赋值语句分开写。而静态初始化的初始化语句和赋值语句是同一句话

## java中的默认值

整型：0

浮点型：0.0

字符型：'\u0000'

布尔型：false

引用类型：null

注意：当我们使用动态初始化定义一个数组，那么它里面每个小格子都装着一个默认值



## 面向对象的编程思路：

1. 找名词
2. 名词分两类，实体和属性
3. 将每个实体定义成一个类，每个属性定义成类中的一个成员变量
4. 确定类和类之间的关系，编写方法

注意：将某个类的对象传入另一个类的某个方法中，可以体现它们之间的关联关系

## 创建对象

~~~java
new 构造方法();
~~~

## 成员变量

定义在方法外的变量，用来描述类中的某个属性

## 构造方法

与类同名，并且没有返回值，也不能写void，它只能被new调用，用来创建对象，当我们不写构造方法，系统将默认提供一个无参构造方法。

一般来讲，我们会将给对象赋属性值的动作写入构造方法。当被调用时需要传入参数为属性赋值

注意：通常当我们写了一个有参的构造方法，最好再写一个无参的构造方法，提供给别人调用。

## 内存解析

**栈内存** ---- 存放局部变量，方法的运行也在栈内存中

**堆内存** ---- 存放所有的对象

**方法区** ---- 存放所有的代码，它里面还包含常量池

**本地方法栈** ---- 和操作系统相关（仅作了解）

**程序计数器** ---- 和cpu相关（仅作了解）

注意：当栈空间中的局部变量是引用类型，那么它存放的一定是一个地址，这是一个堆空间中某个对象的地址。当局部变量的作用范围结束，它会立即从占空间中被删除，然后堆空间中的对象会变成垃圾。在未来的某个时刻被垃圾回收器gc收走，释放内存

# 2023年7月12日

## 重载

在一个类中有多个方法，他们的方法名是一样的，他们的参数不一样（参数不一样体现在：参数的个数、参数的类型），根据调用者传入的参数决定调用的是哪个方法

注意：构造方法也是可以重载的，根据传参决定由哪个构造方法创建对象

注意：不要以参数名的不同来定义重载，那不是重载，那就是相同的方法

## this

它是一个引用，它存放当前对象的地址，我们可以使用`this.成员变量`来访问当前对象的成员变量，`this.方法`来调用当前对象所在类的方法。

~~~java
public class Leaf {
    int i;

    public Leaf() {
    }

    public Leaf(int i) {
        this.i = i;
    }

    public Leaf increment() {
        this.i++;
        return this;
    }

    public void print() {
        System.out.println(this.i);
    }

    public static void main(String[] args) {
        Leaf leaf = new Leaf(1);
        leaf.increment().increment().increment().print();//链式调用
    }
}
~~~



## static

静态的，它可以用来修饰成员变量和方法

被static修饰的成员变量被成为静态成员变量，它被该类所有的对象共享，它在内存中只有一份，存放在内存中的常量区

static的成员变量可以由类名直接调用，它可以用来计数

~~~java
public class Cat {

    int id;
    String name;
    static int sid;

    Cat() {
        this.id = sid++;
    }


    Cat(String name) {
        this.id = sid++;
        this.name = name;
    }

    public static void main(String[] args) {
        Cat.sid = 1;
        Cat c1 = new Cat();
        c1.name = "Tom";

        Cat c2 = new Cat("小白");

        System.out.println(c1.id + "," + c1.name);//1,Tom
        System.out.println(c2.id + "," + c2.name);//2,小白

    }
}
~~~

被static修饰的方法被称为静态方法，静态方法又称为类方法，在静态方法中不能直接使用非静态的成员变量或非静态的方法。静态方法中不能用this

# 2023年7月13日

## 包

package

为了解决类名冲突的问题，Java引入了包的机制，我们往往先创建bao，再创建类，类名上方出现package语句用来描述当前类所在的包。

注意：

- 通过一个包下不能出现相同的包名
- 如果需要使用不同的包下的类，必须编写全类名（带包名的类名），或者使用`import`语句将该类导入

注意：`import`语句中的 `* `表示通配符，它可以导入某个包下的所有类

java.lang是整个JDK唯一一个无需导包就可以直接使用的包，它里面都是一些非常常用的类。

注意：通常对于包名的命名都会采用所在公司域名的倒写。

## 继承

“xxx”是一种“yyy”，只要这句话能说得通，这两个类就具有继承关系，被继承的类称为父类（基类，超类），继承的类称为子类（派生类）

子类自动拥有父类中所有的成员变量和方法，除此之外，子类还可能拥有其他新增加的属性和方法

创建子类语法：

~~~java
class 类名 extends 父类类名{
    
}
~~~

Java语言是单继承，一个子类不能同时继承多个父类，但是，继承有传递性

## 访问控制符

| 访问控制符 | 同一个类 | 同一个包 | 子类 | 任何地方 |
| ---------- | -------- | -------- | ---- | -------- |
| private    | √        |          |      |          |
| default    | √        | √        |      |          |
| protected  | √        | √        | √    |          |
| public     | √        | √        | √    | √        |

public修饰的类可以在任何地方使用，否则只能在当前包下使用

**子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

注意：子类拥有父类中的private方法，单子类不能使用该方法

## JavaBean

一个实体类，应该将所有成员变量私有化，并提供公共的get/set方法给外界调用，来堆成员变量存值和取值

至少提供一个无参构造器来创建对象。

JavaBean体现了面向对象的封装性。

## 重写

子类继承父类，子类对父类的方法不满意，那么子类可以重写父类中的方法，被重写的方法和重写的方法必须有相同的声明部分。它们的方法实现不一样，根据调用者的类型来决定调用哪个方法。

我们可以在重写的方法上方使用@Override注解来检查是不是重写

## super

这是一个引用，它在每个对象内部，它存放着当前对象的父类对象的内存地址，我们可以使用super.成员变量来访问父类对象的属性，我们可以使用super.方法来调用父类的方法。

父类在内存中会包含父类的部分：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689219257/javaStudy/%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E7%B1%BB%E4%B9%9F%E4%BC%9A%E5%AF%B9%E5%BA%94%E7%94%9F%E6%88%90%E4%B8%A4%E4%B8%AA%E7%88%B6%E7%B1%BB_a9u2hy.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689219257/javaStudy/如果有两个子类也会对应生成两个父类_a9u2hy.jpg)

~~~java
//父类
public class FatherClass {
    int value;
}
//子类1
public class SubClass extends FatherClass{
}
//子类2
public class SubClass2 extends FatherClass{
}
//测试
public class Test {

    public static void main(String[] args) {
        SubClass subClass = new SubClass();
        SubClass2 subClass2 = new SubClass2();
        subClass.value = 1;
        subClass2.value = 2;
        System.out.println(subClass.value);//1
        System.out.println(subClass2.value);//2
        //事实证明子类的对象包含父类的部分，并且并不想通
    }
}
~~~

## 继承中的构造方法

1. 子类在构造的过程中必须首先调用父类的构造方法来构造父类对象。
2. 在子类的构造方法中可以使用super(参数)来调用父类指定的某个构造方法构造父类对象。
3. super()可以不写，那么默认调父类无参构造方法，如果写了，则必须写在子类构造方法的第一行
4. 如果不写super()而父类中又没有无参构造方法，则编译报错

## this()

在某个构造方法中调用其他构造方法来创建对象

## Object

这是所有类的父类，当我们定义的某个类不继承任何类，那么它就直接继承了Object类，所有类都拥有并可以使用Object类中的方法。

## toString()

用一个字符串的形式来描述当前对象

## 父类引用指向子类对象

子类对象当作父类对象去使用（向上转型）

向上转型又称为父类引用指向子类对象。

当父类引用指向子类对象的时候，父类引用无法访问子类对象中新增加的成员。

注意：父类引用指向子类对象的好处：代码可扩展性比较好

~~~java
//假设Cat、Dog、Bird都是Animal的子类，分别有自己的一些独立方法
public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat("猫", "蓝色");
        Animal a2 = new Dog("狗", "红色");
        Animal a3 = new Bird("鸟", "绿色");

        f(a1);
    }
    //可扩展性体现在此
    static void f(Animal a) {
        System.out.println();
        if (a instanceof Cat) {
            System.out.println(((Cat) a).getEyesColor());
        } else if (a instanceof Dog) {
            System.out.println(((Dog) a).getFurColor());
        } else if (a instanceof Bird) {
            System.out.println(((Bird) a).getColor());
        }
    }
}

~~~



## instanceof

用来判断某个对象是否是某个类或该类子类的对象。

~~~java
    //假设Cat类和Dog类都是Animal类的子类
public static void main(String[] args) {
        Animal a = new Animal();
        Cat c = new Cat();
        a = new Cat();

        System.out.println(a instanceof Animal);//true
        System.out.println(a instanceof Cat);//true
        System.out.println(a instanceof Dog);//false
    }
~~~

## 向下转型

将父类变量使用`(子类类型)`转成子类类型，向下转型之后，该引用就可以访问子类中新增加的成员。

~~~java
        Animal a = new Cat();
        Cat c  = (Cat)a;
        c.eyeColor();
~~~

## 多态

运行时多态：当父类引用指向子类对象的时候，父类引用调用父类的方法，实际上调用到的是子类重写过后的方法，

多态是面向对象的核心机制，它的存在使得我们的代码可扩展性达到了最好

## 抽象类和抽象方法

只有声明而没有实现的方法

抽象类：含有抽象方法的类

抽象方法和抽象类都必须被abstract关键词修饰

抽象类不能被实例化，抽象类都是用来被继承的，继承了抽象类，就必须要重写该抽象类中所有的抽象方法
# 2023年7月14日

## equals(对象)

判断当前对象是否与传入对象相等

Object的equals(对象) ---- 它判断的是两个对象是否是同一个对象，只有同一个对象才认为相等，否则都是不等。所以我们通常需要对Object类的equals方法进行重写，把我们自己认为相等的标准写入equals()

一般来讲，我们都会以成员变量值全部相等，作为相等的标准。

~~~java
public class Cat {

    int color;
    int height;
    int weight;

    public Cat(int color, int height, int weight) {
        this.color = color;
        this.height = height;
        this.weight = weight;
    }

    @Override
    public boolean equals(Object obj) {
        if (null == obj) {
            return false;
        }
        if (!(obj instanceof Cat)) {
            return false;
        } else {
            Cat c = (Cat) obj;
            if (c.color == this.color && c.height == this.height &&
                    c.weight == this.weight) {
                return true;
            } else {
                return false;
            }
        }

    }
}

//test
public class Test {


    public static void main(String[] args) {
        int i = 100;
        int j = 100;
        System.out.println(i == j);//true

        Cat c1 = new Cat(999, 12, 12);
        Cat c2 = new Cat(999, 12, 12);
        System.out.println(c1 == c2);//false
        System.out.println(c1.equals(c2));//true
    }
}

~~~

## final

它可以用来修饰一个类，表示该类不能被继承

它可以用来修饰一个方法，表示该方法不能被重写

它可以用来修饰一个变量，表示该变量值不能改

## 常量

~~~java
public static final 常量类型 常量名
~~~

## 接口

接口中的方法都是抽象方法，它使用interface定义

接口中的方法默认都是public的

接口是抽象方法和常量的集合

类可以通过implements来实现接口，实现接口就必须要重写接口中所有的抽象方法。

在调用的时候，我们可以通过接口类型的引用指向其实现类的对象。当我们使用该引用调用接口类的方法，实际执行的是实现类中重写的方法，所以接口也具有多态性

一个接口可以被多个无关的类实现
一个类可以同时实现多个无关的接口
如果接口的引用指向实现类的对象，那么该引用只能访问当前接口中的方法

## 异常处理

~~~java
try{
    可能抛出异常的代码
}catch (异常类型 变量名){
    当抛出该异常类型对象时的处理语句
}
~~~

## throws 

当我们的方法可能抛出某个异常时，我们不作处理，使用throws抛给调用者来处理

对于编译时异常，不try catch则，必须要写throws，

对于运行时异常，不try catch，写不写throws都可以在它的调用者处进行异常处理

~~~java
public class Test3 {


    public static void main(String[] args) {
        f(10);
    }

    public static void f(int i) throws ArithmeticException {
        int res = 0;
        res = 100 / i;
        System.out.println(res);
    }
}
~~~

## throw

手动抛一个异常（就算实际没发生异常，也能抛出来）

~~~java
public class Test {
    public static void main(String[] args) {
        try {
            f();
        } catch (ArithmeticException e) {
            System.out.println("抛出一个异常0");
        }
    }

    public static void f() throws ArithmeticException {
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        if (0 == i)
            throw new ArithmeticException();
        sc.close();
    }
}
~~~

所有异常类的结构图：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689314013/javaStudy/%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE_sw0vzq.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689314013/javaStudy/所有异常类的结构图_sw0vzq.jpg)

### 常见异常

1. NullPointerException (空指针异常)：当试图在一个空对象上调用方法或访问属性时抛出。
2. IllegalArgumentException (非法参数异常)：当传递给方法的参数不合法时抛出，例如传递了不允许的值或无效的参数。
3. ArrayIndexOutOfBoundsException (数组索引越界异常)：当访问数组中不存在的索引时抛出。
4. ArithmeticException (算术异常)：当发生数学运算错误时抛出，例如除数为零。
5. ClassCastException (类转换异常)：当试图将一个对象强制转换为不兼容的类时抛出。
6. IllegalStateException (非法状态异常)：当对象处于不允许的状态时抛出，例如在调用方法之前或之后。
7. IOException (输入输出异常)：处理输入和输出操作时可能发生的异常，例如文件读写错误。
8. FileNotFoundException (文件未找到异常)：当试图打开不存在的文件时抛出。
9. InterruptedException (中断异常)：当线程在等待、休眠或阻塞状态时被中断时抛出。
10. UnsupportedOperationException (不支持操作异常)：当不支持的操作或方法被调用时抛出。

运行时异常在编译的时候可以不做处理，而编译通过。

非运行时异常在编译的时候，必须try catch 或者throws，否则编译报错

读取文件：

~~~java
    public static void main(String[] args) {
        InputStream is = null;
        try {
            is = new FileInputStream("D:\\java\\MyProject\\test20230714\\src\\com\\iweb\\test\\Test4.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

## finally

它是跟在try catch后面的第三个代码块，表示无论是否抛异常，都一定要执行的代码

注意：当finally代码块之前执行了return语句，那么，finally代码块中的代码也一定会执行，而且会在return之前执行

注意：当一个try代码块对应多个catch代码的时候，catch代码块的先后顺序要求先捕获子类异常，后捕获父类异常

### 面试题

final、finally、finalize三个单词有什么区别



finalize：垃圾回收器调用的一个方法的方法名

## String

字符串，不可变的字符序列

字符串是常量，存放在常量区

注意：做项目的过程中，凡是牵涉到字符串的比较，一律使用equals()

new String("hello");  ---- 创建了两个对象，现在常量池创建"hello"，然后再拷贝一份到堆内存

~~~java
    public static void main(String[] args){
        String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1 == s2);//true
        String s3 = "he" + "llo";
        System.out.println(s1 == s3);//true
        String s4 = new String("hello");
        System.out.println(s1 == s4);//false
        System.out.println(s1.equals(s4));//true
    }
~~~

常用方法

~~~java
        String s2 = "hello";
        System.out.println(s2.charAt(4));//o
        System.out.println(s2.endsWith("llo"));//true
        System.out.println(s2.endsWith("hel"));//false
        System.out.println(s2.endsWith(""));//true
        String s5 = "HELLO";
        System.out.println(s2.equals(s5));//false
        System.out.println(s2.equalsIgnoreCase(s5));//true
        System.out.println(s2.indexOf("o"));//4
        System.out.println(s2.isEmpty());//false
        String s6 = "";
        System.out.println(s6.isEmpty());//true
        System.out.println(s2.length());//5


        String s7 = s2.replace("ll", "LL");
        System.out.println(s7);//heLLo
        System.out.println(s2);//hello  常量是不会变的
        String s8 = "Java,Oracle,Html,Servlet,Spring,Vue";
        String[] arr = s8.split(",");
        for(int i = 0;i < arr.length;i++){
            System.out.print(arr[i] + "  ");
        }//Java  Oracle  Html  Servlet  Spring  Vue
        String s9 = s2.substring(0,4);
        System.out.println();
        System.out.println(s9);//hell
        String s10 = s2.toUpperCase();
        System.out.println(s10);//HELLO
        String s11 = s10.toLowerCase();
        System.out.println(s11);//hello
        String s12 = "         sfaf      ";
        String s13 = s12.trim();//无法去除字符串中间的空格
        System.out.println(s13);//sfaf
        System.out.println(s12);//         sfaf
        Cat c = new Cat();
        String s14 = String.valueOf(c);
        System.out.println(s14);//com.iweb.test.Cat@745f
~~~

注意：trim()无法去除字符串中间的空格，要用以下方法：

~~~java
        String s15 = "  hello my  friend  ";
        String s16 = s15.replaceAll("\\s+","");
        System.out.println(s16);
//使用了正则表达式\\s+来匹配一个或多个连续的空格，并将其替换为空字符串，从而实现去除空格的效果。
~~~

在Java中，`\\s+` 是一个正则表达式，表示匹配一个或多个连续的空白字符。空白字符包括空格、制表符、换行符和回车符等。

正则表达式中的 `\\s` 表示空白字符，而 `+` 表示匹配前面的元素一次或多次。因此，`\\s+` 表示匹配一个或多个连续的空白字符。

你可以使用 `\\s+` 来进行字符串的分割和匹配。以下是一些示例用法：

~~~java
String input = "Hello   World   Java";
String[] words = input.split("\\s+");

// 结果：words = ["Hello", "World", "Java"]
~~~



## 加密算法

使用 `DigestUtils.md5Hex(明文)`;

~~~java
    public static void main(String[] args) {
        String s1 = "123456";
        String s2 = DigestUtils.md5Hex(s1);
        System.out.println(s2);//e10adc3949ba59abbe56e057f20f883e
    }
~~~



sha256加密 ---- 使用`DigestUtils.sha256Hex(明文)`

~~~java
        String s3 = DigestUtils.sha256Hex(s1);
        System.out.println(s3);
~~~

## StringBuffer

可变的字符序列，它里面的字符串内容可以被改变

append(字符串) ---- 将传入的字符串追加到当前字符串后面

insert(下标，字符串) ---- 将传入的字符串插入指定下标

delete(起始下标，结束下标) ---- 删除指定下标位置开始到指定下标位置结束的子字符

~~~Java
    public static void main(String[] args){
        StringBuffer stringBuffer = new StringBuffer("hello");
        stringBuffer.append(" world");
        System.out.println(stringBuffer);//hello world
        stringBuffer.insert(3,"Tom");
        System.out.println(stringBuffer);//helTomlo world
        stringBuffer.delete(3,6);//从下标为3删到下标为6
        System.out.println(stringBuffer);//hello world

    }
~~~

## StringBuilder

和StringBuffer类似，也是可变字符序列

StringBuffer和StringBuilder的区别：

- StringBuffer是线程同步的，在多线程的项目中，安全性高，但是效率低
- StringBuilder是线程不同步的，在多线程的项目中，安全性低，但效率高

## Math

数学相关的类

sqrt ---- 平方根

random ---- [0.0,1.0) 的随机小数

abs ---- 绝对值

round ---- 四舍五入求整数部分

max ---- 最大值

min ---- 最小值

# 2023年7月15日

## Date

日期类，创建出Date对象表示当前时间，我们可以使用SimpleDateFormat对象来定义年月日时分秒的格式，格式中：y表示年，M表示月，d表示日，h表示小时，m表示分钟，s表示秒

我们可以使用SimpleDateFormat对象调用format方法传入Date对象得到符合该格式的日期字符串。

~~~java
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);//Sat Jul 15 09:19:13 CST 2023
        SimpleDateFormat sdf =
                new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
        String s = sdf.format(date);
        System.out.println(s);//2023-07-15 09-19-13
    }
~~~



## BigDecimal

大数值型，它可以在项目中进行算数运算，它的底层是字符串，没有长度限制，它也没有浮点型精度误差的问题，它提供了一些方法供我们调用：

add() ---- 加法

subtract() ---- 减法

multiply() ---- 乘法

divide() ---- 除法，在除法中，第二个参表示小数位，第三个参表示保留方式，ROUND_HALF_UP表示四舍五入的方式

计算结果也是BigDecimal对象，我们可以调用它的xxxValue()转成基本数据类型

~~~java
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);//Sat Jul 15 09:19:13 CST 2023
        SimpleDateFormat sdf =
                new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
        String s = sdf.format(date);
        System.out.println(s);//2023-07-15 09-19-13


        double d1 = 1.0;
        double d2 = 3.0;
        BigDecimal b1 = new BigDecimal(String.valueOf(d1));
        BigDecimal b2 = new BigDecimal(String.valueOf(d2));
        BigDecimal res = b1.add(b2);
        System.out.println(res);//4.0
        double resultDouble = res.doubleValue();
        System.out.println(resultDouble);//4.0

        BigDecimal res2 = b2.subtract(b1);
        System.out.println(res2);//2.0

        BigDecimal res3 = b1.multiply(b2);
        System.out.println(res3);//3.00

        BigDecimal res4 = b1.divide(b2, 5, BigDecimal.ROUND_HALF_UP);
        System.out.println(res4);//0.33333


    }
~~~

## 枚举型

使用enum来定义该类型，该类型的变量只能在指定的若干值中间获取

定义格式：

~~~java
enum 枚举类型名{
    值1，值2...
}
~~~

定义变量并初始化：

枚举类型 变量名 = 枚举类型.值

~~~java
public enum MyColor {
    red,blue,green,yello
}
~~~

~~~java
        MyColor m = MyColor.blue;
        System.out.println(m);//blue
        switch (m) {
            case red:
                System.out.println("红色");
                break;
            case green:
                System.out.println("绿色");
                break;
            case blue:
                System.out.println("蓝色");
                break;
            default:
                System.out.println("黄色");
                break;
        }
~~~

## 基本数据类型包装类

java中针对8种基本数据类型，分别提供了各自的包装类

当传入参数需要用到对象而不是数值的时候，就轮到包装类上场了

Integer ---- int

Character ---- char

剩下的6种，首字母转大写即可

创建包装类的对象，之许哟啊将基本数据类型数值传入包装类的构造方法即可

从包装类对象种取出基本数据类型数值只需要调用xxxValue()即可

valueOf(字符串) ---- 将字符串中的数值取出获取最基本数据类型的包装类对象

parseXxx(字符串) ---- 将字符串中的数值取出获取该基本数据类型的数值

~~~java
    public static void main(String[] args) {
        Integer integer = new Integer(100);
        System.out.println(integer);
        int i = integer.intValue();//Integer  -> int
        System.out.println(i);

        String s = String.valueOf(i);//int -> String
        System.out.println(s);

        Integer integer1 = Integer.valueOf(s);//String  -> Integer
        System.out.println(integer1);
        
        //Integer.parseInt()
        int i1 = Integer.parseInt(s);//String -> int
        System.out.println(i1);

    }
~~~

注意：如果从字符串中解析数值，则该字符串中的数值必须符合类型规范，否则会抛出NumberFormatException异常

成员变量只声明未初始化在类初始化时会赋予默认值可以直接使用；局部变量必须赋值才可以使用，如果局部变量未赋值，**编译无法通过**。

基本数据类型的包装类对象的默认值为null



## 集合

常用的集合类：

List ---- 这是一个接口，里面存放的元素都是有序的，可重复的

List接口有一个ArrayList的实现类，它的底层是数组

add(对象) ---- 添加元素

size() ---- 获取List中元素的个数

get(下标) ---- 根据下标获取该下标位置的元素

contains(对象) ---- 判断当前集合是否包含指定对象

remove(对象) ---- 从当前集合中删除指定对象

注意：不管是contains还是remove，传入的对象，都需要和当前集合中的某个对象相互equals才能完成操作

~~~java
		//Student类中必须重写equals方法，才能使用contains和remove方法
        System.out.println(list.contains(
                new Student("1000", "zhangsan", 12)));
        System.out.println(list.remove(
                new Student("1000", "zhangsan", 12)));
            
~~~

Iterator ---- 迭代器，它是foreach循环的底层原理，我们可以通过iterator()来获取当前集合的迭代器

常用方法：

hasNext() ---- 判断是否迭代结束

next() ---- 迭代下一个元素

remove() ---- 删除当前正在被迭代的元素，注意：必须先调用一次next()之后才可以调用remove()进行删除

~~~java
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object o = iterator.next();//迭代下一个元素
            System.out.println(o);
            iterator.remove();
        }
~~~

## Set

是个接口，里面存放的元素是无序的，不可重复的

常用方法：

add(对象) ---- 添加元素

~~~java
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(new Student("1000", "zhangsan", 12));
        set.add("hello");


        System.out.println(set.size());
        System.out.println(set);

        for (Object o : set) {
            System.out.println(o);
        }

    }
~~~

#  2023年7月17日

## Map

这是一个集合，跟List,Set不一样，它不是Collection接口下的子接口，它自己单独就是一个接口，它们里面可以存放一对一对的元素，每一对元素称为键值对，通过键可以找到值

常见的实现类：`HashMap`

`put(键,值)` ---- 往Map中添加一个键值对

注意：键不能重复，否则会覆盖map中键值对

~~~java
        Map map = new HashMap();
        map.put("1","One");
        map.put("2","Two");
        map.put("3","Three");
        map.put("1","hello");
        System.out.println(map);//{1=hello, 2=Two, 3=Three}
~~~

`get()` ---- 根据键获取对应的值 ，返回类型为Object

`containsKey(键)` ---- 判断当前集合中是否包含传入的键

`containsValue(值) `---- 判断当前集合中是否包含传入的值

~~~java
        Object o = map.get("1");
        System.out.println(o);
        System.out.println(map.containsKey("1"));//true
        System.out.println(map.containsValue("One"));//false
~~~

Map接口下的实现类除了`HashMap`还有`HashTable`，区别在于：

`HashMap`非线程同步，效率高，可以使用null作为键

`Hashtable`线程同步，效率低，不能使用null作为键

## 自动装箱、拆箱（打包、解包）

在Java中，当我们需要一个基本数据类型包装类对象时，直接传入一个基本数据类型数值即可，它会自动打包，又叫自动装箱。

当我们需要一个基本数据类型时，直接传入一个包装类即可，会自动解包，又叫自动拆箱

## Collections

这是Collection集合的帮助类，它提供了各种静态方法对我们的集合进行操作，例如：

sort() ---- 对一个List进行大小排序

~~~Java
        List list = new ArrayList();
        list.add(100);
        list.add(32);
        list.add(53);
        list.add(5);
        list.add(13);
        list.add(87);
        list.add(6);
        list.add(99);
        System.out.println(list);//[100, 32, 53, 5, 13, 87, 6, 99]

        Collections.sort(list);
        System.out.println(list);//[5, 6, 13, 32, 53, 87, 99, 100]
~~~

## 泛型

集合对象在定义的时候，可以使用泛型来限定它里面对象的数据类型,使用<>表示其泛型的类型

格式：

~~~java
集合接口<泛型> 变量名 = new 集合类<>();
~~~

~~~java
        List<String> list = new ArrayList<>();
        list.add("hello");
        list.add(100);//编译报错
~~~

~~~java
        Map<String,Integer> map = new HashMap<>();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
~~~

~~~java
        List<Map<String,String>> list = new ArrayList<>();
        for(int i = 0;i < 10;i++){
            Map<String,String> map = new Hashtable<>();
            for(int j = 0;j < 10;j++){
                map.put("key:" + i + j,"value:" + i + j);
            }
            list.add(map);
        }

        System.out.println(list);
~~~

~~~java
        Map<String,String> map1 = new Hashtable<>();
        map1.put("sno","1001");
        map1.put("sname","1001");
        map1.put("sage","1001");
        Map<String,String> map2 = new Hashtable<>();
        map2.put("sno","1002");
        map2.put("sname","1002");
        map2.put("sage","1002");
        List<Map<String,String>> list = new ArrayList<>();
        list.add(map1);
        list.add(map2);
        for(Map<String,String> m : list){
            System.out.println(m);
        }
~~~

### 自定义泛型类

用户在使用该类的时候，指定泛型类型

~~~java
class 类名<泛型标识>{
    泛型标识 变量名;
    ...
}
~~~

~~~java
public class Generic<E> {
    private E name;


    @Override
    public String toString() {
        return "Generic{" +
                "name=" + name +
                '}';
    }

    public Generic() {

    }

    public Generic(E name) {
        this.name = name;
    }

    public E getName() {
        return name;
    }

    public void setName(E name) {
        this.name = name;
    }
}

//测试
    public static void main(String[] args) {
        Generic<String> generic = new Generic<>("hello");
        System.out.println(generic);

        Generic<Integer> generic1 = new Generic<>(122);
        System.out.println(generic1);
    }
~~~

**注意**：当使用的时候不指定泛型，那么相当于使用Object类作为泛型

**注意**：同一个类，不同泛型的对象，它们的类型还是相同的

### Random

随机数类，它的`nextXxx(上限值)`方法，可以获取某种类型，在上限值范围内的一个随机数

~~~java
    public static void main(String[] args) {
        Random random = new Random();
        int i = random.nextInt(100);//[0,100)
        System.out.println(i);
    }
~~~

~~~java
//抽奖器
public class ProductGetter<T> {

    static Random random = new Random();
    private T product;//奖品
    private List<T> list = new ArrayList<>();//奖池

    //往奖池中添加奖品

    public void addProduct(T t) {
        list.add(t);
    }

    //从奖池中抽取一个奖品
    public T getProduct() {
        this.product = this.list.get(random.nextInt(list.size()));

        return this.product;
    }

}
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();

        productGetter.addProduct("爱疯19");
        productGetter.addProduct("高木同学");
        productGetter.addProduct("日高小春");

        System.out.println(productGetter.getProduct());

        ProductGetter<Integer> productGetter1 = new ProductGetter<>();
        int[] arr1 = new int[]{1,2,3,4};
        for(int i = 0;i < arr1.length;i++){
            productGetter1.addProduct(arr1[i]);
        }
        System.out.println(productGetter1.getProduct());

    }
~~~

### 继承中的泛型

如果父类是一个泛型类，子类也是一个泛型类，那么子类在定义的时候，泛型类型必须包含父类的泛型类型

~~~java
public class ChildGeneric<E> extends Generic<E> {
    
    @Override
    public E getName(){
        return super.getName();
    }
}
~~~

如果子类不是泛型类，那么子类在定义的时候必须指明父类泛型类型

~~~java
public class ChildGeneric2 extends Generic<Integer>{
    @Override
    public Integer getName() {
        return super.getName();
    }
    
    @Override
    public void setName(Integer name){
        super.setName(name);
    }
}
~~~

### 泛型接口

定义格式：

interface 接口名<泛型标识>

1.如果实现类不是泛型类，那么实现类在定义的时候，必须指定接口的泛型类型。

2.如果实现类也是泛型类，那么实现类的泛型类型必须包含接口中的泛型类型

### 泛型方法

使用<泛型标识> 声明的方法

注意：泛型类中的方法不一定是泛型方法，一定要用<泛型标识>声明的方法才叫泛型方法

调用该方法的时候，由调用者确定泛型类型

~~~java
//在抽奖器类中添加泛型方法
    public <T> T getProduct(ArrayList<T> list){
        return list.get(random.nextInt(list.size()));
    }
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();
        ArrayList<String> list1 = new ArrayList<>();
        list1.add("高木同学");
        list1.add("日高小春");
        list1.add("古手川千纱");
        String res = productGetter.getProduct(list1);
        System.out.println(res);

        ArrayList<Integer> list2 = new ArrayList<>();
        list2.add(122);
        list2.add(4243);
        list2.add(3);
        Integer res2 = productGetter.getProduct(list2);
        System.out.println(res2);

    }

~~~

~~~java
public class ProductGetter<T> {
    public static <T,E,K> void printType1(T t,E e,K k){
        System.out.print(t + " --- " + t.getClass() + ",");
        System.out.print(e + " --- " + e.getClass() + ",");
        System.out.print(k + " --- " + k.getClass());
        System.out.println();
    }
}

    public static void main(String[] args) {
        ProductGetter.printType1("hello",100,false);
        ProductGetter.printType1(false,3.14,'a');
    }
~~~

### 可变参数的泛型方法

在泛型方法的形参中使用`泛型标识 ... 变量名` 可以声明一个方法，别人调用的时候，传入任意个数的参数

该变量接收到的是一个泛型参数的数组

~~~java
    public static <E> void printType2(E... e) {
        for (int i = 0; i < e.length; i++) {
            System.out.print(e[i] + " --- " + e[i].getClass() + ",");
        }
    }

//test
    public static void main(String[] args) {
        ProductGetter.printType2("hello", 100, false);
    }
~~~

### 泛型中的通配符

泛型没有继承性，我们可以使用`？`来定义泛型标识通配符，该泛型的类对象可以接收任何泛型的该类对象的值。

~~~java
        List<String> list = new ArrayList<>();
        List<Object> list1 = new ArrayList<>();
        List<?> list2 = new ArrayList<>();
        list1 = list;//报错
        list2 = list;

        Map<String,String> map = new HashMap<>();
        Map<String,Object> map2 = new HashMap<>();
        map2 = map;//报错
        Map<?,?> map3 = new HashMap<>();
        map3 = map;
~~~



## Maven

这是一个帮助我们下载管理jar包和构建项目的工具

`mvn -v` ---- 查看当前maven工具的版本号

中央仓库 ---- 一台搭建在国外的仓库服务器，里面保存着所有我们将使用的jar

私服仓库 ---- 本公司所能使用到的jar包，从中央仓库下载下来

阿里云的镜像仓库 ---- 这是搭建在国内的Maven镜像仓库，它每15分钟和中央仓库同步一次，保证国内程序员的下载速度

本地仓库 ---- 我们自己个人电脑上的一个文件夹，装着自己曾经下载的所有jar包

### 依赖的坐标

`groupId` ---- 公司名称

`artifactId` ---- 项目名称

`version` ---- 版本号

Maven项目之间有继承关系，在父工程下面可以包含子模块，在父工程的pom.xml中：
`<packaging>pom</packaging>`表示这是父工程
`<modules>`表示当前父工程下包含的子模块
在子模块的pom.xml中`<parent>`表示其父工程的坐标

**注意**：模块的依赖具有传递性，如果b模块依赖了a模块，那么它也会自动依赖a模块的依赖

**注意**：父工程的pom.xml中可以通过`<dependencyManagement>`来统一管理子模块的依赖版本，子模块的pom.xml中依赖的坐标版本号标签`<version>`可以省略

## `MVC`开发模型

M ---- Model ： 模型代表应用程序的数据和业务逻辑。数据库、SQL语句、JDBC、JavaBean

V ---- View ：视图是用户界面的表示层，负责将数据以可视化的方式展示给用户。用户操作的前端，是用户界面的表示层，

C ---- Controller ： 控制器是模型和视图之间的桥梁，负责接收用户的输入，并根据输入更新模型和视图。Servlet连接前端和后端数据库，

## 搭建`SpringBoot`项目

1. 创建一个Maven项目
2. 在pom.xml中添加一个spring-boot-starter-parent父工程，再添加spring-boot-starter-web依赖
3. 在Java文件夹中创建一个包，包中创建启动类，该类需要添加`@SpringBootApplication`表示这时springBoot启动类
   同时添加main方法，main方法中添加`SpringApplication.run(当前类名.class, args);`
4. 在启动器类的包中添加controller包，并添加控制器类，然后在控制器类上添加`@RestController`表示这是一个控制器，在控制器中添加一个方法，返回值为String，方法上添加`@RequestMapping("/请求名")`表示接收指定的请求。方法中返回一个字符串用来在浏览器页面显示。
5. 启动main方法，并打开浏览器输入：
   `http://ip地址:端口/请求名`  完成测试

## 修改`SpringBoot`端口

在`resources`文件夹中新建一个`File`，命名为：`application.properties`
该文件中添加`server.port=新端口`
重新启动服务

# 2023年7月18日

## 面试题

ArrayList底层扩容原理：

它的底层是一个数组，长度默认为10，当调用add方法存入元素时，判断数组是否满了，如果满了，就造一个新的数组，长度是原数组的1.5倍，然后将原数组中的元素依次拷贝到新数组中，使用新数组。

~~~java
public interface List {

    void add(Object o);

    void add(int index, Object o);

    Object get(int index);

    int size();

    boolean isEmpty();

}
~~~

~~~java
public class ArrayList implements List {

    Object[] elementData;//集合底层的那个数组

    private int size;//当前集合对象中的元素个数

    public ArrayList(int count) {
        this.size = 0;
        elementData = new Object[count];
    }

    public ArrayList() {
        this.size = 0;
        elementData = new Object[4];
    }

    @Override
    public void add(Object o) {
        add(size, o);
    }

    @Override
    public void add(int index, Object o) {
        if (index < 0 || index > size) {
            throw new MyIndexOutOfBoundException("对不起数组越界");
        }
        //数组满了，需要扩容
        if (this.size == elementData.length) {
            grow();
        }
        //从指定的第index个位置开始，一次往后挪一格
        for (int i = size; i > index; i--) {
            elementData[i] = elementData[i - 1];
        }
        elementData[index] = o;
        size++;
    }

    @Override
    public Object get(int index) {
        if (index < 0 || index >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        return elementData[index];
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    private void grow() {
        //     //数组满了，需要扩容
        //     //1.造一个新数组newArray,长度是原数组的1.5倍
        //     Object[] newArray = new Object[elementData.length
        //             + (elementData.length >> 1)];//+-比移位优先级高
        //     //2.将就数组中的元素拷贝到新数组中
        //     for (int i = 0; i < elementData.length; i++) {
        //         newArray[i] = elementData[i];
        //     }
        //     //3.将就数组的引用指向新数组
        //     elementData = newArray;
        //以上代码可以通过下面一行来替代，使用Arrays帮助类中的copyOf方法
        elementData = Arrays.copyOf(elementData,
                elementData.length +
                        (elementData.length >> 1));
    }

    @Override
    public String toString() {
        String s1 = "[";

        String s2 = "]";
        if (0 == size) {
            return "[]";
        }
        StringBuffer stringBuffer = new StringBuffer("[");
        for (int i = 0; i < size - 1; i++) {
            stringBuffer.append(elementData[i] + ",");
        }

        stringBuffer.append(elementData[size - 1] + "]");
        return stringBuffer.toString();
    }
}
~~~

~~~java
public class Test8 {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(100);
        //list.add(200);
       // list.add(300);
       // list.add(3,500);
        System.out.println(list.get(0));
     //  System.out.println(list.get(1));
     //  System.out.println(list.get(2));
     //  System.out.println(list.get(3));
        System.out.println(list);
    }
}

~~~

## `SpringBoot`项目的一键部署

1. 打开`spring.io`网站，在顶端右边找到`Projects -> Spring Boot`在新页面，找到`LEARN -> 随便哪个版本的Reference.Doc -> 新页面左边蓝色字体找到Using SpringBoot -> 快捷键ctrl + F 搜索spring-boot-maven-plugin将该插件添加到pom.xml中`
2. 在Maven小窗口中的`lifeCycle`下拉菜单中双击`package`完成打包，控制台会告诉你包在什么路径
3. 使用`java -jar`命令直接启动该jar包即可，停止按`ctrl + c`

## `MySQL`数据库语法

### 分页查询

~~~sql
select 字段列表 from 表名 limit 起始条数, 每页条数;
-- for example
select * from fiction limit 6,3;
~~~

### 主键值自增长

建表语句中使用auto_increment实现，格式：

~~~plsql
create table 表名(
	字段名1 字段类型 auto_increment,
	字段名2 字段类型,
    ...
    PRIMARY KEY(主键字段)
)DEFAULT CHARSET = utf8;

-- for example
create table myuser0718(
	userid INTEGER auto_increment,
	username VARCHAR(20),
	userage INTEGER,
	PRIMARY KEY(userid)
)DEFAULT CHARSET=utf8;

~~~

### now()

当前系统时间

~~~~~plsql
select now(); -- 2023-07-18 16:55:35
~~~~~

### DATE_FORMAT(日期字段,日期格式) 

将日期型转字符串

~~~plsql
select f.fictionid,f.fictionname,DATE_FORMAT(f.createtime,'%Y-%m-%d %H:%i:%s') from fiction f;
~~~

# 2023年7月9日

## Vector

它也是List接口的实现类，它的底层是数组，Vector和ArrayList的区别：

1. Vector线程同步，效率低，ArrayList线程不同步，效率高。
2. ArrayList底层数组扩容原理是每次扩1.5倍，Vector底层数组扩容原理是根据指定的扩容量来扩容，如果没有指定扩容量，则原数组长度翻倍

## LinkedList

它也是List接口的实现类，它的底层是链表

**数组和链表的比较**：

- 数组查询快，新增删除慢
- 链表查询慢，新增删除快

#### 手写的单向链表

~~~java
public interface List {

    public int size();

    public boolean isEmpty();

    public void add(Object o);

    public void add(int i, Object o);

    public Object get(int i);
}
~~~

~~~java
public class LinkedList implements List {

    Node head = new Node();//头节点
    int size;//当前集合中的元素个数


    public LinkedList() {
        this.size = 0;
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    @Override
    public void add(Object o) {
        this.add(size, o);
    }

    @Override
    public void add(int i, Object o) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        //找位置
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        //创建一个新节点
        Node newNode = new Node(o);
        //让新节点指向p本来指向的下一个节点
        newNode.setNext(p.next);
        //P指向新节点
        p.next = newNode;
        //元素个数加一
        this.size++;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        return p.getValue();
    }

    @Override
    public String toString() {
        StringBuffer s = new StringBuffer("[");
        Node p = head.next;
        for (int i = 0; i < size - 1; i++) {

            if (i != size - 1) {
                s.append(p.getValue() + ",");
            } else {
                s.append((p.getValue()));
            }
            p = p.next;
        }
        s.append("]");
        return s.toString();
    }
}

~~~

~~~java
public class Node {
    Object value;//当前节点的值
    Node next;//下一个节点

    public Node(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node() {
    }

    public Node(Object value, Node next) {
        this.value = value;
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", next=" + next +
                '}';
    }
}

~~~

~~~java
public class MyIndexOutOfBoundException extends RuntimeException {

    public MyIndexOutOfBoundException() {

    }

    public MyIndexOutOfBoundException(String message) {
        super(message);
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {

        List list = new LinkedList();
//        list.add(100);
//        list.add(200);
//        list.add(300);
//        list.add(400);
//        list.add(500);

        System.out.println(list);

    }
~~~



### java.util包中的LinkedList

它使用双向链表来实现

# 2023年7月20日

## 栈

这是一个容器，它的存取数据操作时是受限的。特点：先进先出，后进后出

栈的操作：

push ---- 入栈

pop ----  出栈

peek ---- 获取栈顶元素，但不出栈

## 队列

是个容器，存储数据操作时受限
特点：先进先出，后进后出，入队要从队尾入队，出队要从队首出队

队列的操作：

enqueue ---- 入队

dequeue ---- 出队

peek ---- 获取队首元素

## 双端队列

这也是一个容器，它的队尾和队首分别都可以入队和出队操作

- 如果把某一端限定了不能入队出队，则变成了一个栈
- 如果对某一段限定了只能入队，另一端只能出队，则变成了普通队列

在Java中，我们使用Deque标识一个双端队列，LinkedList是Deque的实现类，所以我们可以使用LinkedList表示一个双端队列，Deque接口是Queue接口的子接口，Qeueu表示队列

~~~java
//10进制转2进制
        System.out.println("请输入一个10进制整数：");
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        //String str = "";
        Deque deque = new LinkedList();
        do {
            int mod = n % 2;
            //str = mod + str;
            deque.push(mod);
            //System.out.println(mod);
            n /= 2;
        } while (n > 0);
        sc.close();
        while (!deque.isEmpty()) {
            System.out.print(deque.pop());
        }
~~~

## 树

这是一个集合，是一种在层级关系上定义的集合。一棵普通的树，根节点只有一个，往下有子节点，子节点往下还有子节点

节点的度：某个节点拥有子树的数目称为节点的度

树的度：一棵树中节点的度的最大值

叶子节点：度为0的节点

节点的层次：从当前节点开始是第一层，其子树是第二层，直到最深的叶子节点的层数

树的深度：树中节点的最大层次树

节点之间的关系：父亲，儿子，兄弟，堂兄弟

有序树：如果将树中的各个子树看成从左至右是有次序的，则称为有序树，如果不考虑顺序，则是无序树

m叉树：一棵树的任意一个节点，往下最多有几个分支就是几叉树。

森林：若干个互不相交的树的集合

二叉树：每个节点的度均不超过2的有序树

满二叉树：每一层的节点数都要达到最大数（除了叶子节点）的二叉树

完全二叉树：在满二叉树的基础上，最下层，从最右侧起，去掉若干相邻的子节点得到的二叉树

二叉树的性质：终端节点的数量 = 度为2的节点数量 + 1

二叉树的遍历：

- 先序：根左右（先遍历根节点，然后遍历左子树，最后遍历右子树）
- 中序：左根右
- 后序：左右根

### 例题：

已知：
中序： 4 5 1 3 2 6 7
后序： 5 4 3 7 6 2 1
求先序：
思路步骤：

1. 看后序，得到1是根
2. 看中序，得到45是左孩子，3267是右孩子
3. 看后序，得到4是1的左孩子

先序：1 4 5....

4. 看中序，得到5是4的右孩子
5. 看后序，得到2是1的右孩子

先序：1 4 5 2 ....

6. 看中序，得到3是2的左孩子，67是2的右孩子

先序：1 4 5 2 3 ...

7. 看后序，得到6是7的根节点，所以6是2的右孩子

先序：1 4 5 2 3 6 7

8. 看中序，得到7是6的右孩子

### 面试题

二叉树的遍历：给出中序，先序后序给一个求另一个，

解题思路：先看先序或者后序，得到根，再看中序，得到根的左孩子或右孩子，再依次轮换着看先序或者后序和中序，然后画出实际的二叉树

### 手写二叉树

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689918641/javaStudy/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E4%BE%8B_lnreur.png](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689918641/javaStudy/二叉树示例_lnreur.png)

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:23
 * @email 1208195222@qq.com
 * @description 二叉树的接口
 */
public interface BinaryTree {

    //判断是否是空树
    public boolean isEmpty();

    //求节点数量
    public int size();

    //获取二叉树的高度
    public int getHeight();

    //查询指定的节点
    public Node findKey(Object value);

    //先序遍历
    public void preOrderTraverse();

    //中序遍历
    public void inOrderTraverse();

    //非递归的中序遍历
    public void inOrderTraverseByStack();

    //后序遍历
    public void postOrderTraverse();

    //从指定的某个节点开始进行先序遍历
    public void preOrderTraverse(Node node);

    //从指定的某个节点开始进行中序遍历
    public void inOrderTraverse(Node node);

    //从指定的某个节点开始进行后序遍历
    public void postOrderTraverse(Node node);

    //按照层次遍历
    public void levelOrderByStack();
}
~~~

~~~java
package com.iweb.test;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Queue;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:28
 * @email 1208195222@qq.com
 * @description	二叉树接口的实现类
 */
public class LinkedBinaryTree implements BinaryTree {
    Node root;

    @Override
    public String toString() {
        return "LinkedBinaryTree{" +
                "root=" + root +
                '}';
    }


    public LinkedBinaryTree() {
    }

    public LinkedBinaryTree(Node root) {
        this.root = root;
    }

    @Override
    public boolean isEmpty() {
        return this.root == null;
    }

    @Override
    public int size() {
        return this.size(root);
    }

    public int size(Node node) {
        if (node == null) {
            return 0;
        } else {
            int leftSize = this.size(node.leftChild);
            int rightSize = this.size(node.rightChild);
            return leftSize + rightSize + 1;
        }
    }

    @Override
    public int getHeight() {
        return this.getHeight(root);

    }

    public int getHeight(Node node) {
        if (node == null) {
            return 0;
        } else {
            int leftHeight = this.getHeight(node.leftChild);
            int rightHeight = this.getHeight(node.rightChild);
            return leftHeight > rightHeight ? (leftHeight + 1) : (rightHeight + 1);
        }

    }

    @Override
    public Node findKey(Object value) {
        return this.findKey(value, root);
    }

    public Node findKey(Object value, Node node) {
        if (node == null) {
            return null;
        } else if (node.value == value) {
            return node;
        } else {
            Node node1 = this.findKey(value, node.leftChild);
            Node node2 = this.findKey(value, node.rightChild);
            if (node1 != null && node1.value == value) {
                return node1;
            } else if (node2 != null && node2.value == value) {
                return node2;
            }
            return null;
        }
    }

    @Override
    public void preOrderTraverse() {
        this.preOrderTraverse(root);
    }

    @Override
    public void preOrderTraverse(Node node) {
        if (node != null) {
            System.out.print(node.value + " ");
            this.preOrderTraverse(node.leftChild);
            this.preOrderTraverse(node.rightChild);
        }

    }

    @Override
    public void inOrderTraverse() {
        this.inOrderTraverse(root);
    }

    @Override
    public void inOrderTraverseByStack() {
        System.out.println("非递归的中序遍历");
        //创建栈
        Deque<Node> stack = new LinkedList<>();
        Node current = root;
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.isEmpty()) {
                current = stack.pop();
                System.out.print(current.value + " ");
                current = current.rightChild;
            }
        }
    }

    @Override
    public void inOrderTraverse(Node node) {
        if (node != null) {
            this.inOrderTraverse(node.leftChild);
            System.out.print(node.value + " ");
            this.inOrderTraverse(node.rightChild);
        }

    }

    @Override
    public void postOrderTraverse() {
        this.postOrderTraverse(root);
    }

    @Override
    public void postOrderTraverse(Node node) {
        if (node != null) {
            this.postOrderTraverse(node.leftChild);
            this.postOrderTraverse(node.rightChild);
            System.out.print(node.value + " ");
        }

    }

    @Override
    public void levelOrderByStack() {
        System.out.println("按照层次遍历二叉树");
        if (root == null) {
            return;
        } else {
            Queue<Node> queue = new LinkedList<>();
            queue.add(root);
            while (queue.size() != 0) {
                int len = queue.size();
                for (int i = 0; i < len; i++) {
                    Node temp = queue.poll();
                    System.out.print(temp.value + " ");
                    if (temp.leftChild != null) {
                        queue.add(temp.leftChild);
                    }
                    if (temp.rightChild != null) {
                        queue.add(temp.rightChild);
                    }
                }
            }
        }
    }
}

~~~



~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:21
 * @email 1208195222@qq.com
 * @description     节点类
 */
public class Node {

    Object value;//自己的值
    Node leftChild;//左孩子地址
    Node rightChild;


    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", leftChild=" + leftChild +
                ", rightChild=" + rightChild +
                '}';
    }

    public Node() {
    }

    public Node(Object value, Node leftChild, Node rightChild) {
        this.value = value;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/21 9:01
 * @email 1208195222@qq.com
 * @description		测试lei
 */
public class Test2 {

    public static void main(String[] args) {
        Node node5 = new Node(5, null, null);
        Node node4 = new Node(4, null, node5);

        Node node7 = new Node(7, null, null);
        Node node6 = new Node(6, null, node7);

        Node node3 = new Node(3, null, null);
        Node node2 = new Node(2, node3, node6);

        Node node1 = new Node(1, node4, node2);

        LinkedBinaryTree lbt = new LinkedBinaryTree(node1);

        System.out.println(lbt);
        System.out.println(lbt.isEmpty());
        LinkedBinaryTree lbt2 = new LinkedBinaryTree();
        System.out.println(lbt2.isEmpty());

        System.out.println("先序遍历：");
        lbt.preOrderTraverse();
        System.out.println();
        System.out.println("中序遍历：");
        lbt.inOrderTraverse();
        System.out.println();
        System.out.println("后序遍历：");
        lbt.postOrderTraverse();
        System.out.println();
        System.out.println("树的深度：");
        System.out.println("height:" + lbt.getHeight());
        System.out.println("节点的个数：");
        System.out.print(lbt.size());
        System.out.println();
        System.out.println("在二叉树中查找");
        System.out.println(lbt.findKey(1));
        System.out.println();
        System.out.println("层次遍历：");
        lbt.levelOrderByStack();
        System.out.println();
        System.out.println("中序非递归遍历");
        lbt.inOrderTraverseByStack();

    }
}
~~~





## 递归算法

在一个方法的内部调用当前方法本身，它可以将一个复杂的问题层层转化为一个个相似的小问题来求解，**注意**：在写递归的时候必须要有结束调用的条件，否则就会出现栈内存溢出的错误。

~~~java
//求1加到100
    public static void main(String[] args) {

        System.out.println(myMethod(1));
    }

    public static int myMethod(int i) {
        int sum = 0;
        if (1 == i)
            return 1;
        else
            sum = i + myMethod(i - 1);
        return sum;

    }
//用高斯公式
    public static void main(String[] args) {
        System.out.println((1 + 100) * 100 / 2);
    }
~~~

## druid配置信息

写在application.propertie

~~~properties
server.port=8088

spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.url=jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8
spring.datasource.username=root
spring.datasource.password=123456
~~~

MySQL的URL要背下来：`jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8`

## 常用注解

@RestController ---- 这实际上包含了@ResponseBody 和 @Controller两个注解

@ResponseBody ---- 表示返回的数据直接以Json格式的字符串来表示

@Controller ---- 表示这是一个控制器，它能够接收请求，并且由Spring自动创建该类对象

@RequestMapping ---- 表示定义一个请求名，当接收到该请求名的请求时，触发代码执行

@Autowired ---- 需要使用某个对象的时候，无需自己创建，由Spring容器直接推送

@Service ---- 表示这是一个业务逻辑主键，也可以由Spring自动创建该类对象

@Mapper ---- 这是一个MyBatis注解，它可以自动创建该接口的实现类并创建实现类对象，然后自动调用对应的方法去执行对应的SQL语句

@RequestParam ---- 接收请求参数并赋值该控制器方法的形参

@ModelAttribute ---- 将请求参数中的参数值赋给控制器方法形参对象的成员变量，并将该形参对象绑定到Model中

@GetMapping ---- 在控制器方法上接收get请求：用于查询

@PostMaping ---- 在控制器方法上接收Post请求：用于新增

@PutMapping ---- 在控制器方法上接收Put请求：用于修改

@DeleteMapping ---- 在控制器方法上接收Delete请求：用于删除





在地址栏按回车键，发送的是get请求

#  2023年7月22日

**程序** ---- 用编程语言编写的计算机指令的集合，即代码

**进程** ---- 运行中的程序

**线程** ---- 进程中的一条执行路径

**多线程** ---- 多条执行路径同时执行

## Java中创建多线程的两种方式

1. 继承Thread类，并重写run方法，然后由该类对象调用start()方法启动一个新的线程来执行run方法中的代码

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是run方法，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main方法，我执行到了： " + i);
        }
    }
}
~~~

2.实现Runnable接口并重写run方法，然后创建该类对象当作参数传入Thread构造方法来创建Thread对象，并由Thread对象调用start方法，启动一个新的线程来执行run方法中的代码

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是MyRunnable类的方法，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
        }
    }
}
~~~

第二种方式比较好，因为Java是单继承多实现，所以我们应该尽可能将继承的机会留给业务逻辑

### 线程的状态：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689989834/javaStudy/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81_xxgpwz.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689989834/javaStudy/线程的五种状态_xxgpwz.jpg)

1. 使用new Thread() 对象创建线程
2. 调用start方法来使线程进入就绪状态
3. 通过`cpu`调度使线程在就绪和运行状态间切换
4. 运行过程中如果发生了突发事件，例如Scanner类的等待输入，线程进入阻塞状态
5. 突发事件结束，线程回到就绪状态
6. 运行过程中，代码运行结束则进入终止状态

### 常用方法

`Thread.sleep(毫秒数)` ---- 使当前线程休眠指定毫秒数的时间

`interrupt()` ---- 中断该线程，使其处于终止状态

~~~java
public class TestSleep implements Runnable {

    @Override
    public void run() {
        while (true) {
            System.out.println("===========" + new Date() + "===========");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("TestSleep线程终止");
                return;
            }
        }
    }
}

~~~

~~~java
public class Test2 {

    public static void main(String[] args) {
        TestSleep testSleep = new TestSleep();
        Thread thread = new Thread(testSleep);
        thread.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();

    }
}

~~~

`join()` ---- 使该线程合并到当前线程中，等待该线程执行结束，才继续执行当前线程，相当于单线程

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
        }
    }
}
~~~

`yield()` ---- 在运行过程中让出`cpu`资源，让自己处于就绪状态

`setName(名字)` ---- 给当前线程设置名字

`currentThread()` ---- 获取当前线程对象

`currentThread().getName()` ---- 获取当前线程的名字

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            if(i%10 == 0){
                Thread.yield();
            }
            System.out.println("我是" +Thread.currentThread().getName() + "，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        thread.setName("t1");

        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
            if (i % 10 == 0) {
                Thread.yield();
            }
        }
    }
}
~~~

`setPriority(级别)` ---- 设置线程优先级 

`getPriority()` ---- 获取线程优先级

注意：线程的优先级最高10，最低1，默认5

## 线程同步

当多个线程对同一个对象操作的时候，保证该对象数据一致性的一种机制叫做线程同步

线程不同步的例子：

~~~java
public class Time {
    static int count = 0;

    public void f(String str) {
        count++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(str + "你好，你是第 " + count + "个访问该对象的线程");
    }
}

~~~

~~~java
public class TestSync implements Runnable {
    Time time;

    public TestSync() {
        time = new Time();
    }

    @Override
    public void run() {
        time.f(Thread.currentThread().getName());
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {
        TestSync ts = new TestSync();

        Thread thread1 = new Thread(ts);
        Thread thread2 = new Thread(ts);

        thread1.setName("t1");
        thread2.setName("t2");

        thread1.start();
        thread2.start();
    }
}

~~~

输出结果：

~~~java
t2你好，你是第 2个访问该对象的线程
t1你好，你是第 2个访问该对象的线程
~~~

## synchronized

锁

1. 添加在方法声明处，表示当前对象在调用该方法时，锁定当前对象。某个线程在该对象上访问此方法时，其他线程无法在该对象上访问此方法。

~~~java
    public synchronized void f(String str) {
        count++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
~~~

2. 在某段代码上使用`synchronized(对象){}` 来控制这一段代码在被执行的过程中线程同步

~~~java
    public void f(String str) {
        synchronized (this) {
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(str + "你好，你是第 " + count + "个访问该对象的线程");
        }
    }
~~~

## 死锁

多个线程互相锁定着对方需要锁定的对象，导致都无法往下执行

例如：

~~~java
//简单来说，就是先锁定对象o1，然后睡觉，准备睡醒了锁o2,但是睡觉时o2被人su
public class TestDeadLock implements Runnable {

    private int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public int getFlag() {
        return flag;
    }

    public void setFlag(int flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag == 1) {
            synchronized (o1) {
                System.out.println("我是flag1，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (o2) {
                    System.out.println("我是flag1，我结束工作了");
                }
            }
        } else {
            synchronized (o2) {
                System.out.println("我是flag2，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("我是flag2，我结束工作了");
                }
            }
        }
    }
}

~~~

~~~java
public class Test {


    public static void main(String[] args) {
        TestDeadLock testDeadLock1 = new TestDeadLock();
        TestDeadLock testDeadLock2 = new TestDeadLock();

        testDeadLock1.setFlag(1);
        testDeadLock2.setFlag(2);

        Thread thread1 = new Thread(testDeadLock1);
        Thread thread2 = new Thread(testDeadLock2);

        thread1.start();
        thread2.start();
    }
}

~~~

**注意**：避免死锁的一个有效方式：将加锁的粒度加粗

~~~java
package com.iweb.test3;

/**
 * @author 童 淏
 * @createTime 2023/07/22 11:53
 * @email 1208195222@qq.com
 * @description
 */
public class TestDeadLock implements Runnable {

    private int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public int getFlag() {
        return flag;
    }

    public void setFlag(int flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag == 1) {
            synchronized (this) {
                System.out.println("我是flag1，我开始工作了");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("我是flag1，我结束工作了");
            }
        } else {
            synchronized (this) {
                System.out.println("我是flag2，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("我是flag2，我结束工作了");
            }
        }
    }
}

~~~

~~~java
package com.iweb.test3;

/**
 * @author 童 淏
 * @createTime 2023/07/22 11:54
 * @email 1208195222@qq.com
 * @description
 */
public class Test {


    public static void main(String[] args) {
        TestDeadLock testDeadLock1 = new TestDeadLock();
        testDeadLock1.setFlag(1);
        Thread thread1 = new Thread(testDeadLock1);
        thread1.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        testDeadLock1.setFlag(2);
        Thread thread2 = new Thread(testDeadLock1);
        thread2.start();
    }
}

~~~

**注意**：当某个线程访问了某个对象上某个加锁的方法时，其他线程完全可以访问该对象上其他没有加锁的方法。

~~~java
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("m1方法结束了");
    }

    public void m2() {
        System.out.println("我是m2方法");
        System.out.println(i);
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**注意**：没有加锁的方法会对当前对象上其他加锁的方法产生影响

~~~java
package com.iweb.test4;

/**
 * @author 童 淏
 * @createTime 2023/07/24 9:30
 * @email 1208195222@qq.com
 * @description
 */
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
        System.out.println("m1方法结束了");
    }

    public void m2() {
        System.out.println("我是m2方法");
        i = 2000;
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**注意**：多个加锁的方法在同一个对象的操作上互斥

~~~java
package com.iweb.test4;

/**
 * @author 童 淏
 * @createTime 2023/07/24 9:30
 * @email 1208195222@qq.com
 * @description
 */
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
        System.out.println("m1方法结束了");
    }

    public synchronized void m2() {
        System.out.println("我是m2方法");
        i = 2000;
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**总结**：在一个多线程的项目上，增删改的方法需要加锁，查询的方法不需要加锁

# 2023年7月24日

## Object类中提供的一些线程相关的方法

`wait()` ---- 等待，使当前线程阻塞

`notify()` ---- 唤醒当前对象上某个wait中的线程

`notifyAll()` ---- 唤醒当前对象上所有wait中的线程

## wait()和sleep()的区别

1. wait()在Object类，它往往等待别的线程调用notify()才能被唤醒
   sleep()在Thread类，它往往等待自己睡眠时间到了而被自动唤醒
2. 当某个线程处于sleep状态下，依然保留线程锁
   当某个线程处于wait状态下，会释放线程锁

## 生产者消费者（不是很重要）

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 10:44
 * @email 1208195222@qq.com
 * @description
 */
public class ManTou {

    private int id;

    @Override
    public String toString() {
        return "ManTou{" +
                "id=" + id +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public ManTou() {
    }

    public ManTou(int id) {
        this.id = id;
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 10:45
 * @email 1208195222@qq.com
 * @description
 */
public class ManTouStack {


    ManTou[] arrs = new ManTou[6];//馒头框

    int size;//当前框中的馒头数

    //往框中扔一个馒头
    public synchronized void push(ManTou mt) {
        while (size == arrs.length) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        arrs[size] = mt;
        size++;
        System.out.println("生产了:           " + mt);
    }

    //从框中拿一个馒头
    public synchronized ManTou pop() {
        while (size == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        size--;
        System.out.println("消费了：" + arrs[size]);
        return arrs[size];
    }
}




~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:15
 * @email 1208195222@qq.com
 * @description
 */
public class Producer implements Runnable {

    ManTouStack mts = null;

    public Producer(ManTouStack mts) {
        this.mts = mts;
    }

    public Producer() {
    }


    //生产
    @Override
    public void run() {
        for (int i = 0; i <= 20; i++) {
            ManTou manTou = new ManTou(i);
            mts.push(manTou);
            try {
                Thread.sleep((long) (Math.random()) * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


        }
    }


}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:18
 * @email 1208195222@qq.com
 * @description
 */
public class Consumer implements Runnable {

    ManTouStack mts = null;

    public Consumer() {
    }

    public Consumer(ManTouStack mts) {
        this.mts = mts;
    }


    //消费
    @Override
    public void run() {
        for (int i = 0; i <= 20; i++) {
            ManTou mt = mts.pop();
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:20
 * @email 1208195222@qq.com
 * @description
 */
public class Test {

    public static void main(String[] args) {
        ManTouStack mts = new ManTouStack();

        Producer p1 = new Producer(mts);
        Consumer c1 = new Consumer(mts);

        new Thread(p1).start();
        new Thread(c1).start();
    }
}

~~~

## `vue`

这是一个渐进式的前端框架

## 创建`vue`项目

`vue create 项目名`

## 启动`vue`项目

`cd 项目文件夹`

`npm run serve`

## 停止项目

`ctrl + c`

## `elementUI`

这是一个基于`vue`的网站快速生成工具

在`vue`项目中添加`elementUI`：

`vue add element`

## `Axios`

这是一个发送请求到后端的连接工具

安装`Axios`：

`cnpm install axios --save`

## `<router-link to="">`

这是`vue`中的页面跳转，to属性表示目标url

我们需要在`index.js`中配置跳转的url信息，对应to属性

## 嵌套路由

在某个主键中添加容器，路由器由children属性指向子页面，那么点击跳转的时候，子页面内容将被加载到容器中，而不是直接跳转。

## 内部样式表：

在当前页面上编写`css`代码，它的作用范围就是当前页面

## 外部样式表：

单独编写`css`文件，里面写`css`代码，在需要的页面上使用`@import url("css文件路径") `将其导入

## 全局样式表：

只需要在`index.html`的`<head>`中添加`<link rel="stylesheet" type="text/css" href="css文件路径"/>`即可实现全局样式，任何组件中都无序单独导入。

## 组件生命周期相关方法 

~~~javascript
		beforeCreate() {
			console.log("该组件即将创建");
		},
		created() {
			console.log("该组件创建完成");
		},
		beforeMount() {
			console.log("该组件即将渲染");
		},
		mounted() {
			console.log("该组件渲染完成");
		},
		beforeUpdate() {
			console.log("该组件即将被修改");
		},
		updated() {
			console.log("该组件修改完成");
		},
		beforeDestroy() {
			console.log("该组件即将被删除");
		},
		destroyed() {
			console.log("该组件删除完成");
		}
~~~

# 2023年7月25日

## 流

**流**就像一根根管道，管道的一端连接着当前计算机的CPU，另外一端连接着目标资源

数据就像管道中的水，从一个地方流到另外一个地方。

**IO** ---- input/output

流的分类：

1. 按照输入输出方向分为：输入流和输出流
   **面试题**
   写文件是输出
   读文件是输入
   （站在CPU角度看）
2. 按照数据传输的单位分为：字节流和字符流
3. 按照功能分为：节点流和处理流

流的Java类

`InputStream` ---- 字节输入流

`OutputStream` ---- 字节输出流

`Reader` ---- 字符输入流

`Writer` ---- 字符输出流

注意：所有的流都是继承自以上4个抽象类之一

`FileInputStream` ---- 文件字节输入流，用来读文件
read() ---- 读取文件中的一个字节，返回一个int值，如果读到末尾，则返回-1
close() ---- 关闭该输入流
`File.separator` ---- 当前操作系统的文件分隔符，在`windows`下是`\`，在`Linux`下是`/`

注意：实际开发的过程中，可以一律使用`/`，因为windows会自动将其转成`\`

~~~java
public class Test {

    public static void main(String[] args) {
        InputStream is = null;
        String path = File.separator;
        try {
            is = new FileInputStream("D:" + path + "java" + path + "MyProject" + path + "test20230725" + path + "src" + path + "com" + path + "iweb" + path + "test" + path + "Test.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

`FileOutputStream` ---- 文件字节输出流，用来写文件
write() ---- 往文件中写一个字节
close() ---- 关闭该输出流

~~~java
public class Test2 {

    public static void main(String[] args) {
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new FileInputStream("D:/java/MyProject/test20230725/src/com/iweb/test/Test.java");
            os = new FileOutputStream("D:/Desktop/Test2.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                os.write(i);
            }
            System.out.println("复制成功！");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
                if (os != null)
                    os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
//天下一番
~~~

`FileReader` ---- 文件字符输入流，用来读文件
read() ---- 读取文件中的一个字符，返回一个int值，如果读到末尾，则返回-1
close() ---- 关闭该输入流

~~~java
public class Test3 {

    public static void main(String[] args) {
        Reader reader = null;
        String path = File.separator;
        try {
            reader = new FileReader("D:" + path + "java" + path + "MyProject" + path + "test20230725" + path + "src" + path + "com" + path + "iweb" + path + "test" + path + "Test3.java");
            int i = 0;
            while ((i = reader.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null)
                    reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
//天下一番
~~~

`FileWriter` ---- 文件字符输出流，用来写文件
write() ---- 往文件中写一个字符
close() ---- 关闭该输出流

~~~java
public class Test4 {
    public static void main(String[] args) {
        Writer fw = null;
        try {
            fw = new FileWriter("D:/desktop/myunicode.txt");

            for (int i = 1; i < 50000; i++) {
                fw.write(i);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fw != null) {
                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

~~~

### 缓冲流

在内存开辟一块`8k`大小的缓冲区，当我们第一次读文件的时候，一次性读`8k`个内容到缓冲区，然后从缓冲区拿一个字节或字符进行使用，当缓冲区数据用完，才会再次访问硬盘读取`8k`数据，如此反复，极大地减少了对硬盘的访问次数，有效保护硬盘，并提高效率。

`BufferedInputStream `---- 字节缓冲输入流

~~~java
public class Test5 {

    public static void main(String[] args) {
        InputStream is = null;
        BufferedInputStream bis = null;
        String path = File.separator;
        try {
            is = new FileInputStream("D:" + path + "java" + path + "MyProject" + path +
                    "test20230725" + path + "src" + path + "com" + path +
                    "iweb" + path + "test" + path + "Test5.java");
            bis = new BufferedInputStream(is);
            int i = 0;
            while ((i = bis.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bis != null)
                    bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

`BufferedReader` ---- 字符缓冲输入流

`readLine()` ---- 可以读取一行的内容到一个字符串中

`BufferedWriter `---- 字符缓冲输出流

`write() `---- 写入一个字符串到缓冲区，如果缓冲区满了，自动写入硬盘

`newLine() `---- 另起一行

`flush()` ---- 清空缓冲区的内容并将其存入硬盘

~~~java
public class Test6 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = null;
        BufferedWriter bw = null;

        try {
            bw = new BufferedWriter(new FileWriter("D:/desktop/hello.txt"));
            br = new BufferedReader(new FileReader("D:/desktop/hello.txt"));
            for (int i = 0; i < 100; i++) {
                bw.write(String.valueOf(Math.random()));
                bw.newLine();
            }
            bw.flush();
            String s = null;
            while ((s = br.readLine()) != null) {
                System.out.println(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (br != null)
                    br.close();
                if (bw != null)
                    bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

## `Axios`发送请求

### `@CrossOrigin`

控制器类添加该注解可以解决前后端分离项目存在的跨域问题

get请求 ----` this.$axios.get(url)`

post请求 ----` this.$axios.post(url,参数的json字符串)`

我们使用`querystring`对象调用`stringify(json参数)`可以将json参数转json字符串

~~~js
		mounted() {
			console.log("该组件渲染完成");
            //查询全部
			this.$axios.get('http://127.0.0.1:8088/book/queryAll')
				.then(function(response) {
					console.log(response);
				})
				.catch(function(error) {
					console.log(error);
				});
            //新增一条
			this.$axios.post('http://localhost:8088/book', qs.stringify({
					bookname: '昆虫记',
					author: '法布尔'
				}))
				.then(function(response) {
					console.log(response)
				})
				.catch(function(error) {
					console.log(error)
				});


			//修改一条
			this.$axios.put('http://localhost:8088/book', qs.stringify({
					id: '1036',
					bookname: '晚明',
					author: '柯山梦'
				}))
				.then(function(response) {
					console.log(response)
				})
				.catch(function(error) {
					console.log(error)
				});
			//删除一条
			this.$axios.delete('http://localhost:8088/book/1037')
				.then(function(response) {
					console.log(response);
				})
				.catch(function(error) {
					console.log(error);
				});
		}
~~~

`SpringMVC`中的`@PathVariable`注解

可以绑定url中的占位符到方法形参，占位符需要使用一对大括号包起来

## 全局url配置

在`main.js`中添加`Axios.defaults.baseURL = 'http://ip地址:端口'`

每个发请求的地方直接从`"/"`开始写url即可，`"/"`表示web站点根目录

## 拦截器

我们在`Axios`中可以添加拦截器拦截所有的请求，来处理请求中的数据

格式：

~~~js
//main.js中添加：
Axios.interceptors.request.use(function (config){

......

})
~~~

`config.method ` ---- 表示请求方法

`config.data `---- 表示请求参数

`js`中 == 和 === 区别：
`js`中==只会比较数值是否相等，不考虑类型
===不仅要求数值相等，而且类型必须一样

## `<button>` ---- 按钮

`<button v-on:click="方法名">`  调用一个`js`方法

alert(字符串); ---- 弹出一个对话框，展示相应字符串

## 2023年7月26日

## `PrintWriter`

打印流

可以打印日志文件，它提供了各种重载的`print()`和`println()`方法用于打印，它只有输出没有输入，它不会抛异常

它自带缓冲区，他需要调用close()进行关闭

## `InputStreamRead`

这是一个字节流转字符流的桥梁，当传入一个字节流时，会返回对应的字符流。

~~~java
public class Test {

    public static void main(String[] args) {
        PrintWriter pw = null;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            pw = new PrintWriter(new FileWriter("D:/desktop/log.txt", true));
            String s = null;
            while ((s = br.readLine()) != null) {
                if ("exit".equals(s))
                    break;

                System.out.println(s);
                pw.println(s);
                pw.println("====================");
            }

            pw.println("================" + new Date() + "================");
            pw.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (pw != null)
                pw.close();

        }

    }
}
~~~

## UTF-8

这是一种编码格式 ---- 可变长度的Unicode编码

## Socket

套接字

这是客户端的插座，它可以获取连接服务器的输入输出流

## `ServerSocket`

这是服务器端的插座，它可以接收来自客户端的请求，

accept() ---- 这是一个阻塞的方法，他可以等待并获取来自某个客户端的Socket对象，然后获取该客户端的输入输出流

服务器必须先启动，然后等待，由客户端主动发送请求，客户端在`OutputStream`中写入数据，服务器在`InputStream`中接收数据

`DataInputStream和DataOutputStream`

数据流

它可以在网络上进行`UTF-8`数据格式的传输

简单客户端服务器：

~~~java
//服务器
public class MyServer {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        DataInputStream dataInputStream = null;
        Socket socket = null;

        DataOutputStream dataOutputStream = null;

        try {
            serverSocket = new ServerSocket(9527);
            while (true) {
                socket = serverSocket.accept();
                InputStream inputStream = socket.getInputStream();
                dataInputStream = new DataInputStream(inputStream);
                String str = dataInputStream.readUTF();
                System.out.println(str);


                //向客户端回信息
                //OutputStream outputStream = socket.getOutputStream();
                //dataOutputStream = new DataOutputStream(outputStream);
                //dataOutputStream.writeUTF("hello client,this is your server");
                (new DataOutputStream(socket.getOutputStream())).writeUTF(
                        "hello client,this is your server");
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dataInputStream != null)
                    dataInputStream.close();
                if (dataOutputStream != null)
                    dataOutputStream.close();
                if (serverSocket != null)
                    serverSocket.close();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
//客户端
public class MyClient {
    public static void main(String[] args) {
        Socket socket = null;
        DataOutputStream dataOutputStream = null;
        DataInputStream dataInputStream = null;

        try {
            socket = new Socket("127.0.0.1", 9527);
            OutputStream outputStream = socket.getOutputStream();
            dataOutputStream = new DataOutputStream(outputStream);
            dataOutputStream.writeUTF("hello");


            //接收服务器发来的消息
            dataInputStream = new DataInputStream(socket.getInputStream());
            String str = dataInputStream.readUTF();
            System.out.println(str);


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dataOutputStream != null)
                    dataOutputStream.close();
                if (dataInputStream != null)
                    dataInputStream.close();
                if (socket != null)
                    socket.close();


            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
~~~

## 反射

当某个类被加载到内存的时候，JVM会自动创建该类的Class对象，这就是它的反射对象，反射对象就像是一面镜子一样照射着当前正在加载的这个类，把类结构看得清清楚楚，它可以帮助我们创建该加载类对象，访问成员变量，调用方法。

获取Class对象的方式：

1. 对象名.getClass();
2. 类名.class
3. Class.forName("加载类的全类名")

~~~java
    public static void main(String[] args) {
        //方法1
        Person p = new Person();
        Class c1 = p.getClass();
        System.out.println(c1);
        //方法2
        Class c2 = Person.class;
        System.out.println(c2);
        //方法3
        Class c3 = null;
        try {
            c3 = Class.forName("com.iweb.test.Person");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

    }
~~~

**注意**：一个类只有唯一的一个Class对象

newInstance() ---- 反射对象调用该方法来创建加载类对象 **注意：**实际调用的是该加载类的无参构造方法

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~

打印结果：

~~~java
我是无参构造方法
com.iweb.test.Person@14ae5a5
~~~

## Field

这表示一个加载类的某个成员变量的对象

1. 如果成员变量是public
   我们使用Class对象.getField(成员变量名)就可以获取该Field对象

2. 如果成员变量是非public
   我们使用Class对象.getDeclaredField(成员变量名)就可以获取该Field对象，然后由Field.setAccessible(true)进行授权即可

我们使用Field对象.set(加载类的对象，成员变量值) ---- 可以给该对象的成员变量赋属性值

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
            Field f1 = p1.getClass().getField("pname");
            f1.set(p1, "张三");
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~



~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
            Field f1 = c1.getField("pname");
            f1.set(p1,"张三");
            System.out.println(p1);
            Field f2 = c1.getDeclaredField("page");
            f2.setAccessible(true);
            f2.
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~





# 2023年7月27日



## Method类

表示加载类的方法，每个方法在反射看来都是一个Method对象，我们可以使用Class对象调用getMethod(方法名)来获取Method对象，然后使用Method对象.invoke(加载类对象)来完成加载类方法的调用。

~~~java
            Method m1= c1.getMethod("info");
            m1.invoke(p1);
~~~

如果方法带有参数，那么在获取Method对象时，我们需要传入参数的Class对象，同时调用invoke方法时，需要传入参数值。

~~~java
    public void display(String str) {
        System.out.println("我是" + str + "人");
    }
~~~

~~~java
            Method m2 = c1.getMethod("display",String.class);
            m2.invoke(p1,"中国");
~~~

## Field

在Java中，Field类是反射（reflection）机制的一部分，它代表了一个类的成员变量（字段）。通过Field类，我们可以在运行时获取类的字段信息，并对这些字段进行读取和写入操作，即使在编译时并不知道这些字段的名称或类型。

## getFields

通过反射对象获取加载类中的public成员变量的Field数组

`Class c = Person.class;`

`Field[] fields = c.getFields();`

## getDeclaredFields

通过反射对象获取加载类中所有成员变量的Field数组

~~~java
            Field[] fields = c1.getFields();
            System.out.println("一共有" + fields.length + "个public成员变量，他们分别是：");
            for (Field f : fields) {
                System.out.println(f);
            }

            Field[] fields2 = c1.getDeclaredFields();
            System.out.println("一共有" + fields2.length + "个成员变量，他们分别是：");
            for (Field f : fields2) {
                System.out.println(f);
            }
~~~

## getMethods()

通过反射对象获取加载类中方法的Method数组，包括它的父类的**公共**方法

## getDeclaredMethods()

通过反射对象获取加载类中方法的Method数组，不包括它的父类的任何方法。

~~~java
            Method[] methods = c1.getMethods();
            System.out.println("一个有：" + methods.length + "个方法，他们分别是：");
            for (Method m : methods) {
                System.out.println(m);
            }

            Method[] methods2 = c1.getDeclaredMethods();
            System.out.println("一共有：" + methods2.length + "个自己声明的方法，他们分别是：");
            for (Method m : methods2) {
                System.out.println(m);
            }
~~~

## Constructor

这是反射包中一个用来表示构造方法的类，我们通过反射对象调用getConstructors获取构造方法的数组

~~~java
            Constructor[] constructors = c1.getConstructors();
            System.out.println("一共有：" + constructors.length + "个构造方法，他们分别是：");
            for (Constructor c : constructors) {
                System.out.println(c);
            }
~~~

我们可以通过getConstructor(参数的Class对象列表)可以获取有参构造方法的Constructor对象，再由该对象调用newInstance()传入参数值，即可调用有参构造方法创建加载类对象

~~~java
            Constructor<Person> constructor = c1.getConstructor(String.class,int.class);
            Person p2 = constructor.newInstance("李四",20);
            System.out.println(p2);
~~~

## 设计模式

### 单例模式

一个类只能创建一个对象

格式：

1、饿汉模式编写：

构造方法私有化，提供一个`private static final 当前类型的`成员变量赋值为当前类对象

对外提供一个`public static 当前类型返回值`的方法供别人调用，返回该成员变量

~~~java
public class Singleton01 {

    private static final Singleton01 only = new Singleton01();
    
    private Singleton01() {
    }
    
    public static Singleton01 singleton01Factory() {
        return only;
    }
}

~~~

~~~java
public class Test {
    public static void main(String[] args) {
        Singleton01 s1 = Singleton01.singleton01Factory();
        Singleton01 s2 = Singleton01.singleton01Factory();
        System.out.println(s1 == s2);//s1和s2内存地址相同，是同一个对象
    }
}
~~~

2、懒汉模式编写：

构造方法私有化，提供一个`private static 当前类型的`成员变量赋值null

对外提供一个`public static 当前类型返回值的`方法供别人调用，判断成员变量是否为null，如果为null则调用构造方法创建该类对象，返回成员变量

**注意**：懒汉模式需要做线程同步，饿汉不需要

~~~java
public class Singleton02 {
    private static Singleton02 only = null;

    private Singleton02() {
    }


    public synchronized static Singleton02 singleton02Factory() {
        if (only == null)
            only = new Singleton02();
        return only;
    }

}
~~~

~~~java
        Singleton02 s3 = Singleton02.singleton02Factory();
        Singleton02 s4 = Singleton02.singleton02Factory();
        System.out.println(s3 == s4);//s3 和 s4是同一个对象
~~~

### 工厂模式

一个工厂类把创建实体的过程进行了封装，当用户需要一个实体类对象的时候，无需自己创建，由工厂类直接提供

1、静态工厂模式

首先提供一个Map集合的成员变量，用来存放产品对象

然后提供一个static静态代码块用来创建若干产品对象，并存入Map集合中，对外提供一个public的工厂方法，根据需求返回Map中某个产品对象

~~~java
public class Car {
    private String cno;
    private String brand;
    private String maxSpeed;

    public Car() {
    }

    public String getCno() {
        return cno;
    }

    public void setCno(String cno) {
        this.cno = cno;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(String maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public Car(String cno, String brand, String maxSpeed) {
        this.cno = cno;
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }

    @Override
    public String toString() {
        return "Car{" +
                "cno='" + cno + '\'' +
                ", brand='" + brand + '\'' +
                ", maxSpeed='" + maxSpeed + '\'' +
                '}';
    }
}

~~~

~~~java
public class CarFactory01 {


    private static Map<String, Car> map = new HashMap<>();

    //静态代码块，类加载的时候执行
    static {
        Car car01 = new Car("1001", "Audi", "240");
        Car car02 = new Car("1002", "Ford", "220");
        Car car03 = new Car("1003", "Volvo", "240");
        map.put(car01.getCno(), car01);
        map.put(car02.getCno(), car02);
        map.put(car03.getCno(), car03);
    }

    public static Car getCar(String cno) {
        return map.get(cno);
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {
        Car car1 = CarFactory01.getCar("1001");
        System.out.println(car1);
        Car car2 = CarFactory01.getCar("1002");
        System.out.println(car2);
    }
}

~~~

2、实例工厂模式

首先提供一个Map集合的成员变量用来存放产品对象

然后提供一个构造方法用来造一个工厂

还要提供一个生产的方法用来生产产品并存入Map

对外提供一个public工厂方法根据需求返回Map中某个产品对象

~~~java
public class CarFactory02 {


    private static Map<String, Car> map = new HashMap<>();

    public CarFactory02() {
        produce();
    }

    //静态代码块，类加载的时候执行
    void produce() {
        Car car01 = new Car("1001", "Audi", "240");
        Car car02 = new Car("1002", "Ford", "220");
        Car car03 = new Car("1003", "Volvo", "240");
        map.put(car01.getCno(), car01);
        map.put(car02.getCno(), car02);
        map.put(car03.getCno(), car03);
    }

    public  Car getCar(String cno) {
        return map.get(cno);
    }
}

~~~

~~~java
public class Test2 {
    public static void main(String[] args) {
        CarFactory02 carFactory02 = new CarFactory02();//造一座工厂
        Car car2 = carFactory02.getCar("1003");
        System.out.println(car2);
    }
}

~~~

### 代理模式

围绕主体业务提供周边的辅助业务，并且完成主体业务的一种设计模式。

首先提供一个统一的完整业务接口给主体类和代理类分别实现。

然后需要主体类提供主体业务方法

最后提供一个代理类，包含主体类的成员变量，可以调用主体类的主体方法。并提供额外的相关业务

用户只需要面向代理类即可完成整个业务

~~~java
public class Car {
    private String carName;
    private int carPrice;

    public Car() {
    }

    public Car(String carName, int carPrice) {
        this.carName = carName;
        this.carPrice = carPrice;
    }

    @Override
    public String toString() {
        return "Car{" +
                "carName='" + carName + '\'' +
                ", carPrice=" + carPrice +
                '}';
    }
}

~~~

~~~java
public interface SaleCar {
    public Car getCar(String cno);
}

~~~

~~~java
public class CarFactory implements SaleCar {

    private static Map<String, Car> map = new HashMap<>();

    public CarFactory() {
        createCar();
    }

    void createCar() {
        map.put("宝马", new Car("宝马", 50_0000));
        map.put("奥迪", new Car("奥迪", 30_0000));
        map.put("迈巴赫", new Car("宝马", 1250_0000));

    }


    @Override
    public Car getCar(String carName) {

        return map.get(carName);
    }
}

~~~

~~~java
public class Car4S implements SaleCar{

    @Override
    public Car getCar(String carName) {
        System.out.println("销售");
        CarFactory carFactory = new CarFactory();
        return carFactory.getCar(carName);
    }
}
~~~

~~~java
public class Test {


    public static void main(String[] args) {
        Car4S car4S  = new Car4S();
        System.out.println(car4S.getCar("迈巴赫"));
    }
}
~~~





# 2023年7月28日

## JDBC

这是Java连接数据库的标准接口

操作步骤

1. 加载数据库驱动
2. 获取数据库连接
3. 获取Statement对象
4. 执行sql语句
5. 处理查询结果
6. 关闭连接和资源

~~~java
//连接Oracle数据库中dept表
//数据库ip：192.168.77.100  端口： 1521  数据库服务名：helowin
//账号：scott  密码：123456 
public class JdbcExample {
    public static void main(String[] args) {
        String url = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
        String username = "scott";
        String password = "123456";

        Connection conn = null;//表示数据库的连接
        Statement stat = null;//表示操作SQL语句的对象
        ResultSet rest = null;//表示接收结果集的对象


        try {
            //加载数据库驱动，把Oracle驱动类手动加进内存
            Class.forName("oracle.jdbc.driver.OracleDriver");
            //获取数据库连接
            conn = DriverManager.getConnection(url, username, password);
            //获取Statement对象
            stat = conn.createStatement();
            //执行SQL语句并返回结果
            String sql = "select * from dept";
            rest = stat.executeQuery(sql);
            //循环遍历结果集并使用数据
            while (rest.next()) {
                int deptno = rest.getInt("deptno");
                String dname = rest.getString("dname");
                String loc = rest.getString("loc");
                System.out.println(deptno + ":" + dname + ":" + loc);
            }


        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭连接和资源
                if (rest != null)
                    rest.close();
                if (stat != null)
                    stat.close();
                if (conn != null)
                    conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

打印结果：

~~~java
12:喝酒部:伊豆
70:人事部:伤害
10:ACCOUNTING:NEW YORK
20:RESEARCH:DALLAS
30:SALES:CHICAGO
40:OPERATIONS:BOSTON
50:轻音部:霓虹111
~~~



## ResultSetMetaData

(好处就是可以打印列名)

表示RestSet中列相关的信息，我们可以通过

RestSet.getMetaData() ---- 获取它的对象。

getColumnCount() ---- 得到列数

getColumnName(列数) ---- 得到某一列的字段名

~~~java
public class Test {

    public static void main(String[] args) {
        String url = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
        String username = "scott";
        String password = "123456";

        Connection conn = null;
        Statement stat = null;
        ResultSet rest = null;
        ResultSetMetaData rsmd = null;

        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");

            conn = DriverManager.getConnection(url, username, password);

            stat = conn.createStatement();

            String sql = "select * from dept";
            rest = stat.executeQuery(sql);

            rsmd = rest.getMetaData();
            int columnCount = rsmd.getColumnCount();
            while (rest.next()) {
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = rsmd.getColumnName(i);
                    Object columnValue = rest.getObject(i);
                    System.out.print(columnName + "=" + columnValue + "    ");

                }
                System.out.println();
            }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null)
                    rest.close();
                if (stat != null)
                    stat.close();
                if (conn != null)
                    conn.close();

            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

打印结果

~~~java
DEPTNO=12    DNAME=喝酒部    LOC=伊豆    
DEPTNO=70    DNAME=人事部    LOC=伤害    
DEPTNO=10    DNAME=ACCOUNTING    LOC=NEW YORK    
DEPTNO=20    DNAME=RESEARCH    LOC=DALLAS    
DEPTNO=30    DNAME=SALES    LOC=CHICAGO    
DEPTNO=40    DNAME=OPERATIONS    LOC=BOSTON    
DEPTNO=50    DNAME=轻音部    LOC=霓虹111  
~~~

## executeUpdate(SQL语句)

由Statement对象调用该方法，执行增删改语句

~~~java
public class Test2 {
    public static void main(String[] args) {
        Connection conn = null;//表示数据库的连接
        Statement stat = null;//表示操作SQL语句的对象
        try {
            //加载数据库驱动，把Oracle驱动类手动加进内存
            Class.forName("oracle.jdbc.driver.OracleDriver");
            //获取数据库连接
            conn = DriverManager.getConnection(
                    "jdbc:oracle:thin:@192.168.77.100:1521:helowin",
                    "scott",
                    "123456");
            //获取Statement对象
            stat = conn.createStatement();
            //执行SQL语句并返回结果
            String sql = "insert into dept values('60','运维部','北京')";
            int i = stat.executeUpdate(sql);
            System.out.println("成功编辑了 " + i + " 条记录");
            
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {

                if (stat != null)
                    stat.close();
                if (conn != null)
                    conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

## 断点调试

我们在程序入口处打断点，使用Debug方式运行，程序会在断点处停下来，我们可以单步调试，如果调用方法，那么可以使用setup into进入所调用的方法继续调试，我们还可以使用resume program一次性走到下一个断点，如果没有下一个断点，则直接走完。

在调试的过程中，我们可以选中公式或表达式，点击Evalute Expression进行取值的查看，

## CallableStatement

用来调用存储过程，我们通过Connection对象调用`prepareCall("{call 存储过程名(?,?,?,...)}")`来获取该对象，然后通过`该对象.setXxx(序号，值)`给存储过程赋参数值，最后调用`execute()`来执行存储过程

~~~java
public class Test4 {
    public static void main(String[] args) {
        Connection conn = null;//表示数据库的连接
        CallableStatement stat = null;//表示操作SQL语句的对象
        try {
            //加载数据库驱动，把Oracle驱动类手动加进内存
            Class.forName("oracle.jdbc.driver.OracleDriver");
            //获取数据库连接
            conn = DriverManager.getConnection(
                    "jdbc:oracle:thin:@192.168.77.100:1521:helowin",
                    "scott",
                    "123456");
            //获取Statement对象
            stat = conn.prepareCall("{call my_pro(?,?,?)}");
            stat.setInt(1, 70);
            stat.setString(2, "人事部");
            stat.setString(3, "伤害");
            stat.execute();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {

                if (stat != null)
                    stat.close();
                if (conn != null)
                    conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

## confirm("字符串")

弹出一个确认框，当用户点击确定时，返回true，当用户点击取消时，返回false

## JDBC方法封装

~~~java
public class JdbcUtil {
    private static final String URL = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
    private static final String USERNAME = "scott";
    private static final String PASSWORD = "123456";

    private static Connection conn = null;
    private static Statement stat = null;
    private static ResultSet rest = null;

    public JdbcUtil() {

    }

    //获取数据库连接
    public static Connection getConn() {
        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");
            conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    //关闭所有资源和连接
    public static void closeSource() {
        try {
            if (rest != null)
                rest.close();
            if (stat != null)
                stat.close();
            if (conn != null)
                conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /*
    统一进行查询的JDBC方法
     */
    public static List<Map<String, Object>> queryBySql(String sql) {
        List<Map<String, Object>> list = new ArrayList<>();

       
        ResultSetMetaData rsmd = null;
        try {
            stat = getConn().createStatement();
            rest = stat.executeQuery(sql);
            rsmd = rest.getMetaData();
            while (rest.next()) {
                Map<String, Object> map = new HashMap<>();
                for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                    map.put(rsmd.getColumnName(i), rest.getObject(i));
                }
                list.add(map);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null)
                    rest.close();
                closeSource();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return list;
    }

    /*
    增删改
     */
    public static void editBySql(String sql) {
        try {
            stat = getConn().createStatement();
            int i = stat.executeUpdate(sql);
            System.out.println("成功编辑了" + i + "条记录");
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            closeSource();
        }
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {
       String sql = "delete from dept where deptno = 70";
       JdbcUtil.editBySql(sql);

//        String sql2 = "select * from dept";
//        System.out.println(JdbcUtil.queryBySql(sql2));
    }
}

~~~

## JDBC连接MySQL

只需要更改url、username、password、Class.forName()

~~~java
    private static final String URL =
            "jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "123456";
~~~

~~~java
            Class.forName("com.mysql.cj.jdbc.Driver");
~~~

## 模拟登录

~~~java
public class LoginService {
    public boolean login(String username, String password) {
        password = DigestUtils.md5Hex(password);
        String sql = "select count(*) cou from my_user where username = '" + username
                + "' and password = '" + password + "'";
        List<Map<String, Object>> list = JdbcUtil2.queryBySql(sql);
        Map<String, Object> map = list.get(0);
        Long rest = (Long) map.get("cou");
        return rest > 0;
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {

        String username = "root1";
        String password = "123456";
        LoginService loginService = new LoginService();
        if (loginService.login(username, password)) {
            System.out.println("登录成功！");
        } else {
            System.out.println("用户名或密码错误！");
        }

    }
}
~~~

## SQL注入

当参数值直接被拼到SQL语句中时，人为地传入部分SQL语句作为参数，可以绕过条件判断，达到查询的目的

~~~java
//使用SQL注入登录
public class Test {

    public static void main(String[] args) {

        String username = "1' or '1'='1' or '1'='1";//SQL注入
        String password = "123456";
        LoginService loginService = new LoginService();
        if (loginService.login(username, password)) {
            System.out.println("登录成功！");
        } else {
            System.out.println("用户名或密码错误！");
        }

    }
}
~~~

# 2023年7月31日

## PreparedStatement

和Statement对象类似，它也可以执行SQL语句

通过Connection调用prepareStatement(SQL语句)得到该对象

它采用参数绑定的方式来封装SQL语句，SQL语句中所有有参数的地方使用`?`

该对象调用setXxx(序号n，参数值)用来给第n个位置的`?`绑定参数值

他可以有效防止SQL注入

~~~java
//防止SQL注入，并且能传入多个参数的最终JDBC工具类
public class JdbcUtil2 {
    private static final String URL =
            "jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "123456";

    private static Connection conn = null;
    private static PreparedStatement pstat = null;
    private static ResultSet rest = null;

    public JdbcUtil2() {

    }

    //获取数据库连接
    public static Connection getConn() {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    //关闭所有资源和连接
    public static void closeSource() {
        try {
            if (rest != null)
                rest.close();
            if (pstat != null)
                pstat.close();
            if (conn != null)
                conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /*
    统一进行查询的JDBC方法
     */
    public static <T> List<Map<String, Object>> queryBySql(String sql, T... t) {
        List<Map<String, Object>> list = new ArrayList<>();

        ResultSetMetaData rsmd = null;
        try {
            pstat = getConn().prepareStatement(sql);
            for (int i = 0; i < t.length; i++) {
                pstat.setObject(i + 1, t[i]);
            }
            rest = pstat.executeQuery();
            rsmd = rest.getMetaData();
            while (rest.next()) {
                Map<String, Object> map = new HashMap<>();
                for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                    map.put(rsmd.getColumnName(i), rest.getObject(i));
                }
                list.add(map);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null)
                    rest.close();
                closeSource();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return list;
    }

    /*
    增删改
     */
    public static <T> void editBySql(String sql, T... t) {
        int result = 0;
        try {
            pstat = getConn().prepareStatement(sql);
            for (int i = 0; i < t.length; i++) {
                pstat.setObject(i + 1, t[i]);
            }
            result = pstat.executeUpdate();
            System.out.println("成功编辑了" + result + "条记录");
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            closeSource();
        }
    }
}
~~~

~~~java
public class LoginService {
    public boolean login(String username, String password) {
        password = DigestUtils.md5Hex(password);
        String sql = "select count(*) cou from my_user where username = ? and password = ?";
        List<Map<String, Object>> list = JdbcUtil2.queryBySql(sql,username,password);
        Map<String, Object> map = list.get(0);
        long rest = (long) map.get("cou");
        System.out.println(rest);


        return rest > 0;
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {
//        String username = "root";
//        //String username = "1' or '1'='1' or '1'='1";//SQL注入
//        String password = "123456";
//        LoginService loginService = new LoginService();
//        if (loginService.login(username, password)) {
//            System.out.println("登录成功！");
//        } else {
//            System.out.println("用户名或密码错误！");
//        }

//
        String sql = "insert into mybook values(null,?,'')";
        JdbcUtil2.editBySql(sql,"海的房间","黄利群");


    }
}

~~~

