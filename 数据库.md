### 数据库表结构的设计：

找名词，将名词分为 实体和属性

每个实体一张表，每个属性一个字段

确定表与表的关系：

- 一对一： 将一张表的编号字段添加到另一张表中作为关键字段
- 一对多：将一的一端的编号添加到多的一端表中作为关联字段
- 多对多：新建一张关系表，它记录着两端的编号

 ER图 ---- 这是一个数据库表结构设计的辅助工具 矩形表示表，椭圆表示字段，菱形表示关系

员工关系系统需求：公司的每个部门中包含各自的员工，部门需要统计编号，名称所在地。员工需要统计编号，姓名

#### 范式：数据库表设计的规范

- 第一范式：列不可分
- 第二范式：要有主键，不存在部分依赖
- 第三范式：不存在传递依赖

# 日期 2022/7/16

### sql

对数据库操作的标准语言

DDL ---- 数据定义语言：针对数据库对象进行操作的语言

DML ---- 数据操纵语言：针对数据进行操作的语言

#### 创建一张表：

~~~~plsql
create table 表名(
    字段名1 类型,
    字段名2 类型,
    ...
)
~~~~

#### 插入一条记录：

~~~plsql
insert into 表名(字段名1,字段名2,...)values('值1','值2',...)
-- 注意：values前面的小括号决定了要对那些字段插值，如果对所有的字段插值，则values前面的小括号可以省略不写
insert into cominfo0716
  (cno, cname, phone, address, email)
values
  ('1001', '张三', '123655', '江苏省', '12@qq.com');
~~~

#### 查询记录：

~~~plsql
select 字段列表 from 表名  
-- 注意：* 表示所有字段
select * from COMINFO0716 t
~~~

#### 删除记录：

~~~plsql
delete from 表名 where 条件
delete from cominfo0716 where cno = '1001';
~~~

#### 删除表：

~~~plsql
drop table 表名
~~~

#### Oracle中的数据类型：

- `varchar(长度)` ---- 不定长的字符串
- `integer` ---- 整型
- `date` ---- 日期型
- `number(长度,小数位)` ---- 浮点型
- `to_date('日期字符串','日期格式')` ---- 将字符串转日期型，在日期格式中y表示年，m表示月，d表示日

~~~plsql
create table cominfo0716(
       cno varchar2(20),
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2)
);

insert into cominfo0716
values
  ('1003',
   '王五',
   '14343655',
   '江苏省',
   '12111@qq.com',
   '1208196222',
   to_date('1998-07-01', 'yyyy-mm-dd'),
   '70.75');
~~~

h表示小时

mi表示分钟

s表示秒

~~~plsql
insert into cominfo0716
values
  ('1005',
   '赵六',
   '14343655',
   '江苏省',
   '12111@qq.com',
   '1208196222',
   to_date('1998-07-01 20:03:08', 'yyyy-mm-dd hh24:mi:ss'),-- hh24表示24小时制 hh表示12小时制
   '117.714111');-- 超出精度的小数会自动四舍五入 超出精度的整数会报错
~~~

#### 修改记录：

~~~plsql
update 表名 set 字段名1 = 新值,字段名2 = 新值2...
where 条件语句
~~~

#### 约束：

限定表中的数据必须满足某种要求

- not null ---- 该字段值不能为空
- unique ---- 唯一约束，该字段值不能重复

~~~plsql
create table cominfo0716(
       cno varchar2(20) not null,-- 该字段值不能为空
       cname varchar2(20),
       phone varchar2(20) unique, -- 该字段值不能重复
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2)
);
~~~

~~~plsql
-- 注意：还可以使用constraint 自定义名字 unique() 表示该字段唯一
create table cominfo0716(
       cno varchar2(20) not null,
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2),
       constraint uk0716 unique(phone) -- 表示该字段唯一
);
~~~

- primary key ---- 主键约束，它包含了非空和唯一

  注意：还可以使用 constraint 自定义名字 primary key(字段)表示该字段为主键；

~~~plsql
create table cominfo0716(
       cno varchar2(20) primary key,
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2),
       constraint uk0716 unique(phone)
);


create table cominfo0716(
       cno varchar2(20),
       cname varchar2(20),
       phone varchar2(20),
       address varchar2(200),
       email varchar2(32),
       qq integer,
       birthday date,
       weight number(5,2),
       constraint uk0716 unique(phone),
       constraint uk0716 primary key(cno)-- 小括号里如果是多个字段则为联合主键
);
~~~

- 外键约束 ---- 将被关联表的主键字段添加到当前表中当作外键，两层约束：

  1. 当插入从表中的数据时，其外键值必须存在于主表中
  2. 当删除主表中的数据时，其主键值必须没有被从表关联

  语法：在外键字段后添加 references 主表名(主表主键名)

~~~plsql
create table class0716(
cno varchar2(32) primary key,
cname varchar2(32)
);

create  table student0716(
sno varchar2(32) primary key,
sname varchar2(32),
sage integer,
cno varchar2(32) references class0716(cno)
);
~~~

~~~plsql
-- 注意：也可以使用constraint 自定义名称 foreign key(字段名) references 主表名(主表主键名) 来创建外键
create  table student0716(
sno varchar2(32) primary key,
sname varchar2(32),
sage integer,
cno varchar2(32),
constraint fk0716 foreign key(cno) references class0716(cno)
);
~~~

# 日期 22022/7/18

#### sql语句中的别名：

我们可以在表名和字段名的后面添加空格 别名

别名在当前语句中就指代这个表或字段

我们可以通过表的别名自动补出字段名

~~~plsql
select * from teacher t;
select t.tno 编号,t.tname 姓名,t.tage 年龄 from teacher t;
~~~

#### distinct关键字

在结果集所有字段有重复的情况下可以用来排重

~~~plsql
select  distinct t.tname 姓名 from teacher t;
~~~

#### order by

排序，注意：在排序字段后 esc表示升序(可以缺省) desc表示降序

~~~plsql
select * from teacher order by tno desc;
~~~

注意：order by 后面可以跟福多个字段，按照先后的优先级依次排序

#### where子句

条件查询，它写在from子句的后面，用来条件查询

#### between 下限 and 上限

表示在下限和上限之间(两边都闭)  等价于 `xx >= 下限 and xx <= 上限`

#### and

多个条件如果是并且关系 用and连接

#### 空值的判断

is null ---- 为空

is not null ---- 不为空

#### 不等于 <>

注意：oracle中还支持  != 

注意：关于优先级的问题 我们可以使用小括号将自己认为先算的表达式括起来即可

#### in

表示在指定范围内进行匹配，查询出符合要求的记录

~~~plsql
select * from teacher t where t.birplace in('北京','上海','江苏','浙江');
~~~

注意： not in 表示不在指定范围内

#### like

模糊查询

~~~plsql
-- 全匹配： 字段名 like '%关键字%'
select * from teacher t where t.birplace like '%江%';
-- 左匹配：字段名 like '关键字%'
select * from teacher t where t.birplace like '江%';
-- 右匹配：字段名 like '%关键字'
select * from teacher t where t.birplace like '%江';
~~~

#### 聚合函数

1. sum() 函数 ---- 求和

~~~plsql
select sum(t.sal) 男教师薪资综合 from teacher t where t.tsex = '男';
~~~

2. count() ---- 计数 可以传入    *  主键  1

~~~plsql
select count(*) from teacher t where t.tsex = '男';
select count(tno) from teacher t where t.tsex = '男';
select count(1) from teacher t where t.tsex = '男';
~~~

3. max() ---- 最大值
4. min() ---- 最小值
5. avg() ---- 平均值

~~~plsql
select max(t.tage) from teacher t;
select min(t.tage) from teacher t;
select round(avg(t.tage),0) from teacher t;
~~~

#### round(数值,小数位)

以四舍五入的方式保留小数位

#### group by

`group by 分组字段` ---- 就会按照指定字段进行分组

~~~plsql
-- 查询男女老师的人数
select count(*),t.tsex from teacher t group by t.tsex;
-- 查询各个籍贯人数
select count(*),t.birplace from teacher t group by t.birplace;
~~~

分组往往伴随着聚合函数

注意：select 后面的非函数字段，必须是group by 表达式

#### having子句

对分组统计后的函数结果进行条件过滤，需要使用having子句，它写在group by后面

~~~plsql
-- 统计那些籍贯不止一个老师，展示籍贯和教师数
select count(*),t.birplace from teacher t 
where t.birplace is not null
group by t.birplace
having count(*) > 1;
~~~

#### 子查询

一个查询语句的结果是另一个查询语句的条件，那么该查询语句就是子查询

注意：子查询只能查一个字段当作条件值

~~~plsql
--统计李树标同系别的其他老师的信息
--1.查询李树标的系别编号
--2.查询哪些教师的系别编号是该编号
select * from teacher t1 where t1.dno = (
select t.dno from teacher t where t.tname = '李树标')
and t1.tname <> '李树标';
~~~

#### 多表查询

我们可以在from子句中写入多张表，逗号分隔

注意：我们还需要在where子句中编写他们的关联条件，如果关联条件不够，则会出现笛卡尔集的错误

~~~plsql
select t.tname,d.dname from teacher t,department d where t.dno = d.dno;
~~~

~~~plsql
-- 查询每个教师的姓名以及他们所教课程的名字
select t.tname, c.cname
  from teacher t, course c, t_course tc
 where t.tno = tc.tno
   and tc.cno = c.cno;
~~~

#### 左外关联

左边的表，所有记录全部展示

右边的表，如果关联到记录，就展示数据，否则字段值留空

语法：

~~~plsql
select 字段列表 from 左表 left join 右表 on 关联条件
~~~

~~~plsql
select t.tname, d.dname
  from teacher t
  left join department d
    on t.dno = d.dno;
~~~

注意：inner join表示内连接，相当于传统的多表关联   inner可以省略

注意：Oracle数据库中可以使用传统关联的写法，在关联条件的一边添加（+），使得另一边全部展示

#### union

求并集

多条select语句，他们之间如果结果集的字段个数和类型都一样，那么可以添加union来求他们的并集

~~~plsql
 --统计全校所有男同胞的姓名
 select t.tname from teacher t where t.tsex = '男'
 union
 select s.sname from student s where s.sex = '男'; 
~~~

注意：union自带排重效果，union all不会排重（比如上例中老师学生名字一样就给排除了）

