# 2023年7月22日

**程序** ---- 用编程语言编写的计算机指令的集合，即代码

**进程** ---- 运行中的程序

**线程** ---- 进程中的一条执行路径

**多线程** ---- 多条执行路径同时执行

## Java中创建多线程的两种方式

1. 继承Thread类，并重写run方法，然后由该类对象调用start()方法启动一个新的线程来执行run方法中的代码

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是run方法，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main方法，我执行到了： " + i);
        }
    }
}
~~~

2.实现Runnable接口并重写run方法，然后创建该类对象当作参数传入Thread构造方法来创建Thread对象，并由Thread对象调用start方法，启动一个新的线程来执行run方法中的代码

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是MyRunnable类的方法，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
        }
    }
}
~~~

第二种方式比较好，因为Java是单继承多实现，所以我们应该尽可能将继承的机会留给业务逻辑

### 线程的状态：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689989834/javaStudy/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81_xxgpwz.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689989834/javaStudy/线程的五种状态_xxgpwz.jpg)

1. 使用new Thread() 对象创建线程
2. 调用start方法来使线程进入就绪状态
3. 通过`cpu`调度使线程在就绪和运行状态间切换
4. 运行过程中如果发生了突发事件，例如Scanner类的等待输入，线程进入阻塞状态
5. 突发事件结束，线程回到就绪状态
6. 运行过程中，代码运行结束则进入终止状态

### 常用方法

`Thread.sleep(毫秒数)` ---- 使当前线程休眠指定毫秒数的时间

`interrupt()` ---- 中断该线程，使其处于终止状态

~~~java
public class TestSleep implements Runnable {

    @Override
    public void run() {
        while (true) {
            System.out.println("===========" + new Date() + "===========");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("TestSleep线程终止");
                return;
            }
        }
    }
}

~~~

~~~java
public class Test2 {

    public static void main(String[] args) {
        TestSleep testSleep = new TestSleep();
        Thread thread = new Thread(testSleep);
        thread.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();

    }
}

~~~

`join()` ---- 使该线程合并到当前线程中，等待该线程执行结束，才继续执行当前线程，相当于单线程

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
        }
    }
}
~~~

`yield()` ---- 在运行过程中让出`cpu`资源，让自己处于就绪状态

`setName(名字)` ---- 给当前线程设置名字

`currentThread()` ---- 获取当前线程对象

`currentThread().getName()` ---- 获取当前线程的名字

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            if(i%10 == 0){
                Thread.yield();
            }
            System.out.println("我是" +Thread.currentThread().getName() + "，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        thread.setName("t1");

        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
            if (i % 10 == 0) {
                Thread.yield();
            }
        }
    }
}
~~~

`setPriority(级别)` ---- 设置线程优先级 

`getPriority()` ---- 获取线程优先级

注意：线程的优先级最高10，最低1，默认5

## 线程同步

当多个线程对同一个对象操作的时候，保证该对象数据一致性的一种机制叫做线程同步

线程不同步的例子：

~~~java
public class Time {
    static int count = 0;

    public void f(String str) {
        count++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(str + "你好，你是第 " + count + "个访问该对象的线程");
    }
}

~~~

~~~java
public class TestSync implements Runnable {
    Time time;

    public TestSync() {
        time = new Time();
    }

    @Override
    public void run() {
        time.f(Thread.currentThread().getName());
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {
        TestSync ts = new TestSync();

        Thread thread1 = new Thread(ts);
        Thread thread2 = new Thread(ts);

        thread1.setName("t1");
        thread2.setName("t2");

        thread1.start();
        thread2.start();
    }
}

~~~

输出结果：

~~~java
t2你好，你是第 2个访问该对象的线程
t1你好，你是第 2个访问该对象的线程
~~~

## synchronized

锁

1. 添加在方法声明处，表示当前对象在调用该方法时，锁定当前对象。某个线程在该对象上访问此方法时，其他线程无法在该对象上访问此方法。

~~~java
    public synchronized void f(String str) {
        count++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
~~~

2. 在某段代码上使用`synchronized(对象){}` 来控制这一段代码在被执行的过程中线程同步

~~~java
    public void f(String str) {
        synchronized (this) {
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(str + "你好，你是第 " + count + "个访问该对象的线程");
        }
    }
~~~

## 死锁

多个线程互相锁定着对方需要锁定的对象，导致都无法往下执行

例如：

~~~java
//简单来说，就是先锁定对象o1，然后睡觉，准备睡醒了锁o2,但是睡觉时o2被人su
public class TestDeadLock implements Runnable {

    private int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public int getFlag() {
        return flag;
    }

    public void setFlag(int flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag == 1) {
            synchronized (o1) {
                System.out.println("我是flag1，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (o2) {
                    System.out.println("我是flag1，我结束工作了");
                }
            }
        } else {
            synchronized (o2) {
                System.out.println("我是flag2，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("我是flag2，我结束工作了");
                }
            }
        }
    }
}

~~~

~~~java
public class Test {


    public static void main(String[] args) {
        TestDeadLock testDeadLock1 = new TestDeadLock();
        TestDeadLock testDeadLock2 = new TestDeadLock();

        testDeadLock1.setFlag(1);
        testDeadLock2.setFlag(2);

        Thread thread1 = new Thread(testDeadLock1);
        Thread thread2 = new Thread(testDeadLock2);

        thread1.start();
        thread2.start();
    }
}

~~~

**注意**：避免死锁的一个有效方式：将加锁的粒度加粗

~~~java
package com.iweb.test3;

/**
 * @author 童 淏
 * @createTime 2023/07/22 11:53
 * @email 1208195222@qq.com
 * @description
 */
public class TestDeadLock implements Runnable {

    private int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public int getFlag() {
        return flag;
    }

    public void setFlag(int flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag == 1) {
            synchronized (this) {
                System.out.println("我是flag1，我开始工作了");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("我是flag1，我结束工作了");
            }
        } else {
            synchronized (this) {
                System.out.println("我是flag2，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("我是flag2，我结束工作了");
            }
        }
    }
}

~~~

~~~java
package com.iweb.test3;

/**
 * @author 童 淏
 * @createTime 2023/07/22 11:54
 * @email 1208195222@qq.com
 * @description
 */
public class Test {


    public static void main(String[] args) {
        TestDeadLock testDeadLock1 = new TestDeadLock();
        testDeadLock1.setFlag(1);
        Thread thread1 = new Thread(testDeadLock1);
        thread1.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        testDeadLock1.setFlag(2);
        Thread thread2 = new Thread(testDeadLock1);
        thread2.start();
    }
}

~~~

**注意**：当某个线程访问了某个对象上某个加锁的方法时，其他线程完全可以访问该对象上其他没有加锁的方法。

~~~java
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("m1方法结束了");
    }

    public void m2() {
        System.out.println("我是m2方法");
        System.out.println(i);
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**注意**：没有加锁的方法会对当前对象上其他加锁的方法产生影响

~~~java
package com.iweb.test4;

/**
 * @author 童 淏
 * @createTime 2023/07/24 9:30
 * @email 1208195222@qq.com
 * @description
 */
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
        System.out.println("m1方法结束了");
    }

    public void m2() {
        System.out.println("我是m2方法");
        i = 2000;
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**注意**：多个加锁的方法在同一个对象的操作上互斥

~~~java
package com.iweb.test4;

/**
 * @author 童 淏
 * @createTime 2023/07/24 9:30
 * @email 1208195222@qq.com
 * @description
 */
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
        System.out.println("m1方法结束了");
    }

    public synchronized void m2() {
        System.out.println("我是m2方法");
        i = 2000;
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**总结**：在一个多线程的项目上，增删改的方法需要加锁，查询的方法不需要加锁

# 2023年7月24日

## Object类中提供的一些线程相关的方法

`wait()` ---- 等待，使当前线程阻塞

`notify()` ---- 唤醒当前对象上某个wait中的线程

`notifyAll()` ---- 唤醒当前对象上所有wait中的线程

## wait()和sleep()的区别

1. wait()在Object类，它往往等待别的线程调用notify()才能被唤醒
   sleep()在Thread类，它往往等待自己睡眠时间到了而被自动唤醒
2. 当某个线程sleep状态下，依然保留线程锁
   当某个线程wait状态下，会释放线程锁

## 生产者消费者

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 10:44
 * @email 1208195222@qq.com
 * @description
 */
public class ManTou {

    private int id;

    @Override
    public String toString() {
        return "ManTou{" +
                "id=" + id +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public ManTou() {
    }

    public ManTou(int id) {
        this.id = id;
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 10:45
 * @email 1208195222@qq.com
 * @description
 */
public class ManTouStack {


    ManTou[] arrs = new ManTou[6];//馒头框

    int size;//当前框中的馒头数

    //往框中扔一个馒头
    public synchronized void push(ManTou mt) {
        while (size == arrs.length) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        arrs[size] = mt;
        size++;
        System.out.println("生产了:           " + mt);
    }

    //从框中拿一个馒头
    public synchronized ManTou pop() {
        while (size == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        size--;
        System.out.println("消费了：" + arrs[size]);
        return arrs[size];
    }
}




~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:15
 * @email 1208195222@qq.com
 * @description
 */
public class Producer implements Runnable {

    ManTouStack mts = null;

    public Producer(ManTouStack mts) {
        this.mts = mts;
    }

    public Producer() {
    }


    //生产
    @Override
    public void run() {
        for (int i = 0; i <= 20; i++) {
            ManTou manTou = new ManTou(i);
            mts.push(manTou);
            try {
                Thread.sleep((long) (Math.random()) * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


        }
    }


}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:18
 * @email 1208195222@qq.com
 * @description
 */
public class Consumer implements Runnable {

    ManTouStack mts = null;

    public Consumer() {
    }

    public Consumer(ManTouStack mts) {
        this.mts = mts;
    }


    //消费
    @Override
    public void run() {
        for (int i = 0; i <= 20; i++) {
            ManTou mt = mts.pop();
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:20
 * @email 1208195222@qq.com
 * @description
 */
public class Test {

    public static void main(String[] args) {
        ManTouStack mts = new ManTouStack();

        Producer p1 = new Producer(mts);
        Consumer c1 = new Consumer(mts);

        new Thread(p1).start();
        new Thread(c1).start();
    }
}

~~~

## `vue`

这是一个渐进式的前端框架

## 创建`vue`项目

`vue create 项目名`

## 启动`vue`项目

`cd 项目文件夹`

`npm run serve`

## 停止项目

`ctrl + c`

## `elementUI`

这是一个基于`vue`的网站快速生成工具

在`vue`项目中添加`elementUI`：

`vue add element`

## `Axios`

这是一个发送请求到后端的连接工具

安装`Axios`：

`cnpm install axios --save`

## `<router-link to="">`

这是`vue`中的页面跳转，to属性表示目标url

我们需要在`index.js`中配置跳转的url信息，对应to属性

## 嵌套路由

在某个主键中添加容器，路由器由children属性指向子页面，那么点击跳转的时候，子页面内容将被加载到容器中，而不是直接跳转。

## 内部样式表：

在当前页面上编写`css`代码，它的作用范围就是当前页面

## 外部样式表：

单独编写`css`文件，里面写`css`代码，在需要的页面上使用`@import url("css文件路径") `将其导入

## 全局样式表：

只需要在`index.html`的`<head>`中添加`<link rel="stylesheet" type="text/css" href="css文件路径"/>`即可实现全局样式，任何组件中都无序单独导入。

## 组件生命周期相关方法

~~~javascript
beforeCreate() ---- 创建之前
created() ---- 创建完成
beforeMount() ---- 渲染之前
mounted() ---- 渲染完成
		beforeCreate() {
			console.log("该组件即将创建");
		},
		created() {
			console.log("该组件创建完成");
		},
		beforeMount() {
			console.log("该组件即将渲染");
		},
		mounted() {
			console.log("该组件渲染完成");
		},
		beforeUpdate() {
			console.log("该组件即将被修改");
		},
		updated() {
			console.log("该组件修改完成");
		},
		beforeDestroy() {
			console.log("该组件即将被删除");
		},
		destroyed() {
			console.log("该组件删除完成");
		}
~~~

