# 题目描述

日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。

- 如果上报太频繁，会对服务端造成压力;
- 如果上报太晚，会降低用户的体验；
- 如果一次上报的条数太多，会导致超时失败。

为此，项目组设计了如下的上报策略：

1. 每成功上报一条日志，奖励1分
2. 每条日志每延迟上报1秒，扣1分
3. 积累日志达到100条，必须立即上报

给出日志序列，根据该规则，计算首次上报能获得的最多积分数。

# 输入描述

按时序产生的日志条数 T1,T2…Tn，其中

- 1 <= n <= 1000
- 0 <= Ti <= 100

# 输出描述

首次上报最多能获得的积分数

# 用例1

## 输入

```none
1 98 1
```

[Copy](javascript:;)

## 输出

```none
98
```

[Copy](javascript:;)

## 说明

> T1 时刻上报得 1 分
>
> T2 时刻上报得98分，最大
>
> T3 时刻上报得 0 分

# 用例2

## 输入

```none
50 60 1
```

## 输出

```none
50
```

## 说明

> 如果第1个时刻上报，获得积分50。如果第2个时刻上报，最多上报100条，前50条延迟上报1s，每条扣除1分，共获得积分为 100-50=50

# 用例3

## 输入

```none
3 7 40 10 60
```

## 输出

```none
37
```

## 说明

> T1时刻上报得3分
>
> T2时刻上报得7分
>
> T3时刻上报得37分，最大
>
> T4时刻上报得-3分
>
> T5时刻上报，因为已经超了100条限制，所以只能上报100条，得-23分

~~~java
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int[] arr = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    System.out.println(test(arr));
}
static void test(int[] arr){
    int len = arr.length;
    Map<Integer,Integer> map = new HashMap<>(len);
    Map<Integer,Integer> res = new HashMap<>(len);
    for(int i = 0; i < len; i++){
        int sum = 0;
		for(int j = 0; j <= i; j++){
             sum += arr[j];
        }
        map.put(i,sum);
        for(int k = 0; k < i; k++){
            sum -= map.get(i);
        }
        res.put(i,sum);
        if(sum <= res.get(i-1)){
            return res.get(i -1);
        }
  
    }
}
~~~

