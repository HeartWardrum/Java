“熟悉数据结构”通常意味着具备以下几个方面的能力和知识：

1. **基本概念理解**：
   - 理解常见的数据结构，如数组、链表、栈、队列、树、图、哈希表等。
   - 知道每种数据结构的基本操作（插入、删除、查找等）以及这些操作的时间复杂度和空间复杂度。

2. **实现能力**：
   - 能够使用一种或多种编程语言从头实现这些数据结构，并且能够根据需求进行修改和优化。
   - 熟悉标准库中提供的各种数据结构，并知道何时使用它们。

3. **应用能力**：
   - 能够根据具体问题选择合适的数据结构，并知道选择的原因。
   - 能够将数据结构应用于实际编程中，解决复杂问题。

4. **算法理解**：
   - 理解常见的算法，如排序算法（快速排序、归并排序等）、查找算法（二分查找等），并知道它们在不同数据结构上的应用。
   - 能够使用数据结构来实现和优化算法。

5. **解决问题的能力**：
   - 能够分析问题，选择合适的数据结构和算法进行解决。
   - 能够在实际开发中进行数据结构和算法的调试、优化和性能调优。

### 具体步骤和建议

1. **学习基础知识**：
   - 阅读和学习相关的教材或在线教程，例如《数据结构与算法分析》、《算法导论》等。
   - 在线平台如Coursera、edX、LeetCode、HackerRank等提供了大量的学习资源和练习题目。

2. **编码实践**：
   - 使用一种或多种编程语言实现各种数据结构，从基本的数组、链表到复杂的树、图。
   - 在实际项目中应用这些数据结构，解决实际问题。

3. **算法练习**：
   - 通过在线平台如LeetCode、HackerRank、CodeSignal等进行算法和数据结构的练习。
   - 尝试解决不同类型的题目，包括简单题、中等题和困难题。

4. **参与竞赛和项目**：
   - 参与编程竞赛，如ACM-ICPC、Google Code Jam、Facebook Hacker Cup等，以提高解决问题的速度和效率。
   - 在实际项目中应用所学的知识，积累实战经验。

5. **深入理解和优化**：
   - 阅读和理解他人的优秀代码和解决方案，学习其中的技巧和思路。
   - 学习性能优化的方法，如如何减少时间复杂度和空间复杂度。

### 常见数据结构的特点和应用

1. **数组（Array）**：
   - 特点：内存连续，随机访问时间复杂度为O(1)，插入和删除操作复杂度为O(n)。
   - 应用：适合需要频繁随机访问的场景，如实现哈希表、堆排序等。

2. **链表（Linked List）**：
   - 特点：内存不连续，随机访问时间复杂度为O(n)，插入和删除操作复杂度为O(1)。
   - 应用：适合需要频繁插入和删除的场景，如实现队列、栈等。

3. **栈（Stack）和队列（Queue）**：
   - 特点：栈是先进后出（LIFO），队列是先进先出（FIFO）。
   - 应用：适合用于表达式求值、树的遍历、操作系统中的任务调度等。

4. **树（Tree）**：
   - 特点：层级结构，常见的有二叉树、平衡树（如AVL树、红黑树）、B树等。
   - 应用：适合用于表示分层结构的数据，如文件系统、数据库索引等。

5. **图（Graph）**：
   - 特点：由节点和边组成，可以表示任意的关系结构。
   - 应用：适合用于网络、地图、社交网络等场景。

6. **哈希表（Hash Table）**：
   - 特点：通过哈希函数实现快速的插入和查找，平均时间复杂度为O(1)。
   - 应用：适合用于实现高效的查找和去重，如字典、缓存等。

通过系统的学习和大量的编码实践，掌握这些数据结构及其应用，你将能够自信地说自己“熟悉数据结构”。





# 数据结构简介

**数据结构**：以某种特定的布局方式存储数据的容器

没有一种结构是绝对高效的，它总是在某一类操作中效率高，在另一类操作中效率低。

数据结构 = 逻辑结构 + 物理结构（顺序，链式，索引，散列）

逻辑结构：数据元素间抽象化的相互关系（例如Java中的接口Set Map之类的就是一种逻辑结构）

物理结构：在计算机存储器中的存储形式

## 数据结构的逻辑分类

1. 线性结构：
   线性结构中间的元素有且只有一个直接前驱和一个直接后继，元素之间相邻有序，List类以下的都是线性结构
2. 树形结构：
   数据结构中的元素存在一对多的相互关系；
3. 图形结构：
   元素存在多对多

### 1. 线性结构：

#### 1.1栈

LIFO 后进先出

手写栈：

~~~java
import java.util.Arrays;
import java.util.EmptyStackException;

/*
自定义栈容器
 */
public class MyStack<E> {

    // 存放元素的物理结构
    private Object[] arr;

    // 数组的默认长度
    private int stackLength = 4;

    // 记录栈容器中的元素个数
    private int size;

    // 操作数组下标位置的指针
    private int index = -1;

    /**
     * 判断栈容器是否为空
     * @return
     */
    public boolean empty() {
        return this.size == 0;
    }

    /**
     * 获取栈顶元素
     * @return
     */
    public E pop() {
        // 如果栈容器中没有元素，则抛出异常
        if (this.index == -1) {
            throw new EmptyStackException();
        }
        // 记录元素个数
        this.size--;
        // 返回栈顶元素
        return (E)this.arr[index--];
    }

    /**
     * 向栈容器中添加元素
     * @param item
     * @return
     */
    public E push(E item) {

        // 初始化数组
        this.capacity();
        // 向栈容器中添加元素
        this.arr[++index] = item;
        // 记录元素个数
        this.size++;

        return item;
    }

    /**
     * 数组初始化或以1.5倍容量对数组扩容
     */
    private void capacity() {
        // 初始化数组
        if (this.arr == null) {
            this.arr = new Object[this.stackLength];
        }
        // 以1.5倍容量对数组扩容
        if (this.size >= this.stackLength) {
            this.stackLength = this.stackLength + (this.stackLength >> 1);
            this.arr = Arrays.copyOf(this.arr,this.stackLength);
        }

    }

    public static void main(String[] args) {

    }
}

~~~

### 2.链表结构

#### 2.1 链表结构的定义

链表由许多节点构成，每个节点都包含两部分：

- 数据部分：保存该系欸但的实际数据
- 地址部分：保存的是上一个或下一个节点的地址

#### 2.2 链表分类

- 单向链表
- 双向链表
- 双向循环链表

#### 2.3 链表的特点

- 节点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。
- 访问时只能通过头或者尾指针进入链表，并通过每个节点的指针域向后或向前扫描其余节点，所以寻找第一个节点和最后一个节点所花费的时间不等。



