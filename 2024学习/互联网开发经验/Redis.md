https://www.bilibili.com/video/BV1zt421G7uu/?spm_id_from=333.337.search-card.all.click&vd_source=60de449f23a9496cd95f00798d033502

# Redis

Remote Dictionary Server

 

项目中使用redis的方法

- 一些经常使用的数据，在项目启动的时候就从数据库里加载到redis中
- 验证码、token信息加载到redis中

## 为什么使用缓存

1. 高性能（将热点数据从SQL数据库中加入到Redis缓存中，以便之后访问这些数据可以非常的高效）（但可能造成双写不一致的问题，即修改SQL数据库，却没来得及修改Redis数据库，导致用户读数据和数据库中数据不一致）
2. 高并发（MySQL只能承受2000左右的并发量，而Redis支持上万的并发量，大部分请求通过Redis返回，减轻了MySQL的负担）



## 使用缓存带来的问题

- 双写不一致
- 穿透雪崩
- 并发竞争

### 双写不一致

双写不一致（Dual-write Inconsistency）是指在分布式系统或多数据源场景中，为了提高系统的可用性或性能，往往会对同一数据进行多次写入操作，而这些写入操作可能会导致数据不一致的情况。具体来说，双写不一致通常发生在以下几种情况下：

1. **多数据库写入**：在需要将数据同时写入到多个数据库时，如果其中一个数据库写入成功而另一个数据库写入失败，就会造成数据的不一致。

2. **缓存与数据库双写**：为了提高读性能，常常会将数据写入到缓存（如Redis）和数据库（如MySQL）。如果写入缓存成功但写入数据库失败，或者反过来，也会导致数据不一致。

3. **主从数据库同步**：在主从数据库架构中，主数据库写入成功但从数据库同步失败或延迟，也会引起数据不一致的问题。

为了避免双写不一致，常用的方法有：

1. **分布式事务**：使用分布式事务协议（如两阶段提交、三阶段提交）来保证多次写入操作的一致性，但这种方法往往会带来较高的性能开销。

2. **补偿机制**：在写入失败后，通过补偿机制进行重试或者回滚操作，确保最终数据的一致性。

3. **幂等操作**：设计幂等的写操作，即使相同的操作重复执行多次也不会影响最终结果，从而减少不一致的可能性。

4. **最终一致性**：在某些场景下，允许数据在短时间内不一致，通过异步同步机制在一定时间内达到最终一致性。

理解和处理双写不一致是分布式系统设计中的一个重要课题，尤其在高可用性和高性能需求下，需要在一致性、可用性和性能之间做出权衡。

### 穿透雪崩

穿透雪崩（Cache Avalanche）是一种在缓存系统中常见的问题，它通常在缓存数据大规模失效或过期时发生，导致大量的请求直接穿透缓存，打到后端数据库或其他数据源，进而引发一系列连锁反应，可能导致系统负载剧增甚至崩溃。穿透雪崩可以具体分为以下几个方面：

1. **缓存穿透（Cache Penetration）**：指当请求的数据在缓存中不存在且数据库中也不存在时，每个请求都会直接查询数据库，绕过缓存。这通常发生在缓存击穿时，对同一个未命中的key有大量并发请求。

2. **缓存击穿（Cache Breakdown）**：指某个热点数据在缓存中失效后，有大量并发请求同时到达缓存，而该数据在缓存中不存在，所有请求都会访问后端数据库。

3. **缓存雪崩（Cache Avalanche）**：指在短时间内大量缓存数据同时过期，导致大量请求直接穿透缓存，访问数据库。这种情况下，数据库可能会瞬间被大量请求压垮，造成系统崩溃。

为了防止和应对穿透雪崩，常用的方法有：

1. **缓存预热**：在系统启动或缓存失效前，提前将热点数据加载到缓存中，避免缓存失效后大量请求直接访问数据库。

2. **请求排队**：对同一个key的并发请求进行排队处理，只允许一个请求去加载数据并更新缓存，其余请求等待结果。

3. **随机过期时间**：设置缓存数据的过期时间时，使用随机的过期时间，避免大量缓存数据同时过期。

4. **降级策略**：在缓存失效或数据库压力过大时，采取降级策略，如返回默认值或部分数据，以减轻数据库压力。

5. **限流和熔断**：对访问量进行限流，设置熔断机制，防止数据库因大量请求被压垮。

通过这些措施，可以有效防止和缓解穿透雪崩问题，保证系统的稳定性和可用性。

### 并发竞争

并发竞争（Concurrency Competition），也称为竞争条件（Race Condition），是指在多线程或多进程环境下，多个线程或进程同时访问和操作共享资源时，由于访问顺序的不确定性，可能导致数据不一致或程序行为不可预期的问题。以下是一些常见的并发竞争问题和解决方法：

### 常见的并发竞争问题

1. **读-写竞争**：一个线程在读取数据的同时，另一个线程正在写入数据，导致读取到的数据不一致。

2. **写-写竞争**：多个线程同时写入同一个数据，导致最终的数据状态不可预测。

3. **检查-更新竞争**：一个线程在检查某个条件并基于该条件进行更新操作时，另一个线程在检查和更新之间也进行了更新操作，导致数据状态错误。

### 并发竞争的解决方法

1. **锁机制（Locks）**：
   - **互斥锁（Mutex）**：确保一次只有一个线程能访问共享资源，常用于保护临界区。
   - **读写锁（Read-Write Lock）**：允许多个线程同时读取数据，但在写入数据时需要独占访问。

2. **信号量（Semaphores）**：用于控制对资源的访问，通过计数机制限制并发线程的数量。

3. **条件变量（Condition Variables）**：允许线程在等待某个条件满足时被挂起，当条件满足时通知等待的线程。

4. **原子操作（Atomic Operations）**：提供对基本数据类型的原子操作，确保操作的不可分割性，常用于计数器、自增变量等简单操作。

5. **无锁编程（Lock-Free Programming）**：通过使用原子操作和内存屏障等技术，实现不依赖锁的并发控制，减少锁竞争带来的性能开销。

6. **事务内存（Transactional Memory）**：通过将一组操作视为一个事务来执行，确保操作要么全部成功，要么全部失败，避免部分操作成功导致的数据不一致。

### 示例代码

以下是一个简单的使用互斥锁来解决并发竞争问题的示例：

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private final Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Final count: " + counter.getCount());
    }
}
```

在这个示例中，`increment` 和 `getCount` 方法使用互斥锁来确保只有一个线程能够访问和修改 `count` 变量，从而避免了并发竞争问题。

理解并发竞争以及如何解决它，是开发健壮和高效并发程序的重要环节。

## Redis数据类型

- String 对应Java  `String` `Map<String,String>`
- Hash   `HashMap ` `Map<String,Map<String,String>>`
- List       `LinkedList`     `Map<String,List<String>>`
- Set    `Map<String,Set<String>>`
- `zSet` 有序集合   `TreeSet`   `Map<String,SortSet<String>>`

### Redis线程模型

Redis是单线程，为什么这么快？

1. 纯内存操作
2. 线程模型

 