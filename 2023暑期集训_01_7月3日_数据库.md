瀑布模型：

- 需求规格说明书
- 概要设计（包括数据库设计）
- 详细设计（伪代码之类的）
- 编码
- 测试

----------------------

小厂一般使用敏捷开发



2023年7月3日

# 数据库

设计基本步骤：

>1. 找名词
>2. 把名词分两类（实体，属性）
>3. 一个实体一张表
>     一个属性一个字段
>4. 确定表和表之间的关系:
>   - 1对1：主表中添加从表的编号作为关联字段
>   - 1对多：在多的一端中添加1的一端的编号作为关联字段
>   - 多对多：再添加一张关系表用来记录两边的编号

### **ER图**：

### 辅助我们进行数据库表结构设计的工具

在ER图中

> 矩形：实体
> 椭圆：属性
> 菱形：关系

![ER图](https://res.cloudinary.com/dvqgs9esp/image/upload/v1688353564/ER图_q01tnx.png)

### 范式：

### ————判断数据库中某张表设计的好坏的规范

> 1. 第一范式：列不可分（每一个字段都是不可再分的最小原子单位）
> 2. 第二范式：要有主键，不存在部分依赖
>    （主键：某个字段非空唯一）
>    （联合主键：多个字段的组合作为主键）
>    （所有非主键字段必须完全依赖联合主键）
> 3. 第三范式：不存在传递依赖
>    （所有非主键字段必须直接依赖主键）

## Oracle

sql	---- 标准的查询语言
DDL ---- 数据定义语言：针对数据库对象操作的
DML ---- 数据操纵语言：针对数据操作的

~~~sql
-- 查询服务器时间
select sysdate from dual;
~~~

关于dual：

1. dual不是缩写词，本身就是完整的单词
2. Oracle中的dual表是一个单行单列的虚拟表
3. Dual表是oracle与数据字典一起创建的一个表，这个表只有1列：DUMMY，数据类型为VERCHAR2(1)，dual表中只有一个数据：‘X’，Oracle有内部逻辑保证dual表中永远只有一条数据。
4. Dual表主要用来选择系统变量或求一个简单的例子：
   SELECT sysdate FROM daul
   而Oracle的SELECT语法限制为：
   SELECT * FROM table
   所以，没有表名就没有办法查询，而时间日期并不存放在任何表中，于是这个dual虚拟表的概念就被引入了。
5. dual表的用途：
   dual是Oracle中的一个实际存在的表，任何用户均可读取，常用在没有目标表的SELECT语句块中

### 创建一张表：

~~~sql
CREATE TABLE 表名(
字段1 类型，
字段2 类型，
    ...
)
~~~

例如：
~~~sql
CREATE TABLE comifo20230703(
pno VARCHAR2(32),
pname VARCHAR2(32),
gender VARCHAR2(6),
birthday DATE,
phone NUMBER(32)
);
~~~

### 事务

数据库中保证数据准确性，完整性，一致性和原子性的一种机制，当我们增删改数据后，需要提交事务，事务不仅可以被提交，还可以被回滚。

### 修改一张表

1. 添加字段：

~~~sql
ALTER TABLE 表名 ADD(
字段名 类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 ADD(
qq number(32)
);
~~~

2. 修改字段名

~~~sql
ALTER TABLE 表名 RENAME 旧字段名 TO 新字段名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME COLUMN qq TO wechat;
~~~

3. 修改字段类型

~~~sql
ALTER TABLE 表名 MODIFY(
字段名 新类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 MODIFY(
wechat varchar2(32)
);
~~~

4. 删除字段

~~~sql
ALTER TABLE 表名 DROP(字段名);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 DROP(wechat);
~~~

5.修改表名

~~~sql
ALTER TABLE 旧表名 RENAME TO 新表名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME to comifo0703;
~~~

### 删除一张表

~~~sql
DROP TABLE 表名;
~~~

例如：

~~~sql
DROP TABLE comifo0703;
~~~

### 插入一条记录

~~~sql
INSERT INTO 表名(字段1,字段2,...)
VALUES('值1','值2',...);
~~~

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname, phone)
VALUES
  ('1001', '张三', '18112923121');
~~~

语句执行完成后要手动提交事务

注意：当对表中所有字段插入数据时，values前面的小括号可以省略



### 字符串转日期函数

to_date(日期字符串，日期格式)

注意：在格式中，y表示年，m表示月，d表示日，hh表示12小时制，hh24表示24小时制，mi表示分钟，ss表示秒。

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname,gender,birthday, phone) 
VALUES
  ('1002', '李四','男',to_date('2001-06-15','yyyy-mm-dd'),'13944572390');
~~~

~~~sql
INSERT INTO comifo703
  (pno, pname, gender, birthday, phone)
VALUES
  ('1004',
   '荀一',
   '男',
   TO_DATE('2000-07-31 13：23：32', 'yyyy-mm-dd hh24:mi:ss'),
   '1391221390');
~~~



### 修改字段

~~~sql
UPDATE 表名 SET 字段名 = 字段值 WHERE　条件语句; 
~~~

例如：

~~~sql
UPDATE comifo703 SET phone = '5542278383' WHERE pno = '1002';
~~~

### 删除语句

~~~sql
DELETE FROM 表名 WHERE 条件语句;
~~~

例如：

~~~sql
DELETE FROM comifo703 WHERE pno = '1001';
~~~

### 查询语句

~~~sql
SELECT 字段1,字段2,... FROM 表名 WHERE 条件;
~~~

例如：

~~~sql
 SELECT pno,pname,phone FROM comifo703 WHERE pno = '1002';
~~~

### 日期型转字符串型

to_char()

例如：

~~~sql
SELECT pno, pname, to_char(birthday, 'yyyy-mm-dd'), phone
  FROM comifo703
 WHERE pno = '1002';
~~~

### 约束

1.非空 ---- NOT NULL

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL	-- 非空
);
~~~

2.唯一 ---- UNIQUE

注意：如果非空并且唯一，那么UNIQUE需要单独编写：
~~~sql
CONSTRAINT 约束名 UNIQUE(字段)
~~~

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL,
CONSTRAINT uk703 UNIQUE(phone) -- 唯一
);
~~~

注意：小括号中如果有多个字段，则表示他们的组合不能重复。此外，如果要为组合添加约束，则必须使用constraint语句，而不能将unique挂在字段类型的后面

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

3.主键约束 ---- PRIMARY KEY

自带非空唯一的功能

例如：

~~~sql
DROP TABLE comifo703;

CREATE TABLE comifo703(
pno varchar2(32) PRIMARY KEY, -- 主键约束
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

主键约束也可以使用constraint编写
constraint 约束名 primary key(字段)

注意：小括号内如果有多个字段，则表示他们是联合主键。
例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname),
constraint pk703 primary key(pno,pname) -- 联合主键
);
~~~

# 2023年7月4日

### 外键

将某张表中的主键字段添加到另一张表中作为关联字段，那么该字段称为外键

外键约束两层含义：

1、当添加子表数据时，外键值必须是主表主键中已存在的值。
2、当删除父表数据时，主键值必须没有被子表关联使用。

例如：

~~~sql
create table class0704(
cno varchar2(32) primary key,
cname varchar2(32),
ccount number (10)
);

select * from class0704;

insert into class0704 
values
(1001,'A班',32);

create table student0704(
sno varchar2(32) primary key,
sname varchar2(32),
sage number(10),
cno varchar2(32) references class0704(cno) -- 外键
);

select * from student0704;

insert into student0704 
values 
(201801,'李四',12,1001); -- 插入的班级必须是已存在的
~~~

### 别名

我们在sql语句中可以给表或者字段起别名，方便我们带出字段名和展示结果集的表头

例如：

~~~sql
select t.tno 编号,t.tname 姓名, t.tsex 性别, t.tage 年龄 from teacher t;
-- 或
select t.tno as 编号,t.tname as 姓名, t.tsex as 性别, t.tage 年龄 from teacher as t;
-- 建议加as(2023.7.16修正：给表名起别名不能加as)
~~~

### 排重

在select子句部分的字段名前面添加distinct

### 排序

在查询语句最后添加order by子句，用来排序，格式：

~~~sql
order by 字段名 asc/desc
-- desc表示降序，asc表示升序，asc可以省略
~~~

例如：

~~~sql
select distinct t.tno, t.tname from teacher t order by t.tno desc;
~~~

```sql
select distinct t.tno, t.tname, t.tsex
  from teacher t
 order by t.tsex, t.tname, t.tno desc;
```

注意：汉字的大小顺序是unicode编码中的先后顺序

按照薪水高低查询所有男教师信息：

```sql
select * from teacher t where t.tsex = '男' order by t.sal desc;
```

### 常用的比较运算符

```sql
> 大于
>= 
<
<=
!=   -- 只在Oracle数据库中有效
<>
=
between 上限a and 下限b  -- 在[a,b]范围内
is null
is not null
```

### 多条件查询

and ---- 并且
or ---- 或者

```sql
select *
  from teacher t
 where t.tage > 45
   and t.tsex = '男';

select *
  from teacher t
 where t.birplace = '江苏'
    or t.birplace = '浙江';
    
    -- 注意多种逻辑运算符共存的时候，建议使用小括号把先算的部分括起来。
    -- 查询所有女教师和薪水大于9000的男教师
 select *
  from teacher t
 where t.tsex = '女'
    or (t.tsex = '男' and t.sal > 9000);
```

### in 和 not in

in  在指定的范围内筛选

not in  在指定范围以外筛选

格式：`in (值1,值2)`

例如：

```sql
select * from teacher t where t.birplace not in ('北京', '上海', '江苏');
```

### like

模糊查询

格式：

```sql
-- 全匹配 '%关键字%'
select * from teacher t where t.birplace like '%江%';
-- 左匹配 '关键字%'
-- 右匹配 '%关键字'
```

### 聚合分析函数

avg(字段) ---- 求平均值

sum(字段) ---- 求和

max(字段) ---- 求最大值

min(字段) ---- 求最小值

count(字段) ---- 计数

### 数值截取函数

round(数值，小数位) ---- 以四舍五入的方式截取数值

trunc(数值，小数位) ---- 以直接丢弃的方式截取数值

```sql
select round(avg(t.sal),2) 平均工资 from teacher t;
select trunc(avg(t.sal),2) 平均工资 from teacher t;
```

### 分组语句

group by

例如：

```sql
select trunc(avg(t.sal),2) ,t.tsex from teacher t
group by t.tsex;
```

注意：select后面只能添加group by的非函数字段，否则报错。

### having

如果需要在函数的结果上进行判断，不能使用where，只能使用having，having子句需要写在group by子句的后面。

例如：

```sql
select count(*), s.sex from student s group by s.sex having count(*) > 3;
```

```sql
-- 统计哪些籍贯不止一个老师
select count(*), t.birplace
  from teacher t
 group by t.birplace
having count(*) > 1;
```

### 子查询

一个查询语句的结果是另一个查询语句的条件，这样的select语句称为子查询语句

例如：

```sql
-- 查询和李树标同一系别的教师信息
select *
  from teacher t1
 where t1.dno = (select t.dno from teacher t where t.tname = '李树标')
   and t1.tname <> '李树标';
```

```sql
-- 统计学生表中系别和赵静想同，但是年龄比赵静大的同学的信息
select *
  from student s1
 where s1.dno = (select s.dno from student s where s.sname = '赵静')
   and s1.birthday <
       (select s2.birthday from student s2 where s2.sname = '赵静');
```

注意：如果子查询返回的结果集条数大于一条，那么外层查询只能使用in进行关联。

```sql
select *
  from student s1
 where s1.classid in
       (select s.classid
          from student s
         where s.birthday between to_date('1983-01-01', 'yyyy-mm-dd') and
               to_date('1984-12-31', 'yyyy-mm-dd'));
```



### for update

在select语句后面添加for update；可以实现图形化界面的增删改操作。

```sql
select * from student s for update;
```

### 多表关联

`select 字段 from 表1,表2,... where 关联条件`
注意：如果关联条件不够，则会出现笛卡尔乘积的问题
正确写法如下：

```sql
-- 统计每个教师的编号、姓名、系别名称
select t.tno, t.tname, d.dname
  from teacher t, department d
 where t.dno = d.dno;
```

注意：子查询也能实现多表关联

```sql
select t.tno, t.tname
  from teacher t
 where t.dno = (select d.dno from department d where d.dname = '计算机系')
```



### left join

左外关联
左边的表中所有记录全部展示，右边的表中的记录有则展示，无则留空。

格式：
`select 字段 from 左表 left join 右表 on 关联条件`

例如：

```sql
select * from teacher t left join department d on t.dno = d.dno;
```

注意：Oracle中的关联查询可以实现(+)的另一边全部展示

例如：

```sql
-- 和以上代码功能一样，
select * from teacher t ,department d where t.dno = d.dno(+);
```

### inner join

等于用等号进行两表关联，inner可以省略

例如：

```sql
select * from teacher t inner join department d on t.dno = d.dno;
```

### union

在两个select语句中实现并集，要求两个select语句字段类型和个数相同，union自带排重功能，union all 不会排重

例如：

```sql
-- 找出所有男老师和男学生的名字
select s.sname from student s where s.sex = '男'
union all
select t.tname from teacher t where t.tsex = '男';
```

```sql
-- 统计所有男学生选的课程名
-- 以及所有男老师教授的课程名
-- 以及所有课时>40的课程名
select c.cname from course c,student s,s_course sc
where c.cno = sc.cno and sc.sno = s.sno and s.sex = '男'
union 
select c1.cname from course c1, t_course tc,teacher t
where c1.cno = tc.cno and tc.tno = t.tno and t.tsex = '男'
union 
select c2.cname from course c2 where c2.ctime > 40;
```

### intersect

交集

```sql
-- 统计韩信和赵汗青选修了哪些相同的课程，展示课程名
select c.cname
  from course c, s_course sc, student s
 where c.cno = sc.cno
   and sc.sno = s.sno
   and s.sname = '韩信'
intersect
select c1.cname
  from course c1, s_course sc1, student s1
 where c1.cno = sc1.cno
   and sc1.sno = s1.sno
   and s1.sname = '赵汗青';
```

### minus

差集

由生日计算年龄

```sql
select s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age -- 由生日计算年龄
  from student s
 where s.sno in (select sc.sno from s_course sc where sc.mark < 60);

```

```sql
-- 查询不存在挂科人的信息
select distinct s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s,s_course sc
 where s.sno = sc.sno and  s.sno not in (
 select sc.sno from s_course sc where sc.mark < 60 
 );
 
 -- 另一种思路，把最低分大于等于六十的查出来
 select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in ( select sc.sno
                   from s_course sc
                  group by sc.sno
                 having min(sc.mark) >= 60);
```

```sql
-- 查询至少有2门成绩在65以上的同学的信息
select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in (
select sc.sno from s_course sc 
where sc.mark >=65 
group by sc.sno
having count(sc.sno)>=2);
```

练习：

```sql
 -- 对于emp中有管理者的员工，列出姓名，管理者姓名（MGR表示管理者）
 -- 实现了自己关联自己
 select e1.ename as 姓名,e2.ename as 管理者姓名
 from emp e1,emp e2
 where e1.mgr is not null and e1.mgr = e2.empno;
```

```sql
-- 查询同时选修java基础和高等数学两门课，的同学，
-- 并且他的java基础的分数要比高等数学的分数要高，
-- 展示这样的学生信息
select * from student s where s.sno in(
select sc1.sno from s_course sc1 ,s_course sc2 
where sc1.sno = sc2.sno    -- 同一个人
and sc1.cno = (            -- 这个人选修了java基础
select c.cno from course c where c.cname = 'java基础')
and sc2.cno = (            -- 这个人选修了高等数学
select c1.cno from course c1 where c1.cname = '高等数学')
and sc1.mark > sc2.mark    -- java基础分数比高等数学高
);

-- 用临时表改写
-- 造两张临时表
-- 一张表：展示所有选修java基础的同学的信息，以及java基础的分数
-- 另一张：展示所有选修高等数学的同学的信息，以及高等数学的分数
 with t1 as(select s.sno,s.sname ,s.sex,sc.mark  -- 这里不能将写成select * 的原因：如果使用select * 则t1表内有两列字段名都叫sno，在进行总查询的时候，t1.sno就无法确定是哪一列sno，产生未明确定义列错误
            from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = 'java基础'
 ),
 t2 as (select s.sno,s.sname ,s.sex,sc.mark 
        from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = '高等数学'
 )
 select t1.sno,t1.sex,t1.sname from t1,t2 where t1.sno = t2.sno and t1.mark > t2.mark;
```

# 2023年7月5日

### 临时表

它可以辅助我们编写select语句
把临时需要的一些数据先统计出来，形成临时表，执行完查询语句后，该临时表不会保存在数据库中。
格式：

```sql
with 表名1 as(select语句),
表名2 as(select语句)
总的查询语句
```

```sql
-- 查询所有偏科的同学
-- 偏科：
-- 个人总均分大于所有人所有课的总均分
-- 存在挂科
with t1 as
 (select sc.sno, avg(sc.mark) as peravg from s_course sc group by sc.sno)
select s.*
  from student s, s_course sc, t1
 where s.sno = sc.sno
   and s.sno = t1.sno
   and t1.peravg > (select avg(sc1.mark) from s_course sc1)
   and sc.mark < 60;

```

### substr

`substr(字符串,从第几位开始,截取几位)` ---- 从左往右截取字符串

例如：

```sql
select substr('this is a String',6,2) from dual; -- 结果为is
```

length(字符串) ---- 查询这个字符串的长度

从右往左截取方式：
`substr(字符串,-截取位数)` 
`substr(字符串,length(字符串)-截取位数+1,截取位数)`

### case语句

用来做分支判断，然后造一个字段

格式1：

```sql
case when 条件1 then 结果1
	when 条件2 then 结果2
	...
	else 结果n
	end as 别名
```

例如：

```sql
select sc.sno,
       sc.cno,
       sc.mark,
       case
         when sc.mark < 60 then
          '差'
         when sc.mark < 80 then
          '中'
         when sc.mark < 90 then
          '良'
         when sc.mark <= 100 then
          '优'
         else
          '其他'
       end as 等级
  from s_course sc;
```

格式2：

~~~plsql
case 字段名 when 值1 then 值2
			when 值1 then 值2
			...
			else 结果n
			end as 别名
~~~

例如：

~~~plsql
select s.sno,
       s.sname,
       case s.sex
         when '男' then
          'boy'
         when '女' then
          'girl'
         else
          'others'
       end as 性别
  from student s;
~~~

注意：格式2可以使用decode函数取代

`decode(字段,值1,结果1,值2,结果2,...)`

例如：

~~~plsql
select s.sno,
       s.sname,
       decode(s.sex, '男', 'boy', '女', 'girl', 'others') as 性别
  from student s;
~~~

#### 列转行

~~~plsql
  select t.student, 
  sum(case when t.course = '语文' then t.score else null end) as 语文,
  sum(case when t.course = '数学' then t.score else null end) as 数学,
  sum(case when t.course = '英语' then t.score else null end) as 英语,
  sum(case when t.course = '物理' then t.score else null end) as 物理
  from test t
  group by t.student;
~~~

~~~plsql
select student ,
sum(decode(course ,'语文',score)) as 语文,
sum(decode(course ,'数学',score)) as 数学,
sum(decode(course ,'英语',score)) as 英语,
sum(decode(course ,'物理',score)) as 物理
from test group by student;
~~~

最难的sql题（列转行）工作已完全够用，不用钻研更深

~~~plsql
/*2、按部门汇总emp表中五个职位的各自的薪资汇总以及部门汇总，例：

    DEPTNO  ANALYST CLERK MANAGER PRESIDENT SALESMAN  总和
    10      0       1300  2450    5000      0         8750
    20      6000    1900  2975    0         0         10875
    30      0       5950  2850    0         5600      14400
    总和    6000    9150  8275    5000      5600      34025*/
    with t1 as ( 
select 
      to_char(e.deptno)                    AS deptno  ,
      sum(case e.job when 'ANALYST' then sal else 0 end)   AS ANALYST,
      sum(case e.job when 'CLERK' then sal else 0 end)     AS  CLERK,
      sum(case e.job when 'MANAGER' then sal else 0 end)   AS MANAGER,
      sum(case e.job when 'PRESIDENT' then sal else 0 end) AS  PRESIDENT,
      sum(case e.job when 'SALESMAN' then sal else 0 end)  AS SALESMAN ,
      sum(e.sal) AS  总和
from  emp e 
group by e.deptno 
order by e.deptno
),
t2 AS (
select '总和', 
       sum(ANALYST), 
       sum(CLERK), 
       sum(MANAGER), 
       sum(PRESIDENT), 
       sum(SALESMAN) ,
       sum(总和) from t1 )
select * from t1 
union all 
select * from t2 ;
~~~

# 2023年7月6日

## 视图

存储下来的select 语句

创建视图：

~~~plsql
create or replace view 视图名 as 
select 语句;
~~~

查询视图：

~~~plsql
select 字段 from 视图名 ;
~~~

视图的好处：

1. 简化查询
2. 它可以和背后的基表同步(这一点体现了它和备份表的区别)
3. 它可以控制访问权限

视图在创建的时候，可以使用 as 字段别名 来重新定义视图中的字段名

视图的修改和新增是同一条语句：无则新增，有则替换

视图中的字段如果不是表中的原始字段（这样的视图称作复杂视图），则无法对该视图进行增删改操作
如果视图字段全是表中的字段（简单视图），它允许进行增删改操作，实际操作的是它背后的基表

一般不建议对视图进行增删改
在创建视图的语句最后添加 `with read only`可以屏蔽增删改操作
例如：

~~~plsql
create or replace view  emp070601 as 
select * from emp where deptno = 30
with read only;
~~~

所有的数据库的对象的删除都是drop语句

删除视图名：`drop view 视图名`

例如：

~~~plsql
drop view emp070601;
~~~

我们可以像创建视图那样去创建一张表，记录下查询语句中的结果集

格式：

~~~plsql
-- 创建备份表
create table 表名 as
select语句
~~~

## rownum 

行号

用来统计指定条数的记录

例如：

~~~plsql
select e.* ,rownum from emp e where rownum <= 10; -- 显示前十条记录
~~~

注意：rownum的条件过滤是针对原始数据，如果需要排序，那么得先用子查询来排序，在排序的结果集上加rownum

格式：

~~~plsql
select 字段 from (
	select 字段 from 表 where 条件 order by 排序字段 asc/desc
)
where rownum <= 数值
~~~

例如：

~~~plsql
 select * from ( select * from emp order by sal desc) where rownum <= 10; -- 工资最高的前十人
~~~

rownum的条件判断只支持`<`和`<=`，我们可以在当前结果集查询的时候给它起别名，相当于造了一个普通字段，这个普通字段支持各种比较运算符，然后再外层对别名进行条件判断。

例如：

~~~plsql
select *
  from (select a.*, rownum rn from (select * from emp order by sal desc) a 
        )  b
 where b.rn > 5
   and b.rn <= 10;
~~~

注意：在oracle中给表名起别名不能加as

## 分页查询

1. 每页条数是程序中写死的

2. 页数是前端传过来的

3. 分页公式（Oracle）： ---- 固定格式（重要！）
   ~~~plsql
   select * from (
   	select a.*,rownum rn from (
       	select * from 表名 order by 排序字段 desc) a ) b
       	where b.rn > 每页条数 * (页数 - 1) and b.rn <= 每页条数 * 页数;
   ~~~

## 序列

这是一种用来产生唯一数值的数据库对象

创建序列：

~~~plsql
create sequence 序列名
start with 起始值
increment by 递增值
maxvalue 最大值;
~~~

使用序列：

~~~plsql
序列名.nextval
~~~

查询当前值：

~~~plsql
序列名.currval
~~~

修改序列：

~~~plsql
alter sequence 序列名
increment by 递增值
maxvalue 最大值 ;
-- 注意：起始值不能修改
~~~

删除序列：

~~~plsql
drop sequence 序列名
~~~

例如：

~~~plsql
   -- 创建序列
   create sequence myseq0706
   start with 100
   increment by 1
   maxvalue 9999999999999999999999999999;
   -- 使用序列
   select myseq0706.nextval from dual;
   -- 查看序列进行到哪了  新序列创建后必须使用了一次才能查看，否则会出现序列尚未在此会话中定义的cuo'w
   select myseq0706.currval from dual;
~~~

## 索引

这是一种用来提高查询速度的数据库对象，它是添加在数据库表的某个字段上的，当以该字段作为查询条件，会提高查询速度

创建索引：

1. 自动创建 ---- 当表中字段是主键或者唯一约束时，该字段自带索引。
   ~~~~~plsql
   create table mytable0706(
   sno varchar2(32) primary key, -- 自带索引
   sname varchar2(32) ,
   sphone number unique 	-- 自带索引
   );
   ~~~~~

   

2. 手动添加 ---- create index 索引名 on 表名(字段名)
   ~~~~~plsql
   create index my_index0706 on mytable0706(sname);
   ~~~~~

索引的缺点：它会降低增删改的速度，因为在维护数据的同时，还需要花费额外的时间来维护数据上的索引，同时它还会占用资源空间

#### 面试题：

以下下情况不加索引：

1. 表中数据量不大的时候：少于几百万条
2. 该字段不经常被当作where条件
3. 该表中的数据经常被增删改
4. 该字段上的取值范围比较窄

删除索引：

`drop index 索引名`

## 同义词

保存下来的表或视图的别名

创建语法：

~~~plsql
create synonym 同义词名 for 表名或视图名
~~~

例如：

~~~plsql
create synonym s for student;

select * from s; -- 相当于 select * from student
~~~

删除：

~~~plsql
drop synonym  同义词名;
~~~

## PL/SQL语言

这是一门数据库开发语言，用来帮助我们对数据库进行各种复杂的操作

### PL/SQL语法结构：

~~~plsql
declare
声明部分
begin
程序体
exception
异常处理部分
end;
~~~

### 打印语句

~~~plsql
dbms_output.put_line(打印内容);
~~~

例如：

~~~plsql
begin 
  dbms_output.put_line('hello world');
end;
~~~

### 赋值语句

1、查询赋值：

~~~plsql
select 字段名 into 变量名 from 表 where 条件...
~~~

例如：

~~~plsql
declare 
  v_sal number(10,2);
begin
  select e.sal into v_sal from emp e where e.empno = '7369';
  dbms_output.put_line(v_sal);
end;
~~~

~~~plsql
declare
  v_sal number(10,2);
  v_eno number(4);
  v_ename varchar2(10);
  begin
    select e.empno,e.ename,e.sal
    into v_eno,v_ename,v_sal
    from emp e where e.empno = '7369';
    dbms_output.put_line(v_eno||','||v_ename||','||v_sal);
end;
-- 输出结果：7369,SMITH,800
~~~

### 表名.字段名%type

定义变量的时候，类型可以使用`表名.字段名%type`表示当前变量类型和该字段的类型保持一致

例如：

~~~plsql
declare
  v_sal number(10,2);
  v_eno number(4);
  v_ename emp.ename%type; -- 和表中字段类型保持一致
  begin
    select e.empno,e.ename,e.sal
    into v_eno,v_ename,v_sal
    from emp e where e.empno = '7369';
    dbms_output.put_line(v_eno||','||v_ename||','||v_sal);
end;
-- 结果和上面一致
~~~

### 记录

### 记录类型

将一组逻辑相关的变量整合到一块，做成一个类型，再由该类型定义一个变量，那么该变量就可以接收一组值，使用的时候，使用`变量名.属性`即可
定义格式：

~~~plsql
type 记录类型名 is record(
属性1 类型1,
属性2 类型2,
    ...
)
~~~

例如：

~~~plsql
declare 

type my_record is record(
v_eno emp.empno%type,
v_ename emp.ename%type,
v_sal emp.sal%type
);

v_emp my_record;

begin
  select e.empno,e.ename,e.sal
  into v_emp
  from emp e where e.empno = '7369';
  
  dbms_output.put_line(v_emp.v_eno||','||
  v_emp.v_ename||','||
  v_emp.v_sal);
end;

~~~

2、手动赋值：

~~~plsql
declare
v_temp number(10);
begin
  v_temp:=100;
  dbms_output.put_line(v_temp);
end;
~~~

### 变量名 表名%rowtype

定义变量可以声明位一张表中的整行类型

格式：

~~~plsql
变量名 表名%rowtype
~~~

赋值的时候可以将表中整行数据查询赋值给它，使用的时候： `变量名.字段`即可

例如：

~~~plsql
declare 
  v_emp emp%rowtype;
begin
  select * into v_emp from emp where empno = 7369;
  dbms_output.put_line(v_emp.empno||','||v_emp.ename||','||v_emp.sal);
end;
~~~

### commit

在增删改的时候用来提交事务

~~~plsql
declare
v_dname department.dname%type;
begin
  v_dname:='自动化';
  insert into department values (myseq0706.nextval,v_dname,30);
  commit;
end;
~~~

### if语句

格式：

~~~plsql
if 条件1 then
结果1
elsif 条件2 then
结果2
...
else
结果n
end if;
~~~

例如：

~~~plsql
declare
  v_emp   emp%rowtype;
  v_grade varchar2(20);
begin
  select * into v_emp from emp where empno = 7369;
  if v_emp.sal < 1000 then
    v_grade := '拖后腿';
  elsif v_emp.sal < 2000 then
    v_grade := '马马虎虎';
  else
    v_grade := '高薪';
  end if;
  dbms_output.put_line(v_emp.empno || ':' || v_emp.sal || ',' || v_grade);
end;
-- 7369:800,拖后腿
~~~

~~~plsql
-- case when 的写法
declare
  v_emp   emp%rowtype;
  v_grade varchar2(20);
begin
  select * into v_emp from emp where empno = 7369;
  v_grade := case trunc(v_emp.sal / 1000, 0)
               when 0 then
                '拖后腿'
               when 1 then
                '马马虎虎'
               else
                '高薪'
             end;
  dbms_output.put_line(v_emp.empno || ':' || v_emp.sal || ',' || v_grade);
end;

~~~



### 循环

循环四要素：

1. 初始化表达式
2. 布尔值测试表达式
3. 循环体
4. 更改表达式

#### loop循环

~~~plsql
初始化 
loop 
循环体
更改表达式
exit when 
end loop;
~~~

例如：

~~~plsql
-- 正序打印1——100
declare
  v_n number(4);
begin
  v_n := 1;
  loop
    dbms_output.put_line(v_n);
    v_n := v_n + 1;
    exit when v_n > 100;
  end loop;
end;
~~~

#### while 循环

~~~plsql
初始化
while 布尔值测试表达式 loop
循环体
更改表达式
end loop;
~~~

例如：

~~~plsql
declare
  v_n number(4);
begin
  v_n := 1;
  while v_n <= 100 loop
    dbms_output.put_line(v_n);
    v_n := v_n + 1;
  end loop;
end;
~~~

#### for循环

~~~plsql
for 变量 in 下限 .. 上限 loop
循环体
end loop;
end;
~~~

例如：

~~~plsql
declare
begin
  for v_n in 1 .. 100 loop
    dbms_output.put_line(v_n);
  end loop;
end;
~~~

### 游标

它是用来储存一组记录的集合，我们可以使用游标来逐条遍历查询结果集中的数据

在数据库中，游标（Cursor）是一个用于处理查询结果集的数据库对象。它提供了一种机制，可以逐行访问和操作查询结果集中的数据。

操作步骤：
1、定义游标：`cursor 游标名 is select语句`
2、打开游标： `open 游标名`
3、不停地提取游标中的下一条数据：`fetch 游标名 into 变量 ` 并通过 `%found ` 判断是否提到数据，如果提到数据则使用
4、关闭游标：`close 游标名`

~~~plsql
-- 原生态游标写法
declare
  v_ename emp.ename%type;
  v_sal   emp.sal%type;
  -- 定义游标
  cursor my_cur is
    select e.ename, e.sal from emp e;
begin
  -- 打开游标
  open my_cur;
  -- 提取第一条数据到变量中
  fetch my_cur
    into v_ename, v_sal;
  while my_cur%found loop
    dbms_output.put_line(v_ename || ',' || v_sal);
    -- 提取下一条数据到变量中
    fetch my_cur
      into v_ename, v_sal;
  end loop;
  -- 关闭游标
  close my_cur;
end;
~~~

#### 使用for循环操作游标

~~~plsql
for 变量名 in 游标名 loop 
使用 变量名.字段 来操作数据
end loop;
~~~

例如：

~~~plsql
declare
  --定义游标
  cursor my_cur is
    select e.ename, e.sal from emp e;
begin
  for c in my_cur loop
    dbms_output.put_line(c.ename || ',' || c.sal);
  end loop;
end;
~~~

综合题：

~~~plsql
--备份emp表
drop table my_emp;
create table my_emp as select * from emp;

-- 修改my_emp 给员工涨工资
-- <1000 up 20%
-- 1000-1900 up 15%
-- >= 2000 up 10%
declare
  cursor cur_emp is
    select * from my_emp;
  v_temp number(4, 2); -- 涨幅变量
begin
  for c in cur_emp loop
    if c.sal < 1000 then
      v_temp := 0.2;
    elsif c.sal < 2000 then
      v_temp := 0.15;
    else
      v_temp := 0.1;
    end if;
    update my_emp me
       set me.sal = me.sal * (1 + v_temp)
     where me.empno = c.empno;
  end loop;
  commit;
end;
-- 测试看看
select * from my_emp;
select * from emp;
~~~

# 2023年7月7日

## exception

当begin代码块报错的时候，就会跳转到exception代码块进行处理，

格式：

~~~plsql
exception
when 异常名 then 打印提示语句
~~~

### 预定义异常：

对于一些常见的异常，Oracle给它们定义好了异常名，我们直接使用

例如：

~~~plsql
declare
  v_emp emp%rowtype;
begin
  select * into v_emp from emp;
  dbms_output.put_line(v_emp.empno || ',' || v_emp.ename || ',' ||
                       v_emp.sal);
exception
  when TOO_MANY_ROWS then
    dbms_output.put_line('当前sql语句查询到多条数据，无法赋值给一个变量');
end;
~~~

### 非预定义异常

对于一些非常见异常，我们自己定义异常名，它的类型是exception，然后使用 `pragma exception_init(异常名,异常编号)`将该异常名和异常编号绑定。这时，就可以在exception中进行捕获和处理

例如：

~~~plsql
declare
  v_dno dept.deptno%type;
  v_exception_del exception;
  pragma exception_init(v_exception_del, -02292);
begin
  v_dno := 20;
  delete from dept where deptno = v_dno;
  dbms_output.put_line('部门号删除成功');
exception
  when v_exception_del then
    dbms_output.put_line('当前部门下还存在员工，无法删除部门！');
end;
~~~

### 自定义异常

这时我们业务逻辑中不符合某个要求而出现的异常，对于数据库来说没有问题。
我们只需要定义异常变量，然后在抛出的地方，使用 `raise 异常变量名`即可对其捕获和操作

~~~plsql
declare
  v_sal emp.sal%type;
  v_exception_sal exception;
begin
  select sal into v_sal from emp where empno = '7839';
  if v_sal > 4000 then
    raise v_exception_sal;
  else
    dbms_output.put_line(v_sal);
  end if;
exception
  when v_exception_sal then
    dbms_output.put_line('对不起，你吃得太多了，公司决定开除你');
end;
~~~

## 函数

function，我们将PL/SQL代码保存到函数中，可以用来被调用，函数必须有返回值

创建函数：

~~~plsql
create or replace function 函数名(参数列表)
return 返回值类型
is
声明部分
begin
程序体
exception 
异常处理
end;
~~~

注意：函数可以被select语句直接调用，也可以被PL/SQL代码调用

例如：

~~~plsql
-- 无参数版本
create or replace function myfun1 return varchar2 is
begin
  return 'hello world';
end;

-- 调用1
select myfun1 from dual;
-- 调用2
begin
dbms_output.put_line(myfun1);
end;
~~~

~~~plsql
-- 有参数版本
create or replace function myfun2(v_pra varchar2) return varchar2 is
begin
return 'hello:' || v_pra;
end;
-- 调用1
select myfun2('Tom') from dual;
-- 调用2
begin
dbms_output.put_line(myfun2('Tom'));
end;
~~~

~~~plsql
   -- 编写函数，输入一个部门编号，返回该部分薪资总和
  create or replace function myfunc4(v_deptno emp.deptno%type) return number is
    v_totalsal number(10,2);
  begin
    select sum(e.sal)
      into v_totalsal
      from emp e
     where e.deptno = v_deptno;
    return v_totalsal;
  end;
  
  select myfunc4(10) from dual;
~~~

## 存储过程

procedure, 我们将PL/SQL代码保存到存储过程中，可以用来调用，存储过程没有return语句，创建存储过程：

~~~plsql
create or replace procedure 存储过程名(参数列表)
is
声明部分
begin
程序体
exception
异常处理
end;
~~~

存储过程能被PL/SQL代码调用

~~~plsql
-- 创建存储过程：向dept表中插入数据
create or replace procedure mypro1(v_deptno dept.deptno%type,
                                   v_dname  dept.dname%type,
                                   v_loc    dept.loc%type) is
begin
  insert into dept values (v_deptno, v_dname, v_loc);
  commit;
end;
-- 使用存储过程
begin
mypro1(50, '开发部', '上海');
end;
~~~

~~~plsql
  -- 编写存储过程，输入一个部门编号，删除该部门
  -- 如果输入的部门编号不存在，则抛出自定义异常，提示部门号不存在
  -- 如果输入的部门编号被员工关联，则抛出非预定义异常，提示存在员工
  -- 如果可以正常删除，则打印“xxx删除成功”
  create or replace procedure del_dept(v_dno dept.deptno%type) is
    e_noresult   exception;
    e_contentemp exception;
    pragma exception_init(e_contentemp, -02292);
    v_count number;
  begin
    select count(*) into v_count from dept d where d.deptno = v_dno;
    if v_count > 0 then
      delete from dept where deptno = v_dno;
      dbms_output.put_line('已删除编号为' || v_dno || '的部门');
      commit;
    else
      raise e_noresult;
    end if;
  exception
    when e_noresult then
      dbms_output.put_line('对不起，该部门编号不存在');
    when e_contentemp then
      dbms_output.put_line('对不起，该部门存在员工，无法删除');
  end;
~~~

~~~plsql
-- 给my_emp 涨工资，1982年以前入职的，涨20%
-- 1982 - 1985年入职的 涨15%
-- 1985年以后入职的  涨10%


drop table my_emp;
create table my_emp as select * from emp;
-- 创建存储过程
create or replace procedure pro_emp is
v_up  number(4,2);  -- 工资涨幅
cursor my_cur is select *  from my_emp ;  
begin
  for c in my_cur loop
if c.hiredate < to_date('1982-01-01','yyyy-mm-dd') then
  v_up := 0.2;
  elsif c.hiredate < to_date('1986-01-01','yyyy-mm-dd') then 
    v_up := 0.15;
    else v_up := 0.1;
    end if;
    c.sal := c.sal * (1 + v_up);
    update my_emp me set me.sal = c.sal where me.empno = c.empno;
end loop;
commit;
end;
-- 运行存储过程
begin 
  pro_emp;
  end;

-- 查看结果
select * from my_emp;
~~~

### 存储过程的参数形式

1、in ---- 只能接收输入参数，它不能改变传入的值，也不能输出
2、默认  ---- 相当于 in
3、out ---- 不能接收输入的参数，可以改变值，并且输出返回
4、in out ---- 既能接收输入参数，又能改变值并且输出返回。

~~~plsql
create or replace procedure my_pro(v1 number,
                                   v2 in number,
                                   v3 out number,
                                   v4 in out number) is
begin
  dbms_output.put_line('v1:' || v1 || ',' || 'v2:' || v2 || ',' || 'v3:' || v3 || ',' ||
                       'v4:' || v4);
  -- v1 := 101;
  -- v2 := 201;
  v3 := 301;
  v4 := 401;
end;

declare v1_t number(10); v2_t number(10); v3_t number(10); v4_t number(10);
begin
v1_t := 100; v2_t := 200; v3_t := 300; v4_t := 400;

my_pro(v1_t, v2_t, v3_t, v4_t); dbms_output.put_line('v1:_t' || v1_t || ',' || 'v2_t:' || v2_t || ',' || 'v3_t:' || v3_t || ',' || 'v4_t:' || v4_t);
end;
-- 打印结果：
--v1:100,v2:200,v3:,v4:400
--v1:_t100,v2_t:200,v3_t:301,v4_t:401

~~~

注意：在函数和存储过程中，如果需要做模糊查询，那么左%和右%是单独拼写在条件字符串中的。

~~~plsql
create or replace procedure my_pro(likevalue varchar2) is cursor my_cur is
  select * from emp e where e.ename like '%' || likevalue || '%';
begin
  for c in my_cur loop
    dbms_output.put_line(c.empno || ',' || c.ename || ',' || c.sal);
  end loop;
end;

begin
  my_pro('A');
end;
~~~

## 删除函数和存储过程

~~~plsql
-- 删除函数
drop function 函数名;
drop procedure 存储过程名;
~~~

## trigger

触发器：它监控着数据库中的某张表上的数据的增删改操作，当发生指定的操作时，自动出发PL/SQL代码执行

语法：

~~~plsql
create or replace trigger 触发器名
before/after
insert/update/delete
on	表名
for each row
声明部分
begin
执行部分
end;
~~~

注意： for each row表示行级触发器，每更新一行触发一次，如果不写，，则是语句级触发器，每执行一条语句触发一次。

~~~plsql
create or replace trigger my_tri1
after
update 
on my_emp
for each row
  begin
    dbms_output.put_line('hello world');
    end;
~~~

`:old.字段名` ---- 在触发器中可以获取该字段增删改操作之前的值

~~~plsql
-- 创建备份表
create table my_emp_bak as select * from my_emp where 1=2; 

-- 实时对被删除的数据进行备份的触发器
create or replace trigger my_tri2
  before delete on my_emp
  for each row
begin
  insert into my_emp_bak
  values
    (:old.empno,
     :old.ename,
     :old.job,
     :old.mgr,
     :old.hiredate,
     :old.sal,
     :old.comm,
     :old.deptno);
end;


select * from my_emp;
select * from my_emp_bak;

delete from my_emp ; 
-- 当my_emp表中数据被删除时，会立刻往my_emp_bak中添加相同数据
~~~

## 键盘输入

~~~plsql
变量名 := '&变量名';
~~~

~~~plsql
declare
  v_1 number;
  v_2 varchar2(255);
begin
  v_1 := '&v_1';
  v_2 := '&dsfsdfsd'; -- '&后面随便写点啥都行
  dbms_output.put_line(v_1);
  dbms_output.put_line(v_2);
end;
~~~

## 对一张表的增删改查存储过程

~~~plsql
select * from dept;

create or replace procedure addOne(v_deptno dept.deptno%type,
                                   v_dname  dept.dname%type,
                                   v_loc    dept.loc%type) is
begin
  insert into dept values (v_deptno, v_dname, v_loc);
  commit;
end;

  create or replace procedure deleteOne(v_deptno dept.deptno%type) is
  begin
    delete from dept where dept.deptno = v_deptno;
  end;
  
  create or replace procedure updateOne(v_deptno dept.deptno%type,
                                        v_dname  dept.dname%type,
                                        v_loc    dept.loc%type) is
  begin
    update dept
       set dept.dname = v_dname, loc = v_loc
     where deptno = v_deptno;
  end;
  
  
  create or replace procedure findALL is
    cursor v_depts is
      select * from dept;
  begin
    for c in v_depts loop
      dbms_output.put_line(c.deptno || ',' || c.dname || ',' || c.loc);
    end loop;
  end;
      
      create or replace procedure findById(v_deptno dept.deptno%type) is
        v_dept dept%rowtype;
      begin
        select * into v_dept from dept where deptno = v_deptno;
        dbms_output.put_line(v_dept.deptno || ',' || v_dept.dname || ',' ||
                             v_dept.loc);
      end;
        
        -- 查询所有
        declare
        begin
          findAll;
        end;
          
          -- 查询一条
          declare
          begin
            findById('40');
          end;
        
        -- 删除一条
        declare
        begin
          deleteOne('50');
        end;
          
          -- 增加一条
          declare
          begin
            addOne('50', '测试部', '背景');
          end;
        -- 修改一条
        declare
        begin
          updateOne('50', '轻音部', '日版');
        end;

~~~



 
