瀑布模型：

- 需求规格说明书
- 概要设计（包括数据库设计）
- 详细设计（伪代码之类的）
- 编码
- 测试

----------------------

小厂一般使用敏捷开发



2023年7月3日

# 数据库

设计基本步骤：

>1. 找名词
>2. 把名词分两类（实体，属性）
>3. 一个实体一张表
>     一个属性一个字段
>4. 确定表和表之间的关系:
>   - 1对1：主表中添加从表的编号作为关联字段
>   - 1对多：在多的一端中添加1的一端的编号作为关联字段
>   - 多对多：再添加一张关系表用来记录两边的编号

### **ER图**：

### 辅助我们进行数据库表结构设计的工具

在ER图中

> 矩形：实体
> 椭圆：属性
> 菱形：关系

![ER图](https://res.cloudinary.com/dvqgs9esp/image/upload/v1688353564/ER图_q01tnx.png)

### 范式：

### ————判断数据库中某张表设计的好坏的规范

> 1. 第一范式：列不可分（每一个字段都是不可再分的最小原子单位）
> 2. 第二范式：要有主键，不存在部分依赖
>    （主键：某个字段非空唯一）
>    （联合主键：多个字段的组合作为主键）
>    （所有非主键字段必须完全依赖联合主键）
> 3. 第三范式：不存在传递依赖
>    （所有非主键字段必须直接依赖主键）

## Oracle

sql	---- 标准的查询语言
DDL ---- 数据定义语言：针对数据库对象操作的
DML ---- 数据操纵语言：针对数据操作的

~~~sql
-- 查询服务器时间
select sysdate from dual;
~~~

关于dual：

1. dual不是缩写词，本身就是完整的单词
2. Oracle中的dual表是一个单行单列的虚拟表
3. Dual表是oracle与数据字典一起地总创建的一个表，这个表只有1列：DUMMY，数据类型为VERCHAR2(1)，dual表中只有一个数据：‘X’，Oracle有内部逻辑保证dual表中永远只有一条数据。
4. Dual表主要用来选择系统变量或求一个简单的例子：
   SELECT sysdate FROM daul
   而Oracle的SELECT语法限制为：
   SELECT * FROM table
   所以，没有表名就没有办法查询，而时间日期并不存放在任何表中，于是这个dual虚拟表的概念就被引入了。
5. dual表的用途：
   dual是Oracle中的一个实际存在的表，任何用户均可读取，常用在没有目标表的SELECT语句块中

### 创建一张表：

~~~sql
CREATE TABLE 表名(
字段1 类型，
字段2 类型，
    ...
)
~~~

例如：
~~~sql
CREATE TABLE comifo20230703(
pno VARCHAR2(32),
pname VARCHAR2(32),
gender VARCHAR2(6),
birthday DATE,
phone NUMBER(32)
);
~~~

### 事务

数据库中保证数据准确性，完整性，一致性和原子性的一种机制，当我们增删改数据后，需要提交事务，事务不仅可以被提交，还可以被回滚。

### 修改一张表

1. 添加字段：

~~~sql
ALTER TABLE 表名 ADD(
字段名 类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 ADD(
qq number(32)
);
~~~

2. 修改字段名

~~~sql
ALTER TABLE 表名 RENAME 旧字段名 TO 新字段名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME COLUMN qq TO wechat;
~~~

3. 修改字段类型

~~~sql
ALTER TABLE 表名 MODIFY(
字段名 新类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 MODIFY(
wechat varchar2(32)
);
~~~

4. 删除字段

~~~sql
ALTER TABLE 表名 DROP(字段名);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 DROP(wechat);
~~~

5.修改表名

~~~sql
ALTER TABLE 旧表名 RENAME TO 新表名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME to comifo0703;
~~~

### 删除一张表

~~~sql
DROP TABLE 表名;
~~~

例如：

~~~sql
DROP TABLE comifo0703;
~~~

### 插入一条记录

~~~sql
INSERT INTO 表名(字段1,字段2,...)
VALUES('值1','值2',...);
~~~

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname, phone)
VALUES
  ('1001', '张三', '18112923121');
~~~

语句执行完成后要手动提交事务（？？？一般来说数据库系统会自动提交事务，所以这到底是什么原因呢？？？）

注意：当对表中所有字段插入数据时，values前面的小括号可以省略



### 字符串转日期函数

to_date(日期字符串，日期格式)

注意：在格式中，y表示年，m表示月，d表示日，hh表示12小时制，hh24表示24小时制，mi表示分钟，ss表示秒。

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname,gender,birthday, phone) 
VALUES
  ('1002', '李四','男',to_date('2001-06-15','yyyy-mm-dd'),'13944572390');
~~~

~~~sql
INSERT INTO comifo703
  (pno, pname, gender, birthday, phone)
VALUES
  ('1004',
   '荀一',
   '男',
   TO_DATE('2000-07-31 13：23：32', 'yyyy-mm-dd hh24:mi:ss'),
   '1391221390');
~~~



### 修改字段

~~~sql
UPDATE 表名 SET 字段名 = 字段值 WHERE　条件语句; 
~~~

例如：

~~~sql
UPDATE comifo703 SET phone = '5542278383' WHERE pno = '1002';
~~~

### 删除语句

~~~sql
DELETE FROM 表名 WHERE 条件语句;
~~~

例如：

~~~sql
DELETE FROM comifo703 WHERE pno = '1001';
~~~

### 查询语句

~~~sql
SELECT 字段1,字段2,... FROM 表名 WHERE 条件;
~~~

例如：

~~~sql
 SELECT pno,pname,phone FROM comifo703 WHERE pno = '1002';
~~~

### 日期型转字符串型

to_char()

例如：

~~~sql
SELECT pno, pname, to_char(birthday, 'yyyy-mm-dd'), phone
  FROM comifo703
 WHERE pno = '1002';
~~~

### 约束

1.非空 ---- NOT NULL

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL	-- 非空
);
~~~

2.唯一 ---- UNIQUE

注意：如果非空并且唯一，那么UNIQUE需要单独编写：
~~~sql
CONSTRAINT 约束名 UNIQUE(字段)
~~~

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL,
CONSTRAINT uk703 UNIQUE(phone) -- 唯一
);
~~~

注意：小括号中如果有多个字段，则表示他们的组合不能重复。此外，如果要为组合添加约束，则必须使用constraint语句，而不能将unique挂在字段类型的后面

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

3.主键约束 ---- PRIMARY KEY

自带非空唯一的功能

例如：

~~~sql
DROP TABLE comifo703;

CREATE TABLE comifo703(
pno varchar2(32) PRIMARY KEY, -- 主键约束
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

主键约束也可以使用constraint编写
constraint 约束名 primary key(字段)

注意：小括号内如果有多个字段，则表示他们是联合主键。
例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname),
constraint pk703 primary key(pno,pname) -- 联合主键
);
~~~

2023年7月4日

### 外键

将某张表中的主键字段添加到另一张表中作为关联字段，那么该字段称为外键

外键约束两层含义：

1、当添加子表数据时，外键值必须是父表主键中已存在的值。
2、当删除父表数据时，主键值必须没有被子表关联使用。

例如：

~~~sql
create table class0704(
cno varchar2(32) primary key,
cname varchar2(32),
ccount number (10)
);

select * from class0704;

insert into class0704 
values
(1001,'A班',32);

create table student0704(
sno varchar2(32) primary key,
sname varchar2(32),
sage number(10),
cno varchar2(32) references class0704(cno) -- 外键
);

select * from student0704;

insert into student0704 
values 
(201801,'李四',12,1001); -- 插入的班级必须是已存在的
~~~

### 别名

我们在sql语句中可以给表或者字段起别名，方便我们带出字段名和展示结果集的表头

例如：

~~~sql
select t.tno 编号,t.tname 姓名, t.tsex 性别, t.tage 年龄 from teacher t;
-- 或
select t.tno as 编号,t.tname as 姓名, t.tsex as 性别, t.tage 年龄 from teacher as t;
-- 建议加as
~~~

### 排重

在select子句部分的字段名前面添加distinct

### 排序

在查询语句最后添加order by子句，用来排序，格式：

~~~sql
order by 字段名 asc/desc
-- desc表示降序，asc表示升序，asc可以省略
~~~

例如：

~~~sql
select distinct t.tno, t.tname from teacher t order by t.tno desc;
~~~

```sql
select distinct t.tno, t.tname, t.tsex
  from teacher t
 order by t.tsex, t.tname, t.tno desc;
```

注意：汉字的大小顺序是unicode编码中的先后顺序

按照薪水高低查询所有男教师信息：

```sql
select * from teacher t where t.tsex = '男' order by t.sal desc;
```

### 常用的比较运算符

```sql
> 大于
>= 
<
<=
!=   -- 只在Oracle数据库中有效
<>
=
between 上限a and 下限b  -- 在[a,b]范围内
is null
is not null
```

### 多条件查询

and ---- 并且
or ---- 或者

```sql
select *
  from teacher t
 where t.tage > 45
   and t.tsex = '男';

select *
  from teacher t
 where t.birplace = '江苏'
    or t.birplace = '浙江';
    
    -- 注意多种逻辑运算符共存的时候，建议使用小括号把先算的部分括起来。
    -- 查询所有女教师和薪水大于9000的男教师
 select *
  from teacher t
 where t.tsex = '女'
    or (t.tsex = '男' and t.sal > 9000);
```

### in 和 not in

in  在指定的范围内筛选

not in  在指定范围以外筛选

格式：`in (值1,值2)`

例如：

```sql
select * from teacher t where t.birplace not in ('北京', '上海', '江苏');
```

### like

模糊查询

格式：

```sql
-- 全匹配 '%关键字%'
select * from teacher t where t.birplace like '%江%';
-- 左匹配 '关键字%'
-- 右匹配 '%关键字'
```

### 聚合分析函数

avg(字段) ---- 求平均值

sum(字段) ---- 求和

max(字段) ---- 求最大值

min(字段) ---- 求最小值

count(字段) ---- 计数

### 数值截取函数

round(数值，小数位) ---- 以四舍五入的方式截取数值

trunc(数值，小数位) ---- 以直接丢弃的方式截取数值

```sql
select round(avg(t.sal),2) 平均工资 from teacher t;
select trunc(avg(t.sal),2) 平均工资 from teacher t;
```

### 分组语句

group by

例如：

```sql
select trunc(avg(t.sal),2) ,t.tsex from teacher t
group by t.tsex;
```

注意：select后面只能添加group by的非函数字段，否则报错。

### having

如果需要在函数的结果上进行判断，不能使用where，只能使用having，having子句需要写在group by子句的后面。

例如：

```sql
select count(*), s.sex from student s group by s.sex having count(*) > 3;
```

```sql
-- 统计哪些籍贯不止一个老师
select count(*), t.birplace
  from teacher t
 group by t.birplace
having count(*) > 1;
```

### 子查询

一个查询语句的结果是另一个查询语句的条件，这样的select语句成为子查询语句

例如：

```sql
-- 查询和李树标同一系别的教师信息
select *
  from teacher t1
 where t1.dno = (select t.dno from teacher t where t.tname = '李树标')
   and t1.tname <> '李树标';
```

```sql
-- 统计学生表中系别和赵静想同，但是年龄比赵静大的同学的信息
select *
  from student s1
 where s1.dno = (select s.dno from student s where s.sname = '赵静')
   and s1.birthday <
       (select s2.birthday from student s2 where s2.sname = '赵静');
```

注意：如果子查询返回的结果集条数大于一条，那么外层查询只能使用in进行关联。

```sql
select *
  from student s1
 where s1.classid in
       (select s.classid
          from student s
         where s.birthday between to_date('1983-01-01', 'yyyy-mm-dd') and
               to_date('1984-12-31', 'yyyy-mm-dd'));
```



### for update

在select语句后面添加for update；可以实现图形化界面的增删改操作。

```sql
select * from student s for update;
```

### 多表关联

`select 字段 from 表1,表2,... where 关联条件`
注意：如果关联条件不够，则会出现笛卡尔乘积的问题
正确写法如下：

```sql
-- 统计每个教师的编号、姓名、系别名称
select t.tno, t.tname, d.dname
  from teacher t, department d
 where t.dno = d.dno;
```

注意：子查询也能实现多表关联

```sql
select t.tno, t.tname
  from teacher t
 where t.dno = (select d.dno from department d where d.dname = '计算机系')
```



### left join

左外关联
左边的表中所有记录全部展示，右边的表中的记录有则展示，无则留空。

格式：
`select 字段 from 左表 left join 右表 on 关联条件`

例如：

```sql
select * from teacher t left join department d on t.dno = d.dno;
```

注意：Oracle中的关联查询可以实现(+)的另一边全部展示

例如：

```sql
-- 和以上代码功能一样，
select * from teacher t ,department d where t.dno = d.dno(+);
```

### inner join

等于用等号进行两表关联，inner可以省略

例如：

```sql
select * from teacher t inner join department d on t.dno = d.dno;
```

### union

在两个select语句中实现并集，要求两个select语句字段类型和个数相同，union自带排重功能，union all 不会排重

例如：

```sql
-- 找出所有男老师和男学生的名字
select s.sname from student s where s.sex = '男'
union all
select t.tname from teacher t where t.tsex = '男';
```

```sql
-- 统计所有男学生选的课程名
-- 以及所有男老师教授的课程名
-- 以及所有课时>40的课程名
select c.cname from course c,student s,s_course sc
where c.cno = sc.cno and sc.sno = s.sno and s.sex = '男'
union 
select c1.cname from course c1, t_course tc,teacher t
where c1.cno = tc.cno and tc.tno = t.tno and t.tsex = '男'
union 
select c2.cname from course c2 where c2.ctime > 40;
```

### intersect

交集

```sql
-- 统计韩信和赵汗青选修了哪些相同的课程，展示课程名
select c.cname
  from course c, s_course sc, student s
 where c.cno = sc.cno
   and sc.sno = s.sno
   and s.sname = '韩信'
intersect
select c1.cname
  from course c1, s_course sc1, student s1
 where c1.cno = sc1.cno
   and sc1.sno = s1.sno
   and s1.sname = '赵汗青';
```

### minus

差集

由生日计算年龄

```sql
select s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age -- 由生日计算年龄
  from student s
 where s.sno in (select sc.sno from s_course sc where sc.mark < 60);

```

```sql
-- 查询不存在挂科人的信息
select distinct s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s,s_course sc
 where s.sno = sc.sno and  s.sno not in (
 select sc.sno from s_course sc where sc.mark < 60 
 );
 
 -- 另一种思路，把最低分大于等于六十的查出来
 select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in ( select sc.sno
                   from s_course sc
                  group by sc.sno
                 having min(sc.mark) >= 60);
```

```sql
-- 查询至少有2门成绩在65以上的同学的信息
select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in (
select sc.sno from s_course sc 
where sc.mark >=65 
group by sc.sno
having count(sc.sno)>=2);
```

练习：

```sql
 -- 对于emp中有管理者的员工，列出姓名，管理者姓名（MGR表示管理者）
 -- 实现了自己关联自己
 select e1.ename as 姓名,e2.ename as 管理者姓名
 from emp e1,emp e2
 where e1.mgr is not null and e1.mgr = e2.empno;
```

```sql
-- 查询同时选修java基础和高等数学两门课，的同学，
-- 并且他的java基础的分数要比高等数学的分数要高，
-- 展示这样的学生信息
select * from student s where s.sno in(
select sc1.sno from s_course sc1 ,s_course sc2 
where sc1.sno = sc2.sno    -- 同一个人
and sc1.cno = (            -- 这个人选修了java基础
select c.cno from course c where c.cname = 'java基础')
and sc2.cno = (            -- 这个人选修了高等数学
select c1.cno from course c1 where c1.cname = '高等数学')
and sc1.mark > sc2.mark    -- java基础分数比高等数学高
);

-- 用临时表改写
-- 造两张临时表
-- 一张表：展示所有选修java基础的同学的信息，以及java基础的分数
-- 另一张：展示所有选修高等数学的同学的信息，以及高等数学的分数
 with t1 as(select s.sno,s.sname ,s.sex,sc.mark  -- 这里不能将写成select * 的原因：如果使用select * 则t1表内有两列字段名都叫sno，在进行总查询的时候，t1.sno就无法确定是哪一列sno，产生未明确定义列错误
            from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = 'java基础'
 ),
 t2 as (select s.sno,s.sname ,s.sex,sc.mark 
        from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = '高等数学'
 )
 select t1.sno,t1.sex,t1.sname from t1,t2 where t1.sno = t2.sno and t1.mark > t2.mark;
```

2023年7月5日

### 临时表

它可以辅助我们编写select语句
把临时需要的一些数据先统计出来，形成临时表，执行完查询语句后，该临时表不会保存在数据库中。
格式：

```sql
with 表名1 as(select语句),
表名2 as(select语句)
总的查询语句
```

```sql
-- 查询所有偏科的同学
-- 偏科：
-- 个人总均分大于所有人所有课的总均分
-- 存在挂科
with t1 as
 (select sc.sno, avg(sc.mark) as peravg from s_course sc group by sc.sno)
select s.*
  from student s, s_course sc, t1
 where s.sno = sc.sno
   and s.sno = t1.sno
   and t1.peravg > (select avg(sc1.mark) from s_course sc1)
   and sc.mark < 60;

```

### substr

`substr(字符串,从第几位开始,截取几位)` ---- 从左往右截取字符串

例如：

```sql
select substr('this is a String',6,2) from dual; -- 结果为is
```

length(字符串) ---- 查询这个字符串的长度

从右往左截取方式：
`substr(字符串,-截取位数)` 
`substr(字符串,length(字符串)-截取位数+1,截取位数)`

### case语句

用来做分支判断，然后造一个字段

格式1：

```sql
case when 条件1 then 结果1
	when 条件12 then 结果2
	...
	else 结果n
	end as 别名
```

例如：

```sql
select sc.sno,
       sc.cno,
       sc.mark,
       case
         when sc.mark < 60 then
          '差'
         when sc.mark < 80 then
          '中'
         when sc.mark < 90 then
          '良'
         when sc.mark <= 100 then
          '优'
         else
          '其他'
       end as 等级
  from s_course sc;
```

格式2：

~~~plsql
case 字段名 when 值1 then 值2
			when 值1 then 值2
			...
			else 结果n
			end as 别名
~~~

例如：

~~~plsql
select s.sno,
       s.sname,
       case s.sex
         when '男' then
          'boy'
         when '女' then
          'girl'
         else
          'others'
       end as 性别
  from student s;
~~~

注意：格式2可以使用decode函数取代

`decode(字段,值1,结果1,值2,结果2,...)`

例如：

~~~plsql
select s.sno,
       s.sname,
       decode(s.sex, '男', 'boy', '女', 'girl', 'others') as 性别
  from student s;
~~~

#### 列转行

~~~plsql
  select t.student, 
  sum(case when t.course = '语文' then t.score else null end) as 语文,
  sum(case when t.course = '数学' then t.score else null end) as 数学,
  sum(case when t.course = '英语' then t.score else null end) as 英语,
  sum(case when t.course = '物理' then t.score else null end) as 物理
  from test t
  group by t.student;
~~~

~~~plsql
select student ,
sum(decode(course ,'语文',score)) as 语文,
sum(decode(course ,'数学',score)) as 数学,
sum(decode(course ,'英语',score)) as 英语,
sum(decode(course ,'物理',score)) as 物理
from test group by student;
~~~





