# 2023年7月25日

## 流

**流**就像一根根管道，管道的一端连接着当前计算机的CPU，另外一端连接着目标资源

数据就像管道中的水，从一个地方流到另外一个地方。

**IO** ---- input/output

流的分类：

1. 按照输入输出方向分为：输入流和输出流
   **面试题**
   写文件是输出
   读文件是输入
   （站在CPU角度看）
2. 按照数据传输的单位分为：字节流和字符流
3. 按照功能分为：节点流和处理流

流的Java类

`InputStream` ---- 字节输入流

`OutputStream` ---- 字节输出流

`Reader` ---- 字符输入流

`Writer` ---- 字符输出流

注意：所有的流都是继承自以上4个抽象类之一

`FileInputStream` ---- 文件字节输入流，用来读文件
read() ---- 读取文件中的一个字节，返回一个int值，如果读到末尾，则返回-1
close() ---- 关闭该输入流
`File.separator` ---- 当前操作系统的文件分隔符，在`windows`下是`\`，在`Linux`下是`/`

注意：实际开发的过程中，可以一律使用`/`，因为windows会自动将其转成`\`

~~~java
public class Test {

    public static void main(String[] args) {
        InputStream is = null;
        String path = File.separator;
        try {
            is = new FileInputStream("D:" + path + "java" + path + "MyProject" + path + "test20230725" + path + "src" + path + "com" + path + "iweb" + path + "test" + path + "Test.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

`FileOutputStream` ---- 文件字节输出流，用来写文件
write() ---- 往文件中写一个字节
close() ---- 关闭该输出流

~~~java
public class Test2 {

    public static void main(String[] args) {
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new FileInputStream("D:/java/MyProject/test20230725/src/com/iweb/test/Test.java");
            os = new FileOutputStream("D:/Desktop/Test2.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                os.write(i);
            }
            System.out.println("复制成功！");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
                if (os != null)
                    os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
//天下一番
~~~

`FileReader` ---- 文件字符输入流，用来读文件
read() ---- 读取文件中的一个字符，返回一个int值，如果读到末尾，则返回-1
close() ---- 关闭该输入流

~~~java
public class Test3 {

    public static void main(String[] args) {
        Reader reader = null;
        String path = File.separator;
        try {
            reader = new FileReader("D:" + path + "java" + path + "MyProject" + path + "test20230725" + path + "src" + path + "com" + path + "iweb" + path + "test" + path + "Test3.java");
            int i = 0;
            while ((i = reader.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null)
                    reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
//天下一番
~~~

`FileWriter` ---- 文件字符输出流，用来写文件
write() ---- 往文件中写一个字符
close() ---- 关闭该输出流

~~~java
public class Test4 {
    public static void main(String[] args) {
        Writer fw = null;
        try {
            fw = new FileWriter("D:/desktop/myunicode.txt");

            for (int i = 1; i < 50000; i++) {
                fw.write(i);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fw != null) {
                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

~~~

### 缓冲流

在内存开辟一块`8k`大小的缓冲区，当我们第一次读文件的时候，一次性读`8k`个内容到缓冲区，然后从缓冲区拿一个字节或字符进行使用，当缓冲区数据用完，才会再次访问硬盘读取`8k`数据，如此反复，极大地减少了对硬盘的访问次数，有效保护硬盘，并提高效率。

`BufferedInputStream `---- 字节缓冲输入流

~~~java
public class Test5 {

    public static void main(String[] args) {
        InputStream is = null;
        BufferedInputStream bis = null;
        String path = File.separator;
        try {
            is = new FileInputStream("D:" + path + "java" + path + "MyProject" + path +
                    "test20230725" + path + "src" + path + "com" + path +
                    "iweb" + path + "test" + path + "Test5.java");
            bis = new BufferedInputStream(is);
            int i = 0;
            while ((i = bis.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bis != null)
                    bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

`BufferedReader` ---- 字符缓冲输入流

`readLine()` ---- 可以读取一行的内容到一个字符串中

`BufferedWriter `---- 字符缓冲输出流

`write() `---- 写入一个字符串到缓冲区，如果缓冲区满了，自动写入硬盘

`newLine() `---- 另起一行

`flush()` ---- 清空缓冲区的内容并将其存入硬盘

~~~java
public class Test6 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = null;
        BufferedWriter bw = null;

        try {
            bw = new BufferedWriter(new FileWriter("D:/desktop/hello.txt"));
            br = new BufferedReader(new FileReader("D:/desktop/hello.txt"));
            for (int i = 0; i < 100; i++) {
                bw.write(String.valueOf(Math.random()));
                bw.newLine();
            }
            bw.flush();
            String s = null;
            while ((s = br.readLine()) != null) {
                System.out.println(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (br != null)
                    br.close();
                if (bw != null)
                    bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

## `Axios`发送请求

### `@CrossOrigin`

控制器类添加该注解可以解决前后端分离项目存在的跨域问题

get请求 ----` this.$axios.get(url)`

post请求 ----` this.$axios.post(url,参数的json字符串)`

我们使用`querystring`对象调用`stringify(json参数)`可以将json参数转json字符串

~~~js
		mounted() {
			console.log("该组件渲染完成");
            //查询全部
			this.$axios.get('http://127.0.0.1:8088/book/queryAll')
				.then(function(response) {
					console.log(response);
				})
				.catch(function(error) {
					console.log(error);
				});
            //新增一条
			this.$axios.post('http://localhost:8088/book', qs.stringify({
					bookname: '昆虫记',
					author: '法布尔'
				}))
				.then(function(response) {
					console.log(response)
				})
				.catch(function(error) {
					console.log(error)
				});


			//修改一条
			this.$axios.put('http://localhost:8088/book', qs.stringify({
					id: '1036',
					bookname: '晚明',
					author: '柯山梦'
				}))
				.then(function(response) {
					console.log(response)
				})
				.catch(function(error) {
					console.log(error)
				});
			//删除一条
			this.$axios.delete('http://localhost:8088/book/1037')
				.then(function(response) {
					console.log(response);
				})
				.catch(function(error) {
					console.log(error);
				});
		}
~~~

`SpringMVC`中的`@PathVariable`注解

可以绑定url中的占位符到方法形参，占位符需要使用一对大括号包起来

## 全局url配置

在`main.js`中添加`Axios.defaults.baseURL = 'http://ip地址:端口'`

每个发请求的地方直接从`"/"`开始写url即可，`"/"`表示web站点根目录

## 拦截器

我们在`Axios`中可以添加拦截器拦截所有的请求，来处理请求中的数据

格式：

~~~js
//main.js中添加：
Axios.interceptors.request.use(function (config){

......

})
~~~

`config.method ` ---- 表示请求方法

`config.data `---- 表示请求参数

`js`中 == 和 === 区别：
`js`中==只会比较数值是否相等，不考虑类型
===不仅要求数值相等，而且类型必须一样

## `<button>` ---- 按钮

`<button v-on:click="方法名">`  调用一个`js`方法

alert(字符串); ---- 弹出一个对话框，展示相应字符串

## 2023年7月26日

## `PrintWriter`

打印流

可以打印日志文件，它提供了各种重载的`print()`和`println()`方法用于打印，它只有输出没有输入，它不会抛异常

它自带缓冲区，他需要调用close()进行关闭

## `InputStreamRead`

这是一个字节流转字符流的桥梁，当传入一个字节流时，会返回对应的字符流。

~~~java
public class Test {

    public static void main(String[] args) {
        PrintWriter pw = null;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            pw = new PrintWriter(new FileWriter("D:/desktop/log.txt", true));
            String s = null;
            while ((s = br.readLine()) != null) {
                if ("exit".equals(s))
                    break;

                System.out.println(s);
                pw.println(s);
                pw.println("====================");
            }

            pw.println("================" + new Date() + "================");
            pw.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (pw != null)
                pw.close();

        }

    }
}
~~~

## UTF-8

这是一种编码格式 ---- 可变长度的Unicode编码

## Socket

这是客户端的插座，它可以获取连接服务器的输入输出流

## `ServerSocket`

这是服务器端的插座，它可以接收来自客户端的请求，

accept() ---- 这是一个阻塞的方法，他可以等待并获取来自某个客户端的Socket对象，然后获取该客户端的输入输出流

服务器必须先启动，然后等待，由客户端主动发送请求，客户端在`OutputStream`中写入数据，服务器在`InputStream`中接收数据

`DataInputStream和DataOutputStream`

数据流

它可以在网络上进行`UTF-8`数据格式的传输

简单客户端服务器：

~~~java
//服务器
public class MyServer {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        DataInputStream dataInputStream = null;
        Socket socket = null;

        DataOutputStream dataOutputStream = null;

        try {
            serverSocket = new ServerSocket(9527);
            while (true) {
                socket = serverSocket.accept();
                InputStream inputStream = socket.getInputStream();
                dataInputStream = new DataInputStream(inputStream);
                String str = dataInputStream.readUTF();
                System.out.println(str);


                //向客户端回信息
                //OutputStream outputStream = socket.getOutputStream();
                //dataOutputStream = new DataOutputStream(outputStream);
                //dataOutputStream.writeUTF("hello client,this is your server");
                (new DataOutputStream(socket.getOutputStream())).writeUTF(
                        "hello client,this is your server");
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dataInputStream != null)
                    dataInputStream.close();
                if (dataOutputStream != null)
                    dataOutputStream.close();
                if (serverSocket != null)
                    serverSocket.close();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
//客户端
public class MyClient {
    public static void main(String[] args) {
        Socket socket = null;
        DataOutputStream dataOutputStream = null;
        DataInputStream dataInputStream = null;

        try {
            socket = new Socket("127.0.0.1", 9527);
            OutputStream outputStream = socket.getOutputStream();
            dataOutputStream = new DataOutputStream(outputStream);
            dataOutputStream.writeUTF("hello");


            //接收服务器发来的消息
            dataInputStream = new DataInputStream(socket.getInputStream());
            String str = dataInputStream.readUTF();
            System.out.println(str);


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dataOutputStream != null)
                    dataOutputStream.close();
                if (dataInputStream != null)
                    dataInputStream.close();
                if (socket != null)
                    socket.close();


            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
~~~

## 反射

当某个类被加载到内存的时候，JVM会自动创建该类的Class对象，这就是它的反射对象，反射对象就像是一面镜子一样照射着当前正在加载的这个类，把类结构看得清清楚楚，它可以帮助我们创建该加载类对象，访问成员变量，调用方法。

获取Class对象的方式：

1. 对象名.getClass();
2. 类名.class
3. Class.forName("加载类的全类名")

~~~java
    public static void main(String[] args) {
        //方法1
        Person p = new Person();
        Class c1 = p.getClass();
        System.out.println(c1);
        //方法2
        Class c2 = Person.class;
        System.out.println(c2);
        //方法3
        Class c3 = null;
        try {
            c3 = Class.forName("com.iweb.test.Person");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

    }
~~~

**注意**：一个类只有唯一的一个Class对象

newInstance() ---- 反射对象调用该方法来创建加载类对象 **注意：**实际调用的是该加载类的无参构造方法

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~

打印结果：

~~~java
我是无参构造方法
com.iweb.test.Person@14ae5a5
~~~

## Field

这表示一个加载类的某个成员变量的对象

1. 如果成员变量是public
   我们使用Class对象.getField(成员变量名)就可以获取该Field对象

2. 如果成员变量是非public
   我们使用Class对象.getDeclaredField(成员变量名)就可以获取该Field对象，然后由Field.setAccessible(true)进行授权即可

我们使用Field对象.set(加载类的对象，成员变量值) ---- 可以给该对象的成员变量赋属性值

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
            Field f1 = p1.getClass().getField("pname");
            f1.set(p1, "张三");
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~



~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
            Field f1 = c1.getField("pname");
            f1.set(p1,"张三");
            System.out.println(p1);
            Field f2 = c1.getDeclaredField("page");
            f2.setAccessible(true);
            f2.
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~





