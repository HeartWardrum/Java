## 什么是字节码？

在java中，JVM可以理解的代码就叫做字节码（即扩展名为`.class`的文件），他不面向任何特定的处理器，只面向虚拟机。java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题。

`JIT(Just-in-time) compilation`，运行时编译，当`JIT`编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也是我们为什么常说java是编译与解释共存的语言。

## 为什么说 Java 语言“编译与解释并存”？

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

## Java 和 C++ 的区别?

我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。

虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制`GC`，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。
- ......

## 关键字default

`default` 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。

- 在程序控制中，当在 `switch` 中匹配不到任何情况时，可以使用 `default` 来编写默认匹配的情况。
- 在类，方法和变量修饰符中，从 `JDK8` 开始引入了默认方法，可以使用 `default` 关键字来定义一个方法的默认实现。
- 在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 `default`，但是这个修饰符加上了就会报错。

## 移位操作符

移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。

## 如果移位的位数超过数值所占有的位数会怎样？

当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。

也就是说：`x<<42`等同于`x<<10`，`x>>42`等同于`x>>10`，`x >>>42`等同于`x >>> 10`

## 基本类型VS包装类型

**用途**：除了定义一些常量和局部变量之外，我们在其他地方，比如方法参数、对象属性中很少会使用基本数据类型来定义变量。并且，包装类型可用于泛型，而基本类型不行。

**存储方式**：基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被`static`修饰）存放在Java虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。

**占用空间**：相比于包装类型（对象类型），基本数据类型占用的空间往往非常小

**默认值**：成语变量包装类型不赋值就是null，而基本类型有默认值且不是null

**比较方式**：

- 对于基本数据类型来说，`==`比较的是值
- 对于包装数据类型来说，`==`比较的是对象的内存地址，所有整型包装类对象之间值的比较，全部使用equals()方法

### 注意

基本数据类型

- 作为局部变量时存放在栈区
- 作为成员变量时存放在堆区

## 包装类型的缓存机制

java包装类的缓存机制，是在`java5`中引入的一个有助于节省内存、提高性能的功能。java基本类型的包装类大部分都提供了对象的缓存，实现方式是在类初始化时提前创建好会频繁使用的包装 类对象，当需要使用某个包装类的对象时，如果该对象包装的值在缓存的范围内，就返回缓存的对象，否则就创建新的对象并返回。

只有在自动装箱时有效，使用构造函数创建对象不适用

~~~java
		Integer i1 = 1;
		Integer i2 = new Integer(1);//会创建新的对象，不适用
		System.out.println(i1 == i2);//false
~~~

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

~~~java
        Integer i1 = 127;
        Integer i2 = 127;
        Integer i3 = 128;
        Integer i4 = 128;
        System.out.println(i1 == i2);//true
        System.out.println(i3 == i4);//false
~~~



两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。

## 自动装箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

~~~java
Integer i = 10;  //装箱
int n = i;   //拆箱
~~~

从字节码中，我们发现装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

因此，

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`;

注意：**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

## 超过 long 整型的数据应该如何表示？

基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。

在 Java 中，64 位 long 整型是最大的整数类型。



```java
long l = Long.MAX_VALUE;
System.out.println(l + 1); // -9223372036854775808
System.out.println(l + 1 == Long.MIN_VALUE); // true
```

`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。

相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。

~~~java
        long l = Long.MAX_VALUE;
        System.out.println(l);
        System.out.println(l+1);                          //9223372036854775807
        BigInteger bi = BigInteger.valueOf(l);            //-9223372036854775808
        System.out.println(bi.add(BigInteger.valueOf(1)));//9223372036854775808
~~~



## 变量

### 成员变量与局部变量的区别？

1、**语法形式**：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被public、private、static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。

2、**存储方式**：从变量在内存中的存储方式来看，如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存中，局部变量则存在于栈内存中。

3、**生存时间**：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法调用的结束而消亡

4、默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外：被final修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值

### 静态变量有什么用？

静态变量就是被static修饰的变量，可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量，也就是说，静态变量只会被分配一次内存，即使创建多个对象。这样可以节省内存。

静态变量是通过类名来访问的

通常情况下，静态变量会被final关键词修饰为常量

## 字符型常量和字符串型常量的区别？

- 形式：字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符
- 含义：字符常量相当于一个整型值（ASCII值），可以参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放位置）
- 占内存大小：字符常量只占2个字节；字符串常量占若干个字节。

注意：char在Java中占两个字节

## 静态方法不能被重写但是能被重新定义

1、**静态方法不能被重写**

~~~java
class Animal {
	public static void walk() { System.out.println("Animal行走方法"); }
}
public class Horse extends Animal {
	public void walk() { //--------直接报错
		System.out.println("Horse四条腿行走"); 
	}
	public static void main(String [] args) {
		new Horse().walk();
	}
}
~~~

直接报错

2、**静态方法可以被重载**

~~~java
class Animal {
	public static void walk() { System.out.println("Animal行走方法"); }
}
public class Horse extends Animal {
	public void walk(String s) { 
		System.out.println("Horse四条腿行走"); 
	}
	public static void main(String [] args) {
		new Horse().walk("");
	}
}
~~~

运行结果：

~~~java
Horse四条腿行走
~~~

3、**静态方法可以被重新定义**

~~~java
class Animal {
	public static void walk() { System.out.println("Animal行走方法"); }
}
public class Horse extends Animal {
	public static void walk() { 
		System.out.println("Horse四条腿行走"); 
	}
	public static void main(String [] args) {
		new Horse().walk();
	}
}
~~~

运行结果：

~~~java
Horse四条腿行走
~~~

## 重写

方法的重写要遵循“两同两小一大”

- **“两同”**即 方法名相同、形参列表相同
- **“两小”**即 子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等。
- **“一大”**： 子类方法的访问权限应比父类方法的访问权限更大或相等

注意：如果方法的返回类型是void或基本数据类型，则返回这重写时**不可修改**。如果方法的返回值是引用类型，重写时可以返回该引用类型的子类。

## 可变长参数

允许在调用方法时传入不定长的参数（0个或者多个参数）

~~~java
public static void method1(String... args) {
   //......
}
~~~

另外，可变长参数只能作为函数的最后一个参数

~~~java
public static void method2(String arg1, String... args) {
   //......
}
~~~

注意：遇到方法重载的情况，优先匹配固定参数的方法

另，Java的可变参数编译后实际会被转换成一个数组，我们看编译后生成的.class文件就可以看出来了。

## 抽象类

- 用abstract关键字来修饰一个类时，这个类叫做抽象类；用abstract来修饰一个方法时，该方法叫做抽象方法。
- 含有抽象方法的类必须被声明为抽象类，抽象类必须被继承，抽象方法必须被重写。。
- 抽象类不能被实例化
- 抽象方法只需声明，而不需实现。

从某种意义上来说，抽象方法就是被用来重写的，所以在父类声明的抽象方法一定要在子类里面重写。如果真的不想在子类里面重写这个方法，那么可以再在子类里面把这个方法再定义为抽象方法，因为子类觉得我去实现也不合适，应该让继承我的子类去实现比较合适，因此也可以在继承这个子类的下一个子类里面重写在父类里面声明的抽象方法，这是可以的。

对于抽象父类来说：既然类中有一个方法没能实现，那么这个类就是残缺不全的，因此这个类应该被定义为一个抽象类。

~~~~java
//父类 --- 动物类
public abstract class Animal {
    private String name;

    Animal() {
    }

    Animal(String name) {
        this.name = name;
    }

    public abstract void enjoy();//只声明不实现
}
~~~~

~~~java
public class Cat extends Animal {
    private String eyesColor;

    Cat() {

    }

    Cat(String name, String eyesColor) {
        super(name);
        this.eyesColor = eyesColor;
    }

    public void enjoy() {
        System.out.println("喵喵~");
    }
}
~~~

## 接口（interface）

- 接口是抽象方法和常量值的定义的集合
- 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现

Java是只支持单继承的，但在现实中存在多重继承这种现象。使用接口可以帮助我们实现多重继承

- 多个无关的类可以实现同一接口
- 一个类可以实现多个无关的接口
- 与继承关系类似，接口与实现类之间存在多态性。

假如一个抽象类里面所有的方法都是抽象的，没有任何一个方法需要这个抽象类去实现，并且这个抽象类里面所有的变量都是public static final的，这时可以把这样的抽象类定义为一个接口。

在接口中，所有的成员变量都是声明成public static final 的，并且默认也是"public static final" 的

接口中声明的抽象方法可以不写abstract关键字来标识，因为接口里所有的方法都是抽象的，因此这个`abstract`关键字默认都是省略掉的。

为了避免C++中，多重继承时，多个父类之间如果有相同的成员变量的时候，引用起来会相当地麻烦，并且运行时会产生各种各样的问题



