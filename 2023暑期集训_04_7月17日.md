#  2023年7月17日

## Map

这是一个集合，跟List,Set不一样，它不是Collection接口下的子接口，它自己单独就是一个接口，它们里面可以存放一对一对的元素，每一对元素称为键值对，通过键可以找到值

常见的实现类：`HashMap`

`put(键,值)` ---- 往Map中添加一个键值对

注意：键不能重复，否则会覆盖map中键值对

~~~java
        Map map = new HashMap();
        map.put("1","One");
        map.put("2","Two");
        map.put("3","Three");
        map.put("1","hello");
        System.out.println(map);//{1=hello, 2=Two, 3=Three}
~~~

`get()` ---- 根据键获取对应的值 ，返回类型为Object

`containsKey(键)` ---- 判断当前集合中是否包含传入的键

`containsValue(值) `---- 判断当前集合中是否包含传入的值

~~~java
        Object o = map.get("1");
        System.out.println(o);
        System.out.println(map.containsKey("1"));//true
        System.out.println(map.containsValue("One"));//false
~~~

Map接口下的实现类除了`HashMap`还有`HashTable`，区别在于：

`HashMap`非线程同步，效率高

`Hashtable`线程同步，效率低

## 自动装箱、拆箱（打包、解包）

在Java中，当我们需要一个基本数据类型包装类对象时，直接传入一个基本数据类型数值即可，它会自动打包，又叫自动装箱。

当我们需要一个剧本数据类型时，直接传入一个包装类即可，会自动解包，又叫自动拆箱

## Collections

这是Collection集合的帮助类，它提供了各种静态方法对我们的集合进行操作，例如：

sort() ---- 对一个List进行大小排序

~~~Java
        List list = new ArrayList();
        list.add(100);
        list.add(32);
        list.add(53);
        list.add(5);
        list.add(13);
        list.add(87);
        list.add(6);
        list.add(99);
        System.out.println(list);//[100, 32, 53, 5, 13, 87, 6, 99]

        Collections.sort(list);
        System.out.println(list);//[5, 6, 13, 32, 53, 87, 99, 100]
~~~

## 泛型

集合对象在定义的时候，可以使用泛型来限定它里面对象的数据类型,使用<>表示其泛型的类型

格式：

~~~java
集合接口<泛型> 变量名 = new 集合类<>();
~~~

~~~java
        List<String> list = new ArrayList<>();
        list.add("hello");
        list.add(100);//编译报错
~~~

~~~java
        Map<String,Integer> map = new HashMap<>();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
~~~

~~~java
        List<Map<String,String>> list = new ArrayList<>();
        for(int i = 0;i < 10;i++){
            Map<String,String> map = new Hashtable<>();
            for(int j = 0;j < 10;j++){
                map.put("key:" + i + j,"value:" + i + j);
            }
            list.add(map);
        }

        System.out.println(list);
~~~

~~~java
        Map<String,String> map1 = new Hashtable<>();
        map1.put("sno","1001");
        map1.put("sname","1001");
        map1.put("sage","1001");
        Map<String,String> map2 = new Hashtable<>();
        map2.put("sno","1002");
        map2.put("sname","1002");
        map2.put("sage","1002");
        List<Map<String,String>> list = new ArrayList<>();
        list.add(map1);
        list.add(map2);
        for(Map<String,String> m : list){
            System.out.println(m);
        }
~~~

## 自定义泛型类

用户在使用该类的时候，指定泛型类型

~~~java
class 类名<泛型标识>{
    泛型标识 变量名;
    ...
}
~~~

~~~java
public class Generic<E> {
    private E name;


    @Override
    public String toString() {
        return "Generic{" +
                "name=" + name +
                '}';
    }

    public Generic() {

    }

    public Generic(E name) {
        this.name = name;
    }

    public E getName() {
        return name;
    }

    public void setName(E name) {
        this.name = name;
    }
}

//测试
    public static void main(String[] args) {
        Generic<String> generic = new Generic<>("hello");
        System.out.println(generic);

        Generic<Integer> generic1 = new Generic<>(122);
        System.out.println(generic1);
    }
~~~

**注意**：当使用的时候不指定泛型，那么相当于使用Object类作为泛型

**注意**：同一个类，不同泛型的对象，它们的类型还是相同的

## Random

随机数类，它的`nextXxx(上限值)`方法，可以获取某种类型，在上限值范围内的一个随机数

~~~java
    public static void main(String[] args) {
        Random random = new Random();
        int i = random.nextInt(100);//[0,100)
        System.out.println(i);
    }
~~~

~~~java
//抽奖器
public class ProductGetter<T> {

    static Random random = new Random();
    private T product;//奖品
    private List<T> list = new ArrayList<>();//奖池

    //往奖池中添加奖品

    public void addProduct(T t) {
        list.add(t);
    }

    //从奖池中抽取一个奖品
    public T getProduct() {
        this.product = this.list.get(random.nextInt(list.size()));

        return this.product;
    }

}
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();

        productGetter.addProduct("爱疯19");
        productGetter.addProduct("高木同学");
        productGetter.addProduct("日高小春");

        System.out.println(productGetter.getProduct());

        ProductGetter<Integer> productGetter1 = new ProductGetter<>();
        int[] arr1 = new int[]{1,2,3,4};
        for(int i = 0;i < arr1.length;i++){
            productGetter1.addProduct(arr1[i]);
        }
        System.out.println(productGetter1.getProduct());

    }
~~~

## 继承中的泛型

如果父类是一个泛型类，子类也是一个泛型类，那么子类在定义的时候，泛型类型必须和父类一致

~~~java
public class ChildGeneric<E> extends Generic<E> {
    
    @Override
    public E getName(){
        return super.getName();
    }
}
~~~

如果子类不是泛型类，那么子类在定义的时候必须指明父类泛型类型

~~~java
public class ChildGeneric2 extends Generic<Integer>{
    @Override
    public Integer getName() {
        return super.getName();
    }
    
    @Override
    public void setName(Integer name){
        super.setName(name);
    }
}
~~~

## 泛型接口

定义格式：

interface 接口名<泛型标识>

1.如果实现类不是泛型类，那么实现类在定义的时候，必须指定接口的泛型类型。

2.如果实现类也是泛型类，那么实现类的泛型类型必须包含接口中的泛型类型

## Maven

这是一个帮助我们下载管理jar包和构建项目的工具

`mvn -v` ---- 查看当前maven工具的版本号

中央仓库 ---- 一台搭建在国外的仓库服务器，里面保存着所有我们将使用的jar

私服仓库 ---- 本公司所能使用到的jar包，从中央仓库下载下来

阿里云的镜像仓库 ---- 这是搭建在国内的Maven镜像仓库，它每15分钟和中央仓库同步一次，保证国内程序员的下载速度

本地仓库 ---- 我们自己个人电脑上的一个文件夹，装着自己曾经下载的所有jar包

### 依赖的坐标

`groupId` ---- 公司名称

`artifactId` ---- 项目名称

`version` ---- 版本号

Maven项目之间有继承关系，父工程下面可以包含子模块，在父工程下面可以包含子模块，在父工程的pom.xml中：
`<packaging>pom</packaging>`表示这是父工程
`<modules>`表示当前父工程下包含的子模块
在子模块的pom.xml中`<parent>`表示其父工程的坐标

**注意**：模块的依赖具有传递性，如果b模块依赖了a模块，那么它也会自动依赖a模块的依赖

**注意**：父工程的pom.xml中可以通过`<dependencyManagement>`来统一管理子模块的依赖版本，子模块的pom.xml中依赖的坐标版本号标签`<version>`可以省略

## `MVC`开发模型

M ---- Model ： 数据库、SQL语句、JDBC、JavaBean

V ---- View ： 用户操作的前端

C ---- Controller ： Servlet连接前端和后端数据库

## 搭建`SpringBoot`项目

1. 创建一个Maven项目
2. 在pom.xml中添加一个spring-boot-starter-parent父工程，再添加spring-boot-starter-web依赖
3. 在Java文件夹中创建一个包，包中创建启动类，该类需要添加`@SpringBootApplication`表示这时springBoot启动类
   同时添加main方法，main方法中添加`SpringApplication.run(当前类名.class, args);`
4. 在启动器类的包中添加controller包，并添加控制器类，然后在控制器类上添加`@RestController`表示这是一个控制器，在控制器中添加一个方法，返回值为String，方法上添加`@RequestMapping("/请求名")`表示接收指定的请求。方法中返回一个字符串用来在浏览器页面显示。
5. 启动main方法，并打开浏览器输入：
   `http://ip地址:端口/请求名`  完成测试

## 修改`SpringBoot`端口

在`resources`文件夹中新建一个`File`，命名为：`application.properties`
该文件中添加`server.port=新端口`
重新启动服务



