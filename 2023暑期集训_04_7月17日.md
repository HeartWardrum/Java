#  2023年7月17日

## Map

这是一个集合，跟List,Set不一样，它不是Collection接口下的子接口，它自己单独就是一个接口，它们里面可以存放一对一对的元素，每一对元素称为键值对，通过键可以找到值

常见的实现类：`HashMap`

`put(键,值)` ---- 往Map中添加一个键值对

注意：键不能重复，否则会覆盖map中键值对

~~~java
        Map map = new HashMap();
        map.put("1","One");
        map.put("2","Two");
        map.put("3","Three");
        map.put("1","hello");
        System.out.println(map);//{1=hello, 2=Two, 3=Three}
~~~

`get()` ---- 根据键获取对应的值 ，返回类型为Object

`containsKey(键)` ---- 判断当前集合中是否包含传入的键

`containsValue(值) `---- 判断当前集合中是否包含传入的值

~~~java
        Object o = map.get("1");
        System.out.println(o);
        System.out.println(map.containsKey("1"));//true
        System.out.println(map.containsValue("One"));//false
~~~

Map接口下的实现类除了`HashMap`还有`HashTable`，区别在于：

`HashMap`非线程同步，效率高，可以使用null作为键

`Hashtable`线程同步，效率低，不能使用null作为键

## 自动装箱、拆箱（打包、解包）

在Java中，当我们需要一个基本数据类型包装类对象时，直接传入一个基本数据类型数值即可，它会自动打包，又叫自动装箱。

当我们需要一个剧本数据类型时，直接传入一个包装类即可，会自动解包，又叫自动拆箱

## Collections

这是Collection集合的帮助类，它提供了各种静态方法对我们的集合进行操作，例如：

sort() ---- 对一个List进行大小排序

~~~Java
        List list = new ArrayList();
        list.add(100);
        list.add(32);
        list.add(53);
        list.add(5);
        list.add(13);
        list.add(87);
        list.add(6);
        list.add(99);
        System.out.println(list);//[100, 32, 53, 5, 13, 87, 6, 99]

        Collections.sort(list);
        System.out.println(list);//[5, 6, 13, 32, 53, 87, 99, 100]
~~~

## 泛型

集合对象在定义的时候，可以使用泛型来限定它里面对象的数据类型,使用<>表示其泛型的类型

格式：

~~~java
集合接口<泛型> 变量名 = new 集合类<>();
~~~

~~~java
        List<String> list = new ArrayList<>();
        list.add("hello");
        list.add(100);//编译报错
~~~

~~~java
        Map<String,Integer> map = new HashMap<>();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
~~~

~~~java
        List<Map<String,String>> list = new ArrayList<>();
        for(int i = 0;i < 10;i++){
            Map<String,String> map = new Hashtable<>();
            for(int j = 0;j < 10;j++){
                map.put("key:" + i + j,"value:" + i + j);
            }
            list.add(map);
        }

        System.out.println(list);
~~~

~~~java
        Map<String,String> map1 = new Hashtable<>();
        map1.put("sno","1001");
        map1.put("sname","1001");
        map1.put("sage","1001");
        Map<String,String> map2 = new Hashtable<>();
        map2.put("sno","1002");
        map2.put("sname","1002");
        map2.put("sage","1002");
        List<Map<String,String>> list = new ArrayList<>();
        list.add(map1);
        list.add(map2);
        for(Map<String,String> m : list){
            System.out.println(m);
        }
~~~

### 自定义泛型类

用户在使用该类的时候，指定泛型类型

~~~java
class 类名<泛型标识>{
    泛型标识 变量名;
    ...
}
~~~

~~~java
public class Generic<E> {
    private E name;


    @Override
    public String toString() {
        return "Generic{" +
                "name=" + name +
                '}';
    }

    public Generic() {

    }

    public Generic(E name) {
        this.name = name;
    }

    public E getName() {
        return name;
    }

    public void setName(E name) {
        this.name = name;
    }
}

//测试
    public static void main(String[] args) {
        Generic<String> generic = new Generic<>("hello");
        System.out.println(generic);

        Generic<Integer> generic1 = new Generic<>(122);
        System.out.println(generic1);
    }
~~~

**注意**：当使用的时候不指定泛型，那么相当于使用Object类作为泛型

**注意**：同一个类，不同泛型的对象，它们的类型还是相同的

### Random

随机数类，它的`nextXxx(上限值)`方法，可以获取某种类型，在上限值范围内的一个随机数

~~~java
    public static void main(String[] args) {
        Random random = new Random();
        int i = random.nextInt(100);//[0,100)
        System.out.println(i);
    }
~~~

~~~java
//抽奖器
public class ProductGetter<T> {

    static Random random = new Random();
    private T product;//奖品
    private List<T> list = new ArrayList<>();//奖池

    //往奖池中添加奖品

    public void addProduct(T t) {
        list.add(t);
    }

    //从奖池中抽取一个奖品
    public T getProduct() {
        this.product = this.list.get(random.nextInt(list.size()));

        return this.product;
    }

}
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();

        productGetter.addProduct("爱疯19");
        productGetter.addProduct("高木同学");
        productGetter.addProduct("日高小春");

        System.out.println(productGetter.getProduct());

        ProductGetter<Integer> productGetter1 = new ProductGetter<>();
        int[] arr1 = new int[]{1,2,3,4};
        for(int i = 0;i < arr1.length;i++){
            productGetter1.addProduct(arr1[i]);
        }
        System.out.println(productGetter1.getProduct());

    }
~~~

### 继承中的泛型

如果父类是一个泛型类，子类也是一个泛型类，那么子类在定义的时候，泛型类型必须和父类一致

~~~java
public class ChildGeneric<E> extends Generic<E> {
    
    @Override
    public E getName(){
        return super.getName();
    }
}
~~~

如果子类不是泛型类，那么子类在定义的时候必须指明父类泛型类型

~~~java
public class ChildGeneric2 extends Generic<Integer>{
    @Override
    public Integer getName() {
        return super.getName();
    }
    
    @Override
    public void setName(Integer name){
        super.setName(name);
    }
}
~~~

### 泛型接口

定义格式：

interface 接口名<泛型标识>

1.如果实现类不是泛型类，那么实现类在定义的时候，必须指定接口的泛型类型。

2.如果实现类也是泛型类，那么实现类的泛型类型必须包含接口中的泛型类型

### 泛型方法

使用<泛型标识> 声明的方法

注意：泛型类中的方法不一定是泛型方法，一定要用<泛型标识>声明的方法才叫泛型方法

调用该方法的时候，由调用者确定泛型类型

~~~java
//在抽奖器类中添加泛型方法
    public <T> T getProduct(ArrayList<T> list){
        return list.get(random.nextInt(list.size()));
    }
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();
        ArrayList<String> list1 = new ArrayList<>();
        list1.add("高木同学");
        list1.add("日高小春");
        list1.add("古手川千纱");
        String res = productGetter.getProduct(list1);
        System.out.println(res);

        ArrayList<Integer> list2 = new ArrayList<>();
        list2.add(122);
        list2.add(4243);
        list2.add(3);
        Integer res2 = productGetter.getProduct(list2);
        System.out.println(res2);

    }

~~~

~~~java
public class ProductGetter<T> {
    public static <T,E,K> void printType1(T t,E e,K k){
        System.out.print(t + " --- " + t.getClass() + ",");
        System.out.print(e + " --- " + e.getClass() + ",");
        System.out.print(k + " --- " + k.getClass());
        System.out.println();
    }
}

    public static void main(String[] args) {
        ProductGetter.printType1("hello",100,false);
        ProductGetter.printType1(false,3.14,'a');
    }
~~~

### 可变参数的泛型方法

在泛型方法的形参中使用`泛型标识 ... 变量名` 可以声明一个方法，别人调用的时候，传入任意个数的参数

该变量接收到的是一个泛型参数的数组

~~~java
    public static <E> void printType2(E... e) {
        for (int i = 0; i < e.length; i++) {
            System.out.print(e[i] + " --- " + e[i].getClass() + ",");
        }
    }

//test
    public static void main(String[] args) {
        ProductGetter.printType2("hello", 100, false);
    }
~~~

### 泛型中的通配符

泛型没有继承性，我们可以使用`？`来定义泛型标识通配符，该泛型的类对象可以接收任何泛型的该类对象的值。

~~~java
        List<String> list = new ArrayList<>();
        List<Object> list1 = new ArrayList<>();
        List<?> list2 = new ArrayList<>();
        list1 = list;//报错
        list2 = list;

        Map<String,String> map = new HashMap<>();
        Map<String,Object> map2 = new HashMap<>();
        map2 = map;//报错
        Map<?,?> map3 = new HashMap<>();
        map3 = map;
~~~



## Maven

这是一个帮助我们下载管理jar包和构建项目的工具

`mvn -v` ---- 查看当前maven工具的版本号

中央仓库 ---- 一台搭建在国外的仓库服务器，里面保存着所有我们将使用的jar

私服仓库 ---- 本公司所能使用到的jar包，从中央仓库下载下来

阿里云的镜像仓库 ---- 这是搭建在国内的Maven镜像仓库，它每15分钟和中央仓库同步一次，保证国内程序员的下载速度

本地仓库 ---- 我们自己个人电脑上的一个文件夹，装着自己曾经下载的所有jar包

### 依赖的坐标

`groupId` ---- 公司名称

`artifactId` ---- 项目名称

`version` ---- 版本号

Maven项目之间有继承关系，父工程下面可以包含子模块，在父工程下面可以包含子模块，在父工程的pom.xml中：
`<packaging>pom</packaging>`表示这是父工程
`<modules>`表示当前父工程下包含的子模块
在子模块的pom.xml中`<parent>`表示其父工程的坐标

**注意**：模块的依赖具有传递性，如果b模块依赖了a模块，那么它也会自动依赖a模块的依赖

**注意**：父工程的pom.xml中可以通过`<dependencyManagement>`来统一管理子模块的依赖版本，子模块的pom.xml中依赖的坐标版本号标签`<version>`可以省略

## `MVC`开发模型

M ---- Model ： 数据库、SQL语句、JDBC、JavaBean

V ---- View ： 用户操作的前端

C ---- Controller ： Servlet连接前端和后端数据库

## 搭建`SpringBoot`项目

1. 创建一个Maven项目
2. 在pom.xml中添加一个spring-boot-starter-parent父工程，再添加spring-boot-starter-web依赖
3. 在Java文件夹中创建一个包，包中创建启动类，该类需要添加`@SpringBootApplication`表示这时springBoot启动类
   同时添加main方法，main方法中添加`SpringApplication.run(当前类名.class, args);`
4. 在启动器类的包中添加controller包，并添加控制器类，然后在控制器类上添加`@RestController`表示这是一个控制器，在控制器中添加一个方法，返回值为String，方法上添加`@RequestMapping("/请求名")`表示接收指定的请求。方法中返回一个字符串用来在浏览器页面显示。
5. 启动main方法，并打开浏览器输入：
   `http://ip地址:端口/请求名`  完成测试

## 修改`SpringBoot`端口

在`resources`文件夹中新建一个`File`，命名为：`application.properties`
该文件中添加`server.port=新端口`
重新启动服务

# 2023年7月18日

## 面试题

ArrayList底层扩容原理：

它的底层是一个数组，长度默认为10，当调用add方法存入元素时，判断数组是否满了，如果满了，就造一个新的数组，长度是原数组的1.5倍，然后将原数组中的元素依次拷贝到新数组中，使用新数组。

~~~java
public interface List {

    void add(Object o);

    void add(int index, Object o);

    Object get(int index);

    int size();

    boolean isEmpty();

}
~~~

~~~java
public class ArrayList implements List {

    Object[] elementData;//集合底层的那个数组

    private int size;//当前集合对象中的元素个数

    public ArrayList(int count) {
        this.size = 0;
        elementData = new Object[count];
    }

    public ArrayList() {
        this.size = 0;
        elementData = new Object[4];
    }

    @Override
    public void add(Object o) {
        add(size, o);
    }

    @Override
    public void add(int index, Object o) {
        if (index < 0 || index > size) {
            throw new MyIndexOutOfBoundException("对不起数组越界");
        }
        //数组满了，需要扩容
        if (this.size == elementData.length) {
            grow();
        }
        //从指定的第index个位置开始，一次往后挪一格
        for (int i = size; i > index; i--) {
            elementData[i] = elementData[i - 1];
        }
        elementData[index] = o;
        size++;
    }

    @Override
    public Object get(int index) {
        if (index < 0 || index >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        return elementData[index];
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    private void grow() {
        //     //数组满了，需要扩容
        //     //1.造一个新数组newArray,长度是原数组的1.5倍
        //     Object[] newArray = new Object[elementData.length
        //             + (elementData.length >> 1)];//+-比移位优先级高
        //     //2.将就数组中的元素拷贝到新数组中
        //     for (int i = 0; i < elementData.length; i++) {
        //         newArray[i] = elementData[i];
        //     }
        //     //3.将就数组的引用指向新数组
        //     elementData = newArray;
        //以上代码可以通过下面一行来替代，使用Arrays帮助类中的copyOf方法
        elementData = Arrays.copyOf(elementData,
                elementData.length +
                        (elementData.length >> 1));
    }

    @Override
    public String toString() {
        String s1 = "[";

        String s2 = "]";
        if (0 == size) {
            return "[]";
        }
        StringBuffer stringBuffer = new StringBuffer("[");
        for (int i = 0; i < size - 1; i++) {
            stringBuffer.append(elementData[i] + ",");
        }

        stringBuffer.append(elementData[size - 1] + "]");
        return stringBuffer.toString();
    }
}
~~~

~~~java
public class Test8 {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(100);
        //list.add(200);
       // list.add(300);
       // list.add(3,500);
        System.out.println(list.get(0));
     //  System.out.println(list.get(1));
     //  System.out.println(list.get(2));
     //  System.out.println(list.get(3));
        System.out.println(list);
    }
}

~~~

## `SpringBoot`项目的一键部署

1. 打开`spring.io`网站，在顶端右边找到`Projects -> Spring Boot`在新页面，找到`LEARN -> 随便哪个版本的Reference.Doc -> 新页面左边蓝色字体找到Using SpringBoot -> 快捷键ctrl + F 搜索spring-boot-maven-plugin将该插件添加到pom.xml中`
2. 在Maven小窗口中的`lifeCycle`下拉菜单中双击`package`完成打包，控制台会告诉你包在什么路径
3. 使用`java -jar`命令直接启动该jar包即可，停止按`ctrl + c`

## `MySQL`数据库语法

### 分页查询

~~~sql
select 字段列表 from 表名 limit 起始条数, 每页条数;
-- for example
select * from fiction limit 6,3;
~~~

### 主键值自增长

建表语句中使用auto_increment实现，格式：

~~~plsql
create table 表名(
	字段名1 字段类型 auto_crement,
	字段名2 字段类型,
    ...
    PRIMARY KEY(主键字段)
)DEFAULT CHARSET = utf8;

-- for example
create table myuser0718(
	userid INTEGER auto_increment,
	username VARCHAR(20),
	userage INTEGER,
	PRIMARY KEY(userid)
)DEFAULT CHARSET=utf8;

~~~

### now()

当前系统时间

~~~~~plsql
select now(); -- 2023-07-18 16:55:35
~~~~~

### DATE_FORMAT(日期字段,日期格式) 

将日期型转字符串

~~~plsql
select f.fictionid,f.fictionname,DATE_FORMAT(f.createtime,'%y-%m-%d %H:%i:%s') from fiction f;
~~~

