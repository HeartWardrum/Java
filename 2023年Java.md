瀑布模型：

- 需求规格说明书
- 概要设计（包括数据库设计）
- 详细设计（伪代码之类的）
- 编码
- 测试

----------------------

小厂一般使用敏捷开发



2023年7月3日

# 数据库

设计基本步骤：

>1. 找名词
>2. 把名词分两类（实体，属性）
>3. 一个实体一张表
>     一个属性一个字段
>4. 确定表和表之间的关系:
>   - 1对1：主表中添加从表的编号作为关联字段
>   - 1对多：在多的一端中添加1的一端的编号作为关联字段
>   - 多对多：再添加一张关系表用来记录两边的编号

### **ER图**：

### 辅助我们进行数据库表结构设计的工具

在ER图中

> 矩形：实体
> 椭圆：属性
> 菱形：关系

![ER图](https://res.cloudinary.com/dvqgs9esp/image/upload/v1688353564/ER图_q01tnx.png)

### 范式：

### ————判断数据库中某张表设计的好坏的规范

> 1. 第一范式：列不可分（每一个字段都是不可再分的最小原子单位）
> 2. 第二范式：要有主键，不存在部分依赖
>    （主键：某个字段非空唯一）
>    （联合主键：多个字段的组合作为主键）
>    （所有非主键字段必须完全依赖联合主键）
> 3. 第三范式：不存在传递依赖
>    （所有非主键字段必须直接依赖主键）

## Oracle

sql	---- 标准的查询语言
DDL ---- 数据定义语言：针对数据库对象操作的
DML ---- 数据操纵语言：针对数据操作的

~~~sql
-- 查询服务器时间
select sysdate from dual;
~~~

关于dual：

1. dual不是缩写词，本身就是完整的单词
2. Oracle中的dual表是一个单行单列的虚拟表
3. Dual表是oracle与数据字典一起创建的一个表，这个表只有1列：DUMMY，数据类型为VERCHAR2(1)，dual表中只有一个数据：‘X’，Oracle有内部逻辑保证dual表中永远只有一条数据。
4. Dual表主要用来选择系统变量或求值，一个简单的例子：
   SELECT sysdate FROM daul
   而Oracle的SELECT语法限制为：
   SELECT * FROM table
   所以，没有表名就没有办法查询，而时间日期并不存放在任何表中，于是这个dual虚拟表的概念就被引入了。
5. dual表的用途：
   dual是Oracle中的一个实际存在的表，任何用户均可读取，常用在没有目标表的SELECT语句块中

### 创建一张表：

~~~sql
CREATE TABLE 表名(
字段1 类型，
字段2 类型，
    ...
)
~~~

例如：
~~~sql
CREATE TABLE comifo20230703(
pno VARCHAR2(32),
pname VARCHAR2(32),
gender VARCHAR2(6),
birthday DATE,
phone NUMBER(32)
);
~~~

#### char、varchar和varchar2的区别

##### char

char数据类型用于存储字符值。它是一个固定长度的数据类型，也就是说，一旦初始化，我们就不能在执行时改变其大小。因此，它也被称为静态数据类型。 主要用来存储身份证手机号等长度不变的数据。

char数据类型可以存储一个最大长度为2000字节的字符串。

char(5) 中如果只存储abc，那么剩下的两位会被空格填充

##### varchar

可变长度的类型，遵循ANSI标准

如果在varchar2(10)中存储5个字符，那么Oracle将只存储5个字符，类似于VARCHAR，而不是像CHAR那样存储10个字符。 （一个字符在Unicode编码下占三个字节）

##### varchar2

varchar2是Oracle特有的，遵循Oracle标准

在Oracle中varchar2和varchar没有区别

### 事务

数据库中保证数据准确，完整的一种机制，事务的四大特性：ACID ： 原子性，一致性、隔离性、持久性。

当我们增删改数据后，需要提交事务，事务不仅可以被提交，还可以被回滚。

### 修改一张表

1. 添加字段：

~~~sql
ALTER TABLE 表名 ADD(
字段名 类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 ADD(
qq number(32)
);
~~~

2. 修改字段名

~~~sql
ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME COLUMN qq TO wechat;
~~~

3. 修改字段类型

~~~sql
ALTER TABLE 表名 MODIFY(
字段名 新类型
);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 MODIFY(
wechat varchar2(32)
);
~~~

4. 删除字段

~~~sql
ALTER TABLE 表名 DROP(字段名);
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 DROP(wechat);
~~~

5.修改表名

~~~sql
ALTER TABLE 旧表名 RENAME TO 新表名;
~~~

例如：

~~~sql
ALTER TABLE comifo20230703 RENAME to comifo0703;
~~~

### 删除一张表

~~~sql
DROP TABLE 表名;
~~~

例如：

~~~sql
DROP TABLE comifo0703;
~~~

### 插入一条记录

~~~sql
INSERT INTO 表名(字段1,字段2,...)
VALUES('值1','值2',...);
~~~

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname, phone)
VALUES
  ('1001', '张三', '18112923121');
~~~

语句执行完成后要手动提交事务

注意：当对表中所有字段插入数据时，values前面的小括号可以省略



### 字符串转日期函数

to_date(日期字符串，日期格式)

注意：在格式中，y表示年，m表示月，d表示日，hh表示12小时制，hh24表示24小时制，mi表示分钟，ss表示秒。

例如：

~~~sql
INSERT INTO comifo703
  (pno, pname,gender,birthday, phone) 
VALUES
  ('1002', '李四','男',to_date('2001-06-15','yyyy-mm-dd'),'13944572390');
~~~

~~~sql
INSERT INTO comifo703
  (pno, pname, gender, birthday, phone)
VALUES
  ('1004',
   '荀一',
   '男',
   TO_DATE('2000-07-31 13：23：32', 'yyyy-mm-dd hh24:mi:ss'),
   '1391221390');
~~~



### 修改字段

~~~sql
UPDATE 表名 SET 字段名 = 字段值 WHERE　条件语句; 
~~~

例如：

~~~sql
UPDATE comifo703 SET phone = '5542278383' WHERE pno = '1002';
~~~

### 删除语句

~~~sql
DELETE FROM 表名 WHERE 条件语句;
~~~

例如：

~~~sql
DELETE FROM comifo703 WHERE pno = '1001';
~~~

### 查询语句

~~~sql
SELECT 字段1,字段2,... FROM 表名 WHERE 条件;
~~~

例如：

~~~sql
 SELECT pno,pname,phone FROM comifo703 WHERE pno = '1002';
~~~

### 日期型转字符串型

to_char()

例如：

~~~sql
SELECT pno, pname, to_char(birthday, 'yyyy-mm-dd'), phone
  FROM comifo703
 WHERE pno = '1002';
~~~

### 约束

1.非空 ---- NOT NULL

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL	-- 非空
);
~~~

2.唯一 ---- UNIQUE

~~~plsql
create table ta(id not null unique, --非空唯一 
                bookname varchar2(20));
~~~

~~~sql
CONSTRAINT 约束名 UNIQUE(字段)
~~~

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) NOT NULL,
CONSTRAINT uk703 UNIQUE(phone) -- 唯一
);
~~~

注意：小括号中如果有多个字段，则表示他们的组合不能重复。此外，如果要为组合添加约束，则必须使用constraint语句，而不能将unique挂在字段类型的后面

例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

3.主键约束 ---- PRIMARY KEY

自带非空唯一的功能

例如：

~~~sql
DROP TABLE comifo703;

CREATE TABLE comifo703(
pno varchar2(32) PRIMARY KEY, -- 主键约束
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname)
);
~~~

主键约束也可以使用constraint编写
constraint 约束名 primary key(字段)

注意：小括号内如果有多个字段，则表示他们是联合主键。
例如：

~~~sql
CREATE TABLE comifo703(
pno varchar2(32),
pname varchar2(32),
gender varchar2(6),
birthday date,
phone number(32) not null,
constraint uk703 unique(phone,pname),
constraint pk703 primary key(pno,pname) -- 联合主键
);
~~~

# 2023年7月4日

### 外键

将某张表中的主键字段添加到另一张表中作为关联字段，那么该字段称为外键

外键约束两层含义：

1. 当添加子表数据时，外键值必须是主表主键中已存在的值。
2. 当删除父表数据时，主键值必须没有被子表关联使用。

例如：

~~~sql
create table class0704(
cno varchar2(32) primary key,
cname varchar2(32),
ccount number (10)
);

select * from class0704;

insert into class0704 
values
(1001,'A班',32);

create table student0704(
sno varchar2(32) primary key,
sname varchar2(32),
sage number(10),
cno varchar2(32) references class0704(cno) -- 外键
);

select * from student0704;

insert into student0704 
values 
(201801,'李四',12,1001); -- 插入的班级必须是已存在的
~~~

### 别名

我们在sql语句中可以给表或者字段起别名，方便我们带出字段名和展示结果集的表头

例如：

~~~sql
select t.tno 编号,t.tname 姓名, t.tsex 性别, t.tage 年龄 from teacher t;
-- 或
select t.tno as 编号,t.tname as 姓名, t.tsex as 性别, t.tage 年龄 from teacher as t;
-- 建议加as(2023.8.9修正：最好还是不加，有地方会出错)
select e2.* from (
select e.* ,rownum from emp e) as e2; -- 直接报错，不能使用as，似乎只有这种情况不能用as
~~~

**注意** ：当select语句作为from的子句时，不能使用as

### 排重

在select子句部分的字段名前面添加distinct 

~~~sql
create table ta(id integer ,charname varchar2(20));

insert into ta values(1,'a');
insert into ta values(1,'a');
insert into ta values(2,'a');

select distinct id,charname from ta;
-- 打印结果 将两个字段组合相同的也排重了
1 a
2 a 
~~~

distinct会对所有要查询的字段进行排重

distinct只能放在第一个字段前面

~~~sql
select id , distinct charname from ta; -- 报错
~~~

### 排序

在查询语句最后添加order by子句，用来排序，格式：

~~~sql
order by 字段名 asc/desc
-- desc表示降序，asc表示升序，asc可以省略
~~~

例如：

~~~sql
select distinct t.tno, t.tname from teacher t order by t.tno desc;
~~~

```sql
select distinct t.tno, t.tname, t.tsex
  from teacher t
 order by t.tsex, t.tname, t.tno desc;
```

注意：汉字的大小顺序是unicode编码中的先后顺序

按照薪水高低查询所有男教师信息：

```sql
select * from teacher t where t.tsex = '男' order by t.sal desc;
```

### 常用的比较运算符

```sql
> 大于
>= 
<
<=
!=   -- 只在Oracle数据库中有效
<>
=
between 上限a and 下限b  -- 在[a,b]范围内
is null
is not null
```

### 多条件查询

and ---- 并且
or ---- 或者

**注意**：and优先级比or高

```sql
select *
  from teacher t
 where t.tage > 45
   and t.tsex = '男';

select *
  from teacher t
 where t.birplace = '江苏'
    or t.birplace = '浙江';
    
    -- 注意多种逻辑运算符共存的时候，建议使用小括号把先算的部分括起来。
    -- 查询所有女教师和薪水大于9000的男教师
 select *
  from teacher t
 where t.tsex = '女'
    or (t.tsex = '男' and t.sal > 9000);
```

### in 和 not in

in  在指定的范围内筛选

not in  在指定范围以外筛选

格式：`in (值1,值2)`

例如：

```sql
select * from teacher t where t.birplace not in ('北京', '上海', '江苏');
```

### like

模糊查询

格式：

```sql
-- 全匹配 '%关键字%'
select * from teacher t where t.birplace like '%江%';
-- 左匹配 '关键字%'
-- 右匹配 '%关键字'
```

### 聚合分析函数

avg(字段) ---- 求平均值

sum(字段) ---- 求和

max(字段) ---- 求最大值

min(字段) ---- 求最小值

count(字段) ---- 计数

### 数值截取函数

round(数值，小数位) ---- 以四舍五入的方式截取数值

trunc(数值，小数位) ---- 以直接丢弃的方式截取数值

```sql
select round(avg(t.sal),2) 平均工资 from teacher t;
select trunc(avg(t.sal),2) 平均工资 from teacher t;
```

### 分组语句

group by

例如：

```sql
select trunc(avg(t.sal),2) ,t.tsex from teacher t
group by t.tsex;
```

注意：select后面只能添加group by的非函数字段，否则报错。

### having

如果需要在函数的结果上进行判断，不能使用where，只能使用having，having子句需要写在group by子句的后面。

例如：

```sql
select count(*), s.sex from student s group by s.sex having count(*) > 3;
```

```sql
-- 统计哪些籍贯不止一个老师
select count(*), t.birplace
  from teacher t
 group by t.birplace
having count(*) > 1;
```

### 子查询

一个查询语句的结果是另一个查询语句的条件，这样的select语句称为子查询语句

例如：

```sql
-- 查询和李树标同一系别的教师信息
select *
  from teacher t1
 where t1.dno = (select t.dno from teacher t where t.tname = '李树标')
   and t1.tname <> '李树标';
```

```sql
-- 统计学生表中系别和赵静想同，但是年龄比赵静大的同学的信息
select *
  from student s1
 where s1.dno = (select s.dno from student s where s.sname = '赵静')
   and s1.birthday <
       (select s2.birthday from student s2 where s2.sname = '赵静');
```

注意：如果子查询返回的结果集条数大于一条，那么外层查询只能使用in进行关联。

```sql
select *
  from student s1
 where s1.classid in
       (select s.classid
          from student s
         where s.birthday between to_date('1983-01-01', 'yyyy-mm-dd') and
               to_date('1984-12-31', 'yyyy-mm-dd'));
```



### for update

在select语句后面添加for update；可以实现图形化界面的增删改操作。

```sql
select * from student s for update; -- for update是Oracle特有的语法
```

### 多表关联

`select 字段 from 表1,表2,... where 关联条件`
注意：如果关联条件不够，则会出现笛卡尔乘积的问题
正确写法如下：

```sql
-- 统计每个教师的编号、姓名、系别名称
select t.tno, t.tname, d.dname
  from teacher t, department d
 where t.dno = d.dno;
```

注意：子查询也能实现多表关联

```sql
select t.tno, t.tname
  from teacher t
 where t.dno = (select d.dno from department d where d.dname = '计算机系')
```

### left join

左外关联
左边的表中所有记录全部展示，右边的表中的记录有则展示，无则留空。

格式：
`select 字段 from 左表 left join 右表 on 关联条件`

例如：

```sql
select * from teacher t left join department d on t.dno = d.dno;
```

注意：Oracle中的关联查询可以实现(+)的另一边全部展示

例如：

```sql
-- 和以上代码功能一样，
select * from teacher t ,department d where t.dno = d.dno(+);
```

### inner join

等于用等号进行两表关联，inner可以省略

例如：

```sql
select * from teacher t inner join department d on t.dno = d.dno;
```

### union

在两个select语句中实现并集，要求两个select语句字段类型和个数相同，union自带排重功能，union all 不会排重

例如：

```sql
-- 找出所有男老师和男学生的名字
select s.sname from student s where s.sex = '男'
union all
select t.tname from teacher t where t.tsex = '男';
```

```sql
-- 统计所有男学生选的课程名
-- 以及所有男老师教授的课程名
-- 以及所有课时>40的课程名
select c.cname from course c,student s,s_course sc
where c.cno = sc.cno and sc.sno = s.sno and s.sex = '男'
union 
select c1.cname from course c1, t_course tc,teacher t
where c1.cno = tc.cno and tc.tno = t.tno and t.tsex = '男'
union 
select c2.cname from course c2 where c2.ctime > 40;
```

### intersect

交集

```sql
-- 统计韩信和赵汗青选修了哪些相同的课程，展示课程名
select c.cname
  from course c, s_course sc, student s
 where c.cno = sc.cno
   and sc.sno = s.sno
   and s.sname = '韩信'
intersect
select c1.cname
  from course c1, s_course sc1, student s1
 where c1.cno = sc1.cno
   and sc1.sno = s1.sno
   and s1.sname = '赵汗青';
```

### minus

差集

由生日计算年龄

```sql
select s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age -- 由生日计算年龄
  from student s
 where s.sno in (select sc.sno from s_course sc where sc.mark < 60);

```

```sql
-- 查询不存在挂科人的信息
select distinct s.sno,
       s.sname,
       s.sex,
       s.dno,
       s.classid,
       to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s,s_course sc
 where s.sno = sc.sno and  s.sno not in (
 select sc.sno from s_course sc where sc.mark < 60 
 );
 
 -- 另一种思路，把最低分大于等于六十的查出来
 select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in ( select sc.sno
                   from s_course sc
                  group by sc.sno
                 having min(sc.mark) >= 60);
```

```sql
-- 查询至少有2门成绩在65以上的同学的信息
select distinct s.sno,
                s.sname,
                s.sex,
                s.dno,
                s.classid,
                to_char(sysdate, 'yyyy') - to_char(s.birthday, 'yyyy') age
  from student s
 where s.sno in (
select sc.sno from s_course sc 
where sc.mark >=65 
group by sc.sno
having count(sc.sno)>=2);
```

练习：

```sql
 -- 对于emp中有管理者的员工，列出姓名，管理者姓名（MGR表示管理者）
 -- 实现了自己关联自己
 select e1.ename as 姓名,e2.ename as 管理者姓名
 from emp e1,emp e2
 where e1.mgr is not null and e1.mgr = e2.empno;
```

```sql
-- 查询同时选修java基础和高等数学两门课，的同学，
-- 并且他的java基础的分数要比高等数学的分数要高，
-- 展示这样的学生信息
select * from student s where s.sno in(
	select sc1.sno from s_course sc1 ,s_course sc2 
	where sc1.sno = sc2.sno    -- 同一个人
	and sc1.cno = (            -- 这个人选修了java基础
					select c.cno from course c where c.cname = 'java基础')
	and sc2.cno = (            -- 这个人选修了高等数学
					select c1.cno from course c1 where c1.cname = '高等数学')
	and sc1.mark > sc2.mark    -- java基础分数比高等数学高
);

-- 用临时表改写
-- 造两张临时表
-- 一张表：展示所有选修java基础的同学的信息，以及java基础的分数
-- 另一张：展示所有选修高等数学的同学的信息，以及高等数学的分数
 with t1 as(select s.sno,s.sname ,s.sex,sc.mark  -- 这里不能将写成select * 的原因：如果使用select * 则t1表内有两列字段名都叫sno，在进行总查询的时候，t1.sno就无法确定是哪一列sno，产生未明确定义列错误
            from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = 'java基础'
 ),
 t2 as (select s.sno,s.sname ,s.sex,sc.mark 
        from student s,s_course sc,course c 
 where s.sno = sc.sno and sc.cno = c.cno and c.cname = '高等数学'
 )
 select t1.sno,t1.sex,t1.sname from t1,t2 where t1.sno = t2.sno and t1.mark > t2.mark;
```

# 2023年7月5日

### 临时表

它可以辅助我们编写select语句
把临时需要的一些数据先统计出来，形成临时表，执行完查询语句后，该临时表不会保存在数据库中。
格式：

```sql
with 表名1 as(select语句),
表名2 as(select语句)
总的查询语句
```

```sql
-- 查询所有偏科的同学
-- 偏科：
-- 个人总均分大于所有人所有课的总均分
-- 存在挂科
with t1 as
 (select sc.sno, avg(sc.mark) as peravg from s_course sc group by sc.sno)
select s.*
  from student s, s_course sc, t1
 where s.sno = sc.sno
   and s.sno = t1.sno
   and t1.peravg > (select avg(sc1.mark) from s_course sc1)
   and sc.mark < 60;

```

### substr

`substr(字符串,从第几位开始,截取几位)` ---- 从左往右截取字符串

例如：

```sql
select substr('this is a String',6,2) from dual; -- 结果为is
```

length(字符串) ---- 查询这个字符串的长度

从右往左截取方式：
`substr(字符串,-截取位数)` 
`substr(字符串,length(字符串)-截取位数+1,截取位数)`

### case语句

用来做分支判断，然后造一个字段

格式1：

```sql
case when 条件1 then 结果1
	when 条件2 then 结果2
	...
	else 结果n
	end as 别名
```

例如：

```sql
select sc.sno,
       sc.cno,
       sc.mark,
       case
         when sc.mark < 60 then
          '差'
         when sc.mark < 80 then
          '中'
         when sc.mark < 90 then
          '良'
         when sc.mark <= 100 then
          '优'
         else
          '其他'
       end as 等级
  from s_course sc;
```

格式2：

~~~plsql
case 字段名 when 值1 then 值2
			when 值1 then 值2
			...
			else 结果n
			end as 别名
~~~

例如：

~~~plsql
select s.sno,
       s.sname,
       case s.sex
         when '男' then
          'boy'
         when '女' then
          'girl'
         else
          'others'
       end as 性别
  from student s;
~~~

注意：格式2可以使用decode函数取代

`decode(字段,值1,结果1,值2,结果2,...)`

例如：

~~~plsql
select s.sno,
       s.sname,
       decode(s.sex, '男', 'boy', '女', 'girl', 'others') as 性别
  from student s;
~~~

#### 列转行

~~~plsql
  select t.student, 
  sum(case when t.course = '语文' then t.score else null end) as 语文,
  sum(case when t.course = '数学' then t.score else null end) as 数学,
  sum(case when t.course = '英语' then t.score else null end) as 英语,
  sum(case when t.course = '物理' then t.score else null end) as 物理
  from test t
  group by t.student;
~~~

~~~plsql
select student ,
sum(decode(course ,'语文',score)) as 语文,
sum(decode(course ,'数学',score)) as 数学,
sum(decode(course ,'英语',score)) as 英语,
sum(decode(course ,'物理',score)) as 物理
from test group by student;
~~~

最难的sql题（列转行）工作已完全够用，不用钻研更深

~~~plsql
/*2、按部门汇总emp表中五个职位的各自的薪资汇总以及部门汇总，例：

    DEPTNO  ANALYST CLERK MANAGER PRESIDENT SALESMAN  总和
    10      0       1300  2450    5000      0         8750
    20      6000    1900  2975    0         0         10875
    30      0       5950  2850    0         5600      14400
    总和    6000    9150  8275    5000      5600      34025*/
    with t1 as ( 
select 
      to_char(e.deptno)                    AS deptno  ,
      sum(case e.job when 'ANALYST' then sal else 0 end)   AS ANALYST,
      sum(case e.job when 'CLERK' then sal else 0 end)     AS  CLERK,
      sum(case e.job when 'MANAGER' then sal else 0 end)   AS MANAGER,
      sum(case e.job when 'PRESIDENT' then sal else 0 end) AS  PRESIDENT,
      sum(case e.job when 'SALESMAN' then sal else 0 end)  AS SALESMAN ,
      sum(e.sal) AS  总和
from  emp e 
group by e.deptno 
order by e.deptno
),
t2 AS (
select '总和', 
       sum(ANALYST), 
       sum(CLERK), 
       sum(MANAGER), 
       sum(PRESIDENT), 
       sum(SALESMAN) ,
       sum(总和) from t1 )
select * from t1 
union all 
select * from t2 ;
~~~

# 2023年7月6日

## 视图

存储下来的select 语句

创建视图：

~~~plsql
create or replace view 视图名 as 
select 语句;
~~~

查询视图：

~~~plsql
select 字段 from 视图名 ;
~~~

视图的好处：

1. 简化查询
2. 它可以和背后的基表同步(这一点体现了它和备份表的区别)
3. 它可以控制访问权限

视图在创建的时候，可以使用 as 字段别名 来重新定义视图中的字段名

视图的修改和新增是同一条语句：无则新增，有则替换

视图中的字段如果不是表中的原始字段（这样的视图称作复杂视图），则无法对该视图进行增删改操作
如果视图字段全是表中的字段（简单视图），它允许进行增删改操作，实际操作的是它背后的基表

一般不建议对视图进行增删改
在创建视图的语句最后添加 `with read only`可以屏蔽增删改操作
例如：

~~~plsql
create or replace view  emp070601 as 
select * from emp where deptno = 30
with read only;
~~~

所有的数据库的对象的删除都是drop语句

删除视图名：`drop view 视图名`

例如：

~~~plsql
drop view emp070601;
~~~

我们可以像创建视图那样去创建一张表，记录下查询语句中的结果集

格式：

~~~plsql
-- 创建备份表
create table 表名 as
select语句
~~~

## rownum 

行号

用来统计指定条数的记录

例如：

~~~plsql
select e.* ,rownum from emp e where rownum <= 10; -- 显示前十条记录
~~~

注意：rownum的条件过滤是针对原始数据，如果需要排序，那么得先用子查询来排序，在排序的结果集上加rownum

格式：

~~~plsql
select 字段 from (
	select 字段 from 表 where 条件 order by 排序字段 asc/desc
)
where rownum <= 数值
~~~

例如：

~~~plsql
 select * from ( select * from emp order by sal desc) where rownum <= 10; -- 工资最高的前十人
~~~

rownum的条件判断只支持`<`和`<=`，我们可以在当前结果集查询的时候给它起别名，相当于造了一个普通字段，这个普通字段支持各种比较运算符，然后再外层对别名进行条件判断。

例如：

~~~plsql
select *
  from (select a.*, rownum rn from (select * from emp order by sal desc) a 
        )  b
 where b.rn > 5
   and b.rn <= 10;
~~~

注意：在oracle中给表名起别名不能加as

## 分页查询

1. 每页条数是程序中写死的

2. 页数是前端传过来的

3. 分页公式（Oracle）： ---- 固定格式（重要！）
   ~~~plsql
   select * from (
   	select a.*,rownum rn from (
       	select * from 表名 order by 排序字段 desc) a ) b
       	where b.rn > 每页条数 * (页数 - 1) and b.rn <= 每页条数 * 页数;
   ~~~

## 序列

这是一种用来产生唯一数值的数据库对象

创建序列：

~~~plsql
create sequence 序列名
start with 起始值 -- 最小为1
increment by 递增值
maxvalue 最大值;
~~~

使用序列：

~~~plsql
序列名.nextval
~~~

查询当前值：

~~~plsql
序列名.currval
~~~

修改序列：

~~~plsql
alter sequence 序列名
increment by 递增值
maxvalue 最大值 ;
-- 注意：起始值不能修改
~~~

删除序列：

~~~plsql
drop sequence 序列名
~~~

例如：

~~~plsql
   -- 创建序列
   create sequence myseq0706
   start with 100
   increment by 1
   maxvalue 9999999999999999999999999999;
   -- 使用序列
   select myseq0706.nextval from dual;
   -- 查看序列进行到哪了  新序列创建后必须使用了一次才能查看，否则会出现序列尚未在此会话中定义的错误
   select myseq0706.currval from dual;
~~~

关于序列的几个易错点：

1. 新序列直接currval会报错，必须先nextval以下

2. 新序列，直接`select myseq.nextval from dual`返回的是起始值
   ~~~sql
      create sequence myseq
      start with 1
      increment by 1
      maxvalue 9999;
      select myseq.nextval from dual; -- 打印1
   ~~~

3. 新序列，直接`insert into test1(myseq.nextval , '张三');`传入的是起始值加一
   ~~~sql
      drop sequence myseq;
      create sequence myseq
      start with 1
      increment by 1
      maxvalue 9999;
      insert into test1(myseq.nextval,'张三'); -- 传入的是2
   ~~~

## 索引

这是一种用来提高查询速度的数据库对象，它是添加在数据库表的某个字段上的，当以该字段作为查询条件，会提高查询速度

创建索引：

1. 自动创建 ---- 当表中字段是主键或者唯一约束时，该字段自带索引。
   ~~~~~plsql
   create table mytable0706(
   sno varchar2(32) primary key, -- 自带索引
   sname varchar2(32) ,
   sphone number unique 	-- 自带索引
   );
   ~~~~~

   

2. 手动添加 ---- create index 索引名 on 表名(字段名)
   ~~~~~plsql
   create index my_index0706 on mytable0706(sname);
   ~~~~~

索引的缺点：它会降低增删改的速度，因为在维护数据的同时，还需要花费额外的时间来维护数据上的索引，同时它还会占用资源空间

#### 面试题：

以下情况不加索引：

1. 表中数据量不大的时候：少于几百万条
2. 该字段不经常被当作where条件
3. 该表中的数据经常被增删改
4. 该字段上的取值范围比较窄

删除索引：

`drop index 索引名`

## 同义词

保存下来的表或视图的别名

创建语法：

~~~plsql
create synonym 同义词名 for 表名或视图名
~~~

例如：

~~~plsql
create synonym s for student;

select * from s; -- 相当于 select * from student
~~~

删除：

~~~plsql
drop synonym  同义词名;
~~~

## PL/SQL语言

这是一门数据库开发语言，用来帮助我们对数据库进行各种复杂的操作

### PL/SQL语法结构：

~~~plsql
declare
声明部分
begin
程序体
exception
异常处理部分
end;
~~~

### 打印语句

~~~plsql
dbms_output.put_line(打印内容);
~~~

例如：

~~~plsql
begin 
  dbms_output.put_line('hello world');
end;
~~~

### 赋值语句

1、查询赋值：

~~~plsql
select 字段名 into 变量名 from 表 where 条件...
~~~

例如：

~~~plsql
declare 
  v_sal number(10,2);
begin
  select e.sal into v_sal from emp e where e.empno = '7369';
  dbms_output.put_line(v_sal);
end;
~~~

~~~plsql
declare
  v_sal number(10,2);
  v_eno number(4);
  v_ename varchar2(10);
  begin
    select e.empno,e.ename,e.sal
    into v_eno,v_ename,v_sal
    from emp e where e.empno = '7369';
    dbms_output.put_line(v_eno||','||v_ename||','||v_sal);
end;
-- 输出结果：7369,SMITH,800
~~~

### 表名.字段名%type

定义变量的时候，类型可以使用`表名.字段名%type`表示当前变量类型和该字段的类型保持一致
**注意**：此处的表名不能使用别名

例如：

~~~plsql
declare
  v_sal number(10,2);
  v_eno number(4);
  v_ename emp.ename%type; -- 和表中字段类型保持一致
  begin
    select e.empno,e.ename,e.sal
    into v_eno,v_ename,v_sal
    from emp e where e.empno = '7369';
    dbms_output.put_line(v_eno||','||v_ename||','||v_sal);
end;
-- 结果和上面一致
~~~

### 记录

### 记录类型

将一组逻辑相关的变量整合到一块，做成一个类型，再由该类型定义一个变量，那么该变量就可以接收一组值，使用的时候，使用`变量名.属性`即可
定义格式：

~~~plsql
type 记录类型名 is record(
属性1 类型1,
属性2 类型2,
    ...
)
~~~

例如：

~~~plsql
declare 

type my_record is record(
v_eno emp.empno%type,
v_ename emp.ename%type,
v_sal emp.sal%type
);

v_emp my_record;

begin
  select e.empno,e.ename,e.sal
  into v_emp
  from emp e where e.empno = '7369';
  
  dbms_output.put_line(v_emp.v_eno||','||
  v_emp.v_ename||','||
  v_emp.v_sal);
end;

~~~

2、手动赋值：

~~~plsql
declare
v_temp number(10);
begin
  v_temp:=100;
  dbms_output.put_line(v_temp);
end;
~~~

### 变量名 表名%rowtype

定义变量可以声明为一张表中的整行类型

格式：

~~~plsql
变量名 表名%rowtype
~~~

赋值的时候可以将表中整行数据查询赋值给它，使用的时候： `变量名.字段`即可

例如：

~~~plsql
declare 
  v_emp emp%rowtype;
begin
  select * into v_emp from emp where empno = 7369;
  dbms_output.put_line(v_emp.empno||','||v_emp.ename||','||v_emp.sal);
end;
~~~

### commit

在增删改的时候用来提交事务

~~~plsql
declare
v_dname department.dname%type;
begin
  v_dname:='自动化';
  insert into department values (myseq0706.nextval,v_dname,30);
  commit;
end;
~~~

### if语句

格式：

~~~plsql
if 条件1 then
结果1
elsif 条件2 then
结果2
...
else
结果n
end if;
~~~

例如：

~~~plsql
declare
  v_emp   emp%rowtype;
  v_grade varchar2(20);
begin
  select * into v_emp from emp where empno = 7369;
  if v_emp.sal < 1000 then
    v_grade := '拖后腿';
  elsif v_emp.sal < 2000 then
    v_grade := '马马虎虎';
  else
    v_grade := '高薪';
  end if;
  dbms_output.put_line(v_emp.empno || ':' || v_emp.sal || ',' || v_grade);
end;
-- 7369:800,拖后腿
~~~

~~~plsql
-- case when 的写法
declare
  v_emp   emp%rowtype;
  v_grade varchar2(20);
begin
  select * into v_emp from emp where empno = 7369;
  v_grade := case trunc(v_emp.sal / 1000, 0)
               when 0 then
                '拖后腿'
               when 1 then
                '马马虎虎'
               else
                '高薪'
             end;
  dbms_output.put_line(v_emp.empno || ':' || v_emp.sal || ',' || v_grade);
end;

~~~



### 循环

循环四要素：

1. 初始化表达式
2. 布尔值测试表达式
3. 循环体
4. 更改表达式

#### loop循环

~~~plsql
初始化 
loop 
循环体
更改表达式
exit when 
end loop;
~~~

例如：

~~~plsql
-- 正序打印1——100
declare
  v_n number(4);
begin
  v_n := 1;
  loop
    dbms_output.put_line(v_n);
    v_n := v_n + 1;
    exit when v_n > 100;
  end loop;
end;
~~~

#### while 循环

~~~plsql
初始化
while 布尔值测试表达式 loop
循环体
更改表达式
end loop;
~~~

例如：

~~~plsql
declare
  v_n number(4);
begin
  v_n := 1;
  while v_n <= 100 loop
    dbms_output.put_line(v_n);
    v_n := v_n + 1;
  end loop;
end;
~~~

#### for循环

~~~plsql
for 变量 in 下限 .. 上限 loop
循环体
end loop;
end;
~~~

例如：

~~~plsql
declare
begin
  for v_n in 1 .. 100 loop
    dbms_output.put_line(v_n);
  end loop;
end;
~~~

### 游标

它是用来储存一组记录的集合，我们可以使用游标来逐条遍历查询结果集中的数据

在数据库中，游标（Cursor）是一个用于处理查询结果集的数据库对象。它提供了一种机制，可以逐行访问和操作查询结果集中的数据。

操作步骤：
1、定义游标：`cursor 游标名 is select语句`
2、打开游标： `open 游标名`
3、不停地提取游标中的下一条数据：`fetch 游标名 into 变量 ` 并通过 `%found ` 判断是否提到数据，如果提到数据则使用
4、关闭游标：`close 游标名`

~~~plsql
-- 原生态游标写法
declare
  v_ename emp.ename%type;
  v_sal   emp.sal%type;
  -- 定义游标
  cursor my_cur is
    select e.ename, e.sal from emp e;
begin
  -- 打开游标
  open my_cur;
  -- 提取第一条数据到变量中
  fetch my_cur
    into v_ename, v_sal;
  while my_cur%found loop
    dbms_output.put_line(v_ename || ',' || v_sal);
    -- 提取下一条数据到变量中
    fetch my_cur
      into v_ename, v_sal;
  end loop;
  -- 关闭游标
  close my_cur;
end;
~~~

#### 使用for循环操作游标

~~~plsql
for 变量名 in 游标名 loop 
使用 变量名.字段 来操作数据
end loop;
~~~

例如：

~~~plsql
declare
  --定义游标
  cursor my_cur is
    select e.ename, e.sal from emp e;
begin
  for c in my_cur loop
    dbms_output.put_line(c.ename || ',' || c.sal);
  end loop;
end;
~~~

综合题：

~~~plsql
--备份emp表
drop table my_emp;
create table my_emp as select * from emp;

-- 修改my_emp 给员工涨工资
-- <1000 up 20%
-- 1000-1900 up 15%
-- >= 2000 up 10%
declare
  cursor cur_emp is
    select * from my_emp;
  v_temp number(4, 2); -- 涨幅变量
begin
  for c in cur_emp loop
    if c.sal < 1000 then
      v_temp := 0.2;
    elsif c.sal < 2000 then
      v_temp := 0.15;
    else
      v_temp := 0.1;
    end if;
    update my_emp me
       set me.sal = me.sal * (1 + v_temp)
     where me.empno = c.empno;
  end loop;
  commit;
end;
-- 测试看看
select * from my_emp;
select * from emp;
~~~

# 2023年7月7日

## exception

当begin代码块报错的时候，就会跳转到exception代码块进行处理，

格式：

~~~plsql
exception
when 异常名 then 打印提示语句
~~~

### 预定义异常：

对于一些常见的异常，Oracle给它们定义好了异常名，我们直接使用

例如：

~~~plsql
declare
  v_emp emp%rowtype;
begin
  select * into v_emp from emp;
  dbms_output.put_line(v_emp.empno || ',' || v_emp.ename || ',' ||
                       v_emp.sal);
exception
  when TOO_MANY_ROWS then
    dbms_output.put_line('当前sql语句查询到多条数据，无法赋值给一个变量');
end;
~~~

### 非预定义异常

对于一些非常见异常，我们自己定义异常名，它的类型是exception，然后使用 `pragma exception_init(异常名,异常编号)`将该异常名和异常编号绑定。这时，就可以在exception中进行捕获和处理

例如：

~~~plsql
declare
  v_dno dept.deptno%type;
  v_exception_del exception;
  pragma exception_init(v_exception_del, -02292);
begin
  v_dno := 20;
  delete from dept where deptno = v_dno;
  dbms_output.put_line('部门号删除成功');
exception
  when v_exception_del then
    dbms_output.put_line('当前部门下还存在员工，无法删除部门！');
end;
~~~

### 自定义异常

这时我们业务逻辑中不符合某个要求而出现的异常，对于数据库来说没有问题。
我们只需要定义异常变量，然后在抛出的地方，使用 `raise 异常变量名`即可对其捕获和操作

~~~plsql
declare
  v_sal emp.sal%type;
  v_exception_sal exception;
begin
  select sal into v_sal from emp where empno = '7839';
  if v_sal > 4000 then
    raise v_exception_sal;
  else
    dbms_output.put_line(v_sal);
  end if;
exception
  when v_exception_sal then
    dbms_output.put_line('对不起，你吃得太多了，公司决定开除你');
end;
~~~

## 函数

function，我们将PL/SQL代码保存到函数中，可以用来被调用，函数必须有返回值

创建函数：

~~~plsql
create or replace function 函数名(参数列表)
return 返回值类型
is
声明部分
begin
程序体
exception 
异常处理
end;
~~~

注意：函数可以被select语句直接调用，也可以被PL/SQL代码调用

例如：

~~~plsql
-- 无参数版本
create or replace function myfun1 return varchar2 is
begin
  return 'hello world';
end;

-- 调用1
select myfun1 from dual;
-- 调用2
begin
dbms_output.put_line(myfun1);
end;
~~~

~~~plsql
-- 有参数版本
create or replace function myfun2(v_pra varchar2) return varchar2 is
begin
return 'hello:' || v_pra;
end;
-- 调用1
select myfun2('Tom') from dual;
-- 调用2
begin
dbms_output.put_line(myfun2('Tom'));
end;
~~~

~~~plsql
   -- 编写函数，输入一个部门编号，返回该部分薪资总和
  create or replace function myfunc4(v_deptno emp.deptno%type) return number is
    v_totalsal number(10,2);
  begin
    select sum(e.sal)
      into v_totalsal
      from emp e
     where e.deptno = v_deptno;
    return v_totalsal;
  end;
  
  select myfunc4(10) from dual;
~~~

## 存储过程

procedure, 我们将PL/SQL代码保存到存储过程中，可以用来调用，存储过程没有return语句，创建存储过程：

~~~plsql
create or replace procedure 存储过程名(参数列表)
is
声明部分
begin
程序体
exception
异常处理
end;
~~~

存储过程能被PL/SQL代码调用

~~~plsql
-- 创建存储过程：向dept表中插入数据
create or replace procedure mypro1(v_deptno dept.deptno%type,
                                   v_dname  dept.dname%type,
                                   v_loc    dept.loc%type) is
begin
  insert into dept values (v_deptno, v_dname, v_loc);
  commit;
end;
-- 使用存储过程
begin
mypro1(50, '开发部', '上海');
end;
~~~

~~~plsql
  -- 编写存储过程，输入一个部门编号，删除该部门
  -- 如果输入的部门编号不存在，则抛出自定义异常，提示部门号不存在
  -- 如果输入的部门编号被员工关联，则抛出非预定义异常，提示存在员工
  -- 如果可以正常删除，则打印“xxx删除成功”
  create or replace procedure del_dept(v_dno dept.deptno%type) is
    e_noresult   exception;
    e_contentemp exception;
    pragma exception_init(e_contentemp, -02292);
    v_count number;
  begin
    select count(*) into v_count from dept d where d.deptno = v_dno;
    if v_count > 0 then
      delete from dept where deptno = v_dno;
      dbms_output.put_line('已删除编号为' || v_dno || '的部门');
      commit;
    else
      raise e_noresult;
    end if;
  exception
    when e_noresult then
      dbms_output.put_line('对不起，该部门编号不存在');
    when e_contentemp then
      dbms_output.put_line('对不起，该部门存在员工，无法删除');
  end;
~~~

~~~plsql
-- 给my_emp 涨工资，1982年以前入职的，涨20%
-- 1982 - 1985年入职的 涨15%
-- 1985年以后入职的  涨10%


drop table my_emp;
create table my_emp as select * from emp;
-- 创建存储过程
create or replace procedure pro_emp is
v_up  number(4,2);  -- 工资涨幅
cursor my_cur is select *  from my_emp ;  
begin
  for c in my_cur loop
if c.hiredate < to_date('1982-01-01','yyyy-mm-dd') then
  v_up := 0.2;
  elsif c.hiredate < to_date('1986-01-01','yyyy-mm-dd') then 
    v_up := 0.15;
    else v_up := 0.1;
    end if;
    c.sal := c.sal * (1 + v_up);
    update my_emp me set me.sal = c.sal where me.empno = c.empno;
end loop;
commit;
end;
-- 运行存储过程
begin 
  pro_emp;
  end;

-- 查看结果
select * from my_emp;
~~~

### 存储过程的参数形式

1、in ---- 只能接收输入参数，它不能改变传入的值，也不能输出
2、默认  ---- 相当于 in
3、out ---- 不能接收输入的参数，可以改变值，并且输出返回
4、in out ---- 既能接收输入参数，又能改变值并且输出返回。

~~~plsql
create or replace procedure my_pro(v1 number,
                                   v2 in number,
                                   v3 out number,
                                   v4 in out number) is
begin
  dbms_output.put_line('v1:' || v1 || ',' || 'v2:' || v2 || ',' || 'v3:' || v3 || ',' ||
                       'v4:' || v4);
  -- v1 := 101;
  -- v2 := 201;
  v3 := 301;
  v4 := 401;
end;

declare v1_t number(10); v2_t number(10); v3_t number(10); v4_t number(10);
begin
v1_t := 100; v2_t := 200; v3_t := 300; v4_t := 400;

my_pro(v1_t, v2_t, v3_t, v4_t); dbms_output.put_line('v1:_t' || v1_t || ',' || 'v2_t:' || v2_t || ',' || 'v3_t:' || v3_t || ',' || 'v4_t:' || v4_t);
end;
-- 打印结果：
--v1:100,v2:200,v3:,v4:400
--v1:_t100,v2_t:200,v3_t:301,v4_t:401

~~~

注意：在函数和存储过程中，如果需要做模糊查询，那么左%和右%是单独拼写在条件字符串中的。

~~~plsql
create or replace procedure my_pro(likevalue varchar2) is cursor my_cur is
  select * from emp e where e.ename like '%' || likevalue || '%';
begin
  for c in my_cur loop
    dbms_output.put_line(c.empno || ',' || c.ename || ',' || c.sal);
  end loop;
end;

begin
  my_pro('A');
end;
~~~

## 删除函数和存储过程

~~~plsql
-- 删除函数
drop function 函数名;
drop procedure 存储过程名;
~~~

## trigger

触发器：它监控着数据库中的某张表上的数据的增删改操作，当发生指定的操作时，自动出发PL/SQL代码执行

语法：

~~~plsql
create or replace trigger 触发器名
before/after
insert/update/delete
on	表名
for each row
声明部分
begin
执行部分
end;
~~~

注意： for each row表示行级触发器，每更新一行触发一次，如果不写，，则是语句级触发器，每执行一条语句触发一次。

~~~plsql
create or replace trigger my_tri1
after
update 
on my_emp
for each row
  begin
    dbms_output.put_line('hello world');
    end;
~~~

`:old.字段名` ---- 在触发器中可以获取该字段增删改操作之前的值

~~~plsql
-- 创建备份表
create table my_emp_bak as select * from my_emp where 1=2; 

-- 实时对被删除的数据进行备份的触发器
create or replace trigger my_tri2
  before delete on my_emp
  for each row
begin
  insert into my_emp_bak
  values
    (:old.empno,
     :old.ename,
     :old.job,
     :old.mgr,
     :old.hiredate,
     :old.sal,
     :old.comm,
     :old.deptno);
end;


select * from my_emp;
select * from my_emp_bak;

delete from my_emp ; 
-- 当my_emp表中数据被删除时，会立刻往my_emp_bak中添加相同数据
~~~

## 键盘输入

~~~plsql
变量名 := '&变量名';
~~~

~~~plsql
declare
  v_1 number;
  v_2 varchar2(255);
begin
  v_1 := '&v_1';
  v_2 := '&dsfsdfsd'; -- '&后面随便写点啥都行
  dbms_output.put_line(v_1);
  dbms_output.put_line(v_2);
end;
~~~

## 对一张表的增删改查存储过程

~~~plsql
select * from dept;

create or replace procedure addOne(v_deptno dept.deptno%type,
                                   v_dname  dept.dname%type,
                                   v_loc    dept.loc%type) is
begin
  insert into dept values (v_deptno, v_dname, v_loc);
  commit;
end;

  create or replace procedure deleteOne(v_deptno dept.deptno%type) is
  begin
    delete from dept where dept.deptno = v_deptno;
  end;
  
  create or replace procedure updateOne(v_deptno dept.deptno%type,
                                        v_dname  dept.dname%type,
                                        v_loc    dept.loc%type) is
  begin
    update dept
       set dept.dname = v_dname, loc = v_loc
     where deptno = v_deptno;
  end;
  
  
  create or replace procedure findALL is
    cursor v_depts is
      select * from dept;
  begin
    for c in v_depts loop
      dbms_output.put_line(c.deptno || ',' || c.dname || ',' || c.loc);
    end loop;
  end;
      
      create or replace procedure findById(v_deptno dept.deptno%type) is
        v_dept dept%rowtype;
      begin
        select * into v_dept from dept where deptno = v_deptno;
        dbms_output.put_line(v_dept.deptno || ',' || v_dept.dname || ',' ||
                             v_dept.loc);
      end;
        
        -- 查询所有
        declare
        begin
          findAll;
        end;
          
          -- 查询一条
          declare
          begin
            findById('40');
          end;
        
        -- 删除一条
        declare
        begin
          deleteOne('50');
        end;
          
          -- 增加一条
          declare
          begin
            addOne('50', '测试部', '背景');
          end;
        -- 修改一条
        declare
        begin
          updateOne('50', '轻音部', '日版');
        end;

~~~




# 2023年7月8日

java之父 ：James Gosling 詹姆斯·高斯林

## java -- 面向对象

`JavaSE `： Java标准版

`JavaEE`：Java企业版

`JavaME`：Java移动版（用于塞班系统，已经接近淘汰）

### java的特性

1、跨平台：一次编译到处运行
java是运行在虚拟机（JVM）上的，虚拟机跨平台，shell语言和python语言都是运行在操作系统上的
JRE ---- Java运行环境（包含了JVM，还包含了别人写好的代码）
JDK ---- Java开发工具包

2、垃圾回收
在内存中释放没用的变量

### 环境变量

1、`JAVA_HOME` ---- java安装程序的根目录

2、`path` ---- 根目录下的bin文件夹，使得当前系统能够直接找到bin文件夹中的所有开发工具

3、`CLASSPATH` ---- 首先在当前目录寻找java代码，然后在根目录下的`lib`中寻找java代码

### 命令行运行java

java文件后缀是`.java`，这是原文件我们需要通过`javac`命令对它进行编译，得到编译后文件，也就是.class文件

运行java程序，使用`javac名` + 类名

~~~shell
javac Hello.java

java Hello
~~~

### java规范

1、类名首字母大写，并且和文件名同名
2、多写注释：

~~~java
/* 开头
xxxx
xxx
*/结尾 它能注释一段
    
    //它能注释一行
~~~

### 标识符

字母数字下划线和$，不能以数字开头

所有标识符必须遵循见名知意和驼峰原则

变量名和方法名：首字母小写，后面单词首字母大写   lowerCamelCase

类名：所有单词首字母大写											UpperCamelCase

包名：全小写	

常量名：全大写

### 整型的取值范围

byte ---- -2^7 到 2^7- 1

short ---- -2^15 -> 2^15 -1

int ---- -2^31 -> 2^31-1

long ---- -2^63 -> 2^63-1

默认整型为int型

### 浮点型

float ---- -2^128 -> 2^127

double ---- -2^1024 -> 2^1023

默认浮点型为double型

### 字符型char

### 布尔型boolean

注意：\表示转义字符，它有特殊的含义

\n ---- 换行

\t ---- 缩进（水平制表符）

\\\ ---- 打印反斜杠

注意：局部变量的作用范围是它所定义的语句所在的当前的一对大括号

### 自动类型转换

容量小的数据类型和容量大的数据类型作运算时，会自动将容量小的类型转容量大的类型，然后再运算。

当容量小的数据类型的值赋给容量大的数据类型的变量时，也会自动将类型转大，再赋值。

容量的大小问题：
1、byte,short,char  这三种并列最小，当它们之间进行运算时，统一转成int，然后运算
注意：这三者哪怕是相同的类型在进行运算，也会转为int

~~~java
		short s5 = 200;
		short s6 = 300;
		short s7 = s5 + s6;//s5 + s6还是会转换成int进行运算，因此报错
~~~

注意：char型在运算的时候，使用的是UNICODE编码

2、除此以外，从小到大的顺序：int->long->float->double

### 强制类型转换 

---- 容量大的数据类型转容量小的数据类型需要使用一对小括号（目标类型）来完成

强制类型转换可能会有精度的溢出

# 2023年7月10日

## String --- 字符串

字符串在跟其他任何数据类型运算的时候，只有加号+，加号的含义不是加法，而是字符串的拼接

~~~java
	String s3 = "hello";
	int i3 = 12;
	char c1 = 'a';
	System.out.println(s3 + i3 + c1);//hello12a
	System.out.println(i3 + c1 + s3);//109hello
	System.out.println(c1 + s3 + i3);//ahello12
~~~

## ++和--

++a : 先自增再使用变量
a++ ：先使用变量再自增 

if语句的条件判断必须传入boolean值，否则编译报错

赋值运算符“=”，本身也是有值的，它的值就是等号右边的值。

## 逻辑运算符

单&时，左边无论真假，右边都进行运算
双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算

`|`和`||`区别同理

## 位运算符

n >> m ---- n右移m位，相当于n除以2的m次方

n << m ---- n左移m位，相当于乘以2的m次方

## 三元运算符

条件表达式?值1：值2 ---- 条件表达式成立则位值1，否则为值2

注意：当多种运算符并存的时候，不用考虑优先级的高低，只需要使用一对小括号把自己认为先算的括起来即可

## 分支语句

注意：在if语句中，如果某个分支只有一行代码，那么该分支的一对大括号可以省略。

~~~java
class Test4 {
	public static void main(String[] args){
		int x = 4,y = 1;
		if(x>2){
			if(y>2)
				System.out.println(x + y);//if语句只管这一行
			System.out.println("ss");//这么写也不会报错
		}else
			System.out.println("x = " + x);
		System.out.println("hello world");
	}
}
~~~

打印结果：

~~~java
ss
hello world
~~~

## 键盘输入Scanner

~~~java
import java.util.Scanner;

class Test4 {
	public static void main(String[] args){
		/*
		控制台打印：请输入一个年份
		打印该年份是不是闰年
		闰年条件：
		1.如果该年份能被4整除，但不能被100整除，那么就是run'nian
		2.如果该年份能被400整除，也是
		*/
		
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个年份");
		int year = sc.nextInt();
		if((0 == year%4 && 0 != year%100)||0 == year%400){
			System.out.println("是闰年");
		}else{
			System.out.println("不是闰年");
		}
		sc.close();//关闭流	
	}
}
~~~

## switch

~~~java
switch(变量名){
    case 值1:
        代码块1;
        break;
    case 值2:
        代码块2;
        break;
        ...
    default:
        代码块n;
    break;
}
~~~

注意：多个case可以公用一个代码块。

### 面试题

switch语句允许传入哪些数据类型的变量？

byte short int char Enum 
1.7及以后版本的jdk中允许传入String

## 循环四要素

1.初始化表达式
2.布尔值测试表达式
3.循环体
4.更改表达式

### 嵌套循环

一个循环是另外一个循环的循环体，那么该循环就是内层循环，另一个就是外层循环。
内层循环执行结束，外层循环才执行一次
外层循环执行结束，内层循环执行了内层*外层的次数

## break 

结束当前循环，
注意：在嵌套循环中，它结束当前这一层循环

## 无限循环

循环的布尔值测试表达式为true，循环一直执行

while(true)

for(;;){}

## continue

结束当前这一次循环，开启下一次循环

## return

用来结束当前这个方法

注意：当被调用的方法有指定的返回值类型时，该方法中必须写`return 该类型对象`  给调用者，当执行到return语句时，方法也会提前结束。

# 2023年7月11日

## 数组

这是一个容器，可以用来存放指定类型的数值。

定义数组：
1.动态初始化：

~~~java
数组类型[] 数组名 = new 数组类型[长度];
int[] arr = new int[3];
~~~

2.静态初始化：

~~~java
int[] arr = new int[]{1,2,3,4};
//注意：还可以简写
 int[] arr2 = {1,2,3,4};
~~~

~~~java
数组名.length ---- 获取数组长度
~~~

注意：数组一旦初始化，那么它的长度就不能被修改

数组的遍历：

~~~java
int[] arr = new int[]{1,2,3,4};
//1.for循环遍历
for(int i = 0;i < arr.length;i++){
    System.out.println(arr[i]);
}

//2.forEach遍历
for(int j:arr){
	System.out.println(j);
}
~~~

注意：forEach的缺点在于，它只要遍历，就一次性直接遍历完，中途无法获取当前遍历元素的下标

### 冒泡排序

相邻两个数进行比较，如果需要，那么就交换位置，一轮结束，最小的数就排到了第一位，第二轮结束，第二小的数排到了第二位

~~~java
   public static void bubbleSort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {5, 2, 8, 12, 1, 6, 4};
        bubbleSort(array);
        for (int i : array) {
            System.out.print(i + " ");
        }
    }
~~~

## 快速排序

1. 选定Pivot中心轴
2. 将大于Pivot的数字放在Pivot的右边
3. 将小于Pivot的数字防在Pivot的左边
4. 分别对左右子序列重复前三步的操作



注意：实际项目中如果需要排序，则直接调用`java.util.Arrays`包中的`Arrays.sort(数组名)`即可

~~~java
Arrays.toString(数组名); //将数组转成字符串
System.out.println(Arrays.toString(arr));//可以打印数组所有内容
~~~

## 二维数组

一个一维数组中的每个小格子装的都是一个一维数组，那么这就是二维数组

动态初始化：

~~~java
数组类型[][] 数组名 = new 数组类型[长度][长度];
		int[][] arr = new int[3][2];
		arr[0][0] = 101;
		arr[0][1] = 102;
		arr[1][0] = 201;
		arr[1][1] = 202;
		arr[2][0] = 301;
		arr[2][1] = 302;
		
		for(int[] childArr:arr){
			for(int i: childArr){
				System.out.println(i+" ");
			}
			System.out.println();
		}
~~~

静态初始化：

~~~java
		int[][] arr = {{101,102},{201,202},{301,302}};

		System.out.println(arr.length);//3
		for(int i = 0;i < arr.length;i++){
			for(int j = 0;j < arr[i].length;j++){
				System.out.print(arr[i][j] + " ");
			}
			System.out.println();
		}
~~~



### 面试题

动态初始化和静态初始化的区别：

静态初始化是在编译期间完成的。

动态初始化的初始化语句和赋值语句分开写。而静态初始化的初始化语句和赋值语句是同一句话

## java中的默认值

整型：0

浮点型：0.0

字符型：'\u0000'

布尔型：false

引用类型：null

注意：当我们使用动态初始化定义一个数组，那么它里面每个小格子都装着一个默认值



## 面向对象的编程思路：

1. 找名词
2. 名词分两类，实体和属性
3. 将每个实体定义成一个类，每个属性定义成类中的一个成员变量
4. 确定类和类之间的关系，编写方法

注意：将某个类的对象传入另一个类的某个方法中，可以体现它们之间的关联关系

## 创建对象

~~~java
new 构造方法();
~~~

## 成员变量

定义在方法外的变量，用来描述类中的某个属性，随着类的加载而诞生，在构造方法之前

## 构造方法

随着对象的实例化而调用

与类同名，并且没有返回值，也不能写void，它只能被new调用，用来创建对象，当我们不写构造方法，系统将默认提供一个无参构造方法。

一般来讲，我们会将给对象赋属性值的动作写入构造方法。当被调用时需要传入参数为属性赋值

注意：通常当我们写了一个有参的构造方法，最好再写一个无参的构造方法，提供给别人调用。

## 内存解析

**栈内存** ---- 存放局部变量，方法的运行也在栈内存中

**堆内存** ---- 存放所有的对象

**方法区** ---- 存放所有的代码，它里面还包含常量池

**本地方法栈** ---- 和操作系统相关（仅作了解）

**程序计数器** ---- 和cpu相关（仅作了解）

注意：当栈空间中的局部变量是引用类型，那么它存放的一定是一个地址，这是一个堆空间中某个对象的地址。当局部变量的作用范围结束，它会立即从栈空间中被删除，然后堆空间中的对象会变成垃圾。在未来的某个时刻被垃圾回收器gc收走，释放内存

# 2023年7月12日

## 重载

在一个类中有多个方法，他们的方法名是一样的，他们的参数不一样（参数不一样体现在：参数的个数、参数的类型），根据调用者传入的参数决定调用的是哪个方法

**注意**：仅仅是方法的返回值类型不一样不构成重载

注意：构造方法也是可以重载的，根据传参决定由哪个构造方法创建对象

注意：不要以参数名的不同来定义重载，那不是重载，那就是相同的方法

## this

它是一个引用，它存放当前对象的地址，我们可以使用`this.成员变量`来访问当前对象的成员变量，`this.方法`来调用当前对象所在类的方法。

~~~java
public class Leaf {
    int i;

    public Leaf() {
    }

    public Leaf(int i) {
        this.i = i;
    }

    public Leaf increment() {
        this.i++;
        return this;
    }

    public void print() {
        System.out.println(this.i);
    }

    public static void main(String[] args) {
        Leaf leaf = new Leaf(1);
        leaf.increment().increment().increment().print();//链式调用
    }
}
~~~



## static

静态的，它可以用来修饰成员变量和方法

被static修饰的成员变量被成为静态成员变量，它被该类所有的对象共享，它在内存中只有一份，存放在内存中的常量区

static的成员变量可以由类名直接调用，它可以用来计数

~~~java
public class Cat {

    int id;
    String name;
    static int sid;

    Cat() {
        this.id = sid++;
    }


    Cat(String name) {
        this.id = sid++;
        this.name = name;
    }

    public static void main(String[] args) {
        Cat.sid = 1;
        Cat c1 = new Cat();
        c1.name = "Tom";

        Cat c2 = new Cat("小白");

        System.out.println(c1.id + "," + c1.name);//1,Tom
        System.out.println(c2.id + "," + c2.name);//2,小白

    }
}
~~~

被static修饰的方法被称为静态方法，静态方法又称为类方法，在静态方法中不能直接使用非静态的成员变量或非静态的方法。静态方法中不能用this

# 2023年7月13日

## 包

package

为了解决类名冲突的问题，Java引入了包的机制，我们往往先创建包，再创建类，类名上方出现package语句用来描述当前类所在的包。

注意：

- 同一个包下不能出现相同的包名
- 如果需要使用不同的包下的类，必须编写全类名（带包名的类名），或者使用`import`语句将该类导入

注意：`import`语句中的 `* `表示通配符，它可以导入某个包下的所有类

java.lang是整个JDK唯一一个无需导包就可以直接使用的包，它里面都是一些非常常用的类。

注意：通常对于包名的命名都会采用所在公司域名的倒写。

## 继承

“xxx”是一种“yyy”，只要这句话能说得通，这两个类就具有继承关系，被继承的类称为父类（基类，超类），继承的类称为子类（派生类）

子类自动拥有父类中所有的成员变量和方法，除此之外，子类还可能拥有其他新增加的属性和方法

**注意**：子类拥有父类的private方法，只是不可见

创建子类语法：

~~~java
class 类名 extends 父类类名{
    
}
~~~

Java语言是单继承，一个子类不能同时继承多个父类，但是，继承有传递性

## 访问控制符

| 访问控制符 | 同一个类 | 同一个包 | 子类   | 任何地方 |
| ---------- | -------- | -------- | ------ | -------- |
| private    | √        |          |        |          |
| default    | √        | √        |        |          |
| protected  | √        | √        | √ or × |          |
| public     | √        | √        | √      | √        |

public修饰的类可以在任何地方使用

**子类与基类不在同一包中**：子类的类定义中可以访问父类的protected方法，子类的实例不能访问父类的protected方法

注意：子类拥有父类中的private方法，但子类不能使用该方法

## JavaBean

一个实体类，应该将所有成员变量私有化，并提供公共的get/set方法给外界调用，来对成员变量存值和取值

getset比起直接取用成员变量的好处：

- 可以在方法内添加异常处理逻辑，以处理潜在的异常情况。例如，在设置成员变量时，你可以检查传入的值是否合法，如果不合法则抛出异常。而直接取成员变量则无法进行这种异常处理。
- 可以设置只读只写，程序更加灵活多变

至少提供一个无参构造器来创建对象。

JavaBean体现了面向对象的封装性。

## 重写

子类继承父类，子类对父类的方法不满意，那么子类可以重写父类中的方法，被重写的方法和重写的方法必须有相同的声明部分。它们的方法实现不一样，根据调用者的类型来决定调用哪个方法。

我们可以在重写的方法上方使用@Override注解来检查是不是重写

## super

这是一个引用，它在每个对象内部，它存放着当前对象的父类对象的内存地址，我们可以使用super.成员变量来访问父类对象的属性，我们可以使用super.方法来调用父类的方法。

子类在内存中会包含父类的部分：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689219257/javaStudy/%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E7%B1%BB%E4%B9%9F%E4%BC%9A%E5%AF%B9%E5%BA%94%E7%94%9F%E6%88%90%E4%B8%A4%E4%B8%AA%E7%88%B6%E7%B1%BB_a9u2hy.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689219257/javaStudy/如果有两个子类也会对应生成两个父类_a9u2hy.jpg)

~~~java
//父类
public class FatherClass {
    int value;
}
//子类1
public class SubClass extends FatherClass{
}
//子类2
public class SubClass2 extends FatherClass{
}
//测试
public class Test {

    public static void main(String[] args) {
        SubClass subClass = new SubClass();
        SubClass2 subClass2 = new SubClass2();
        subClass.value = 1;
        subClass2.value = 2;
        System.out.println(subClass.value);//1
        System.out.println(subClass2.value);//2
        //事实证明子类的对象包含父类的部分，并且并不想通
    }
}
~~~

## 继承中的构造方法

1. 子类在构造的过程中必须首先调用父类的构造方法来构造父类对象。
2. 在子类的构造方法中可以使用super(参数)来调用父类指定的某个构造方法构造父类对象。
3. super()可以不写，那么默认调父类无参构造方法，如果写了，则必须写在子类构造方法的第一行
4. 如果不写super()而父类中又没有无参构造方法，则编译报错

## this()

在某个构造方法中调用其他构造方法来创建对象，一旦使用，也必须放方法的第一行

## Object

这是所有类的父类，当我们定义的某个类不继承任何类，那么它就直接继承了Object类，所有类都拥有并可以使用Object类中的方法。

## toString()

用一个字符串的形式来描述当前对象

## 父类引用指向子类对象

子类对象当作父类对象去使用（向上转型）

向上转型又称为父类引用指向子类对象。

当父类引用指向子类对象的时候，父类引用无法访问子类对象中新增加的成员。

注意：父类引用指向子类对象的好处：代码可扩展性比较好

~~~java
//假设Cat、Dog、Bird都是Animal的子类，分别有自己的一些独立方法
public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat("猫", "蓝色");
        Animal a2 = new Dog("狗", "红色");
        Animal a3 = new Bird("鸟", "绿色");

        f(a1);
    }
    //可扩展性体现在此
    static void f(Animal a) {
        System.out.println();
        if (a instanceof Cat) {
            System.out.println(((Cat) a).getEyesColor());
        } else if (a instanceof Dog) {
            System.out.println(((Dog) a).getFurColor());
        } else if (a instanceof Bird) {
            System.out.println(((Bird) a).getColor());
        }
    }
}

~~~



## instanceof

用来判断某个对象是否是某个类或该类子类的对象。

~~~java
    //假设Cat类和Dog类都是Animal类的子类
public static void main(String[] args) {
        Animal a = new Animal();
        Cat c = new Cat();
        a = new Cat();

        System.out.println(a instanceof Animal);//true
        System.out.println(a instanceof Cat);//true
        System.out.println(a instanceof Dog);//false
    }
~~~

## 向下转型

将父类变量使用`(子类类型)`转成子类类型，向下转型之后，该引用就可以访问子类中新增加的成员。

~~~java
        Animal a = new Cat();
        Cat c  = (Cat)a;
        c.eyeColor();
~~~

## 多态

运行时多态：当父类引用指向子类对象的时候，父类引用调用父类的方法，实际上调用到的是子类重写过后的方法，

多态是面向对象的核心机制，它的存在使得我们的代码可扩展性达到了最好

## 抽象类和抽象方法

只有声明而没有实现的方法

抽象类：含有抽象方法的类

抽象方法和抽象类都必须被abstract关键词修饰

抽象类不能被实例化，抽象类都是用来被继承的，继承了抽象类，就必须要重写该抽象类中所有的抽象方法
# 2023年7月14日

## equals(对象)

判断当前对象是否与传入对象相等

Object的equals(对象) ---- 它判断的是两个对象是否是同一个对象，只有同一个对象才认为相等，否则都是不等。所以我们通常需要对Object类的equals方法进行重写，把我们自己认为相等的标准写入equals()

一般来讲，我们都会以成员变量值全部相等，作为相等的标准。

~~~java
public class Cat {

    int color;
    int height;
    int weight;

    public Cat(int color, int height, int weight) {
        this.color = color;
        this.height = height;
        this.weight = weight;
    }

    @Override
    public boolean equals(Object obj) {
        if (null == obj) {
            return false;
        }
        if (!(obj instanceof Cat)) {
            return false;
        } else {
            Cat c = (Cat) obj;
            if (c.color == this.color && c.height == this.height &&
                    c.weight == this.weight) {
                return true;
            } else {
                return false;
            }
        }

    }
}

//test
public class Test {


    public static void main(String[] args) {
        int i = 100;
        int j = 100;
        System.out.println(i == j);//true

        Cat c1 = new Cat(999, 12, 12);
        Cat c2 = new Cat(999, 12, 12);
        System.out.println(c1 == c2);//false
        System.out.println(c1.equals(c2));//true
    }
}

~~~

## final

它可以用来修饰一个类，表示该类不能被继承

它可以用来修饰一个方法，表示该方法不能被重写

它可以用来修饰一个变量，表示该变量值不能改

## 常量

~~~java
public static final 常量类型 常量名
~~~

## 接口

接口中的方法都是抽象方法，它使用interface定义

接口中的方法默认都是public的

接口是抽象方法和常量的集合

类可以通过implements来实现接口，实现接口就必须要重写接口中所有的抽象方法。

在调用的时候，我们可以通过接口类型的引用指向其实现类的对象。当我们使用该引用调用接口类的方法，实际执行的是实现类中重写的方法，所以接口也具有多态性

一个接口可以被多个无关的类实现
一个类可以同时实现多个无关的接口
如果接口的引用指向实现类的对象，那么该引用只能访问当前接口中的方法

## 异常处理

~~~java
try{
    可能抛出异常的代码
}catch (异常类型 变量名){
    当抛出该异常类型对象时的处理语句
}
~~~

## throws 

当我们的方法可能抛出某个异常时，我们不作处理，使用throws抛给调用者来处理

对于编译时异常，不try catch则，必须要写throws，

对于运行时异常，不try catch，写不写throws都可以在它的调用者处进行异常处理

~~~java
public class Test3 {


    public static void main(String[] args) {
        f(10);
    }

    public static void f(int i) throws ArithmeticException {
        int res = 0;
        res = 100 / i;
        System.out.println(res);
    }
}
~~~

## throw

手动抛一个异常（就算实际没发生异常，也能抛出来）

~~~java
public class Test {
    public static void main(String[] args) {
        try {
            f();
        } catch (ArithmeticException e) {
            System.out.println("抛出一个异常0");
        }
    }

    public static void f() throws ArithmeticException {
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        if (0 == i)
            throw new ArithmeticException();
        sc.close();
    }
}
~~~

所有异常类的结构图：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689314013/javaStudy/%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE_sw0vzq.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689314013/javaStudy/所有异常类的结构图_sw0vzq.jpg)

### 常见异常

1. NullPointerException (空指针异常)：当试图在一个空对象上调用方法或访问属性时抛出。
2. IllegalArgumentException (非法参数异常)：当传递给方法的参数不合法时抛出，例如传递了不允许的值或无效的参数。
3. ArrayIndexOutOfBoundsException (数组索引越界异常)：当访问数组中不存在的索引时抛出。
4. ArithmeticException (算术异常)：当发生数学运算错误时抛出，例如除数为零。
5. ClassCastException (类转换异常)：当试图将一个对象强制转换为不兼容的类时抛出。
6. IllegalStateException (非法状态异常)：当对象处于不允许的状态时抛出，例如在调用方法之前或之后。
7. IOException (输入输出异常)：处理输入和输出操作时可能发生的异常，例如文件读写错误。
8. FileNotFoundException (文件未找到异常)：当试图打开不存在的文件时抛出。
9. InterruptedException (中断异常)：当线程在等待、休眠或阻塞状态时被中断时抛出。
10. UnsupportedOperationException (不支持操作异常)：当不支持的操作或方法被调用时抛出。

运行时异常在编译的时候可以不做处理，而编译通过。

非运行时异常在编译的时候，必须try catch 或者throws，否则编译报错

读取文件：

~~~java
    public static void main(String[] args) {
        InputStream is = null;
        try {
            is = new FileInputStream("D:\\java\\MyProject\\test20230714\\src\\com\\iweb\\test\\Test4.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

## finally

它是跟在try catch后面的第三个代码块，表示无论是否抛异常，都一定要执行的代码

注意：当finally代码块之前执行了return语句，那么，finally代码块中的代码也一定会执行，而且会在return之前执行

注意：当一个try代码块对应多个catch代码的时候，catch代码块的先后顺序要求先捕获子类异常，后捕获父类异常

### 面试题

final、finally、finalize三个单词有什么区别



finalize：垃圾回收器调用的一个方法的方法名

## String

字符串，不可变的字符序列

字符串是常量，存放在常量区

注意：做项目的过程中，凡是牵涉到字符串的比较，一律使用equals()

new String("hello");  ---- 创建了两个对象，先在常量池创建"hello"，然后再拷贝一份到堆内存

~~~java
    public static void main(String[] args){
        String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1 == s2);//true
        String s3 = "he" + "llo";
        System.out.println(s1 == s3);//true
        String s4 = new String("hello");
        System.out.println(s1 == s4);//false
        System.out.println(s1.equals(s4));//true
    }
~~~

使用了""和+之外的字符串都不再是同一个

常用方法

~~~java
        String s2 = "hello";
        System.out.println(s2.charAt(4));//o
        System.out.println(s2.endsWith("llo"));//true
        System.out.println(s2.endsWith("hel"));//false
        System.out.println(s2.endsWith(""));//true
        String s5 = "HELLO";
        System.out.println(s2.equals(s5));//false
        System.out.println(s2.equalsIgnoreCase(s5));//true
        System.out.println(s2.indexOf("o"));//4
        System.out.println(s2.isEmpty());//false
        String s6 = "";
        System.out.println(s6.isEmpty());//true
        System.out.println(s2.length());//5


        String s7 = s2.replace("ll", "LL");
        System.out.println(s7);//heLLo
        System.out.println(s2);//hello  常量是不会变的
        String s8 = "Java,Oracle,Html,Servlet,Spring,Vue";
        String[] arr = s8.split(",");
        for(int i = 0;i < arr.length;i++){
            System.out.print(arr[i] + "  ");
        }//Java  Oracle  Html  Servlet  Spring  Vue
        String s9 = s2.substring(0,4);
        System.out.println();
        System.out.println(s9);//hell
        String s10 = s2.toUpperCase();
        System.out.println(s10);//HELLO
        String s11 = s10.toLowerCase();
        System.out.println(s11);//hello
        String s12 = "         sfaf      ";
        String s13 = s12.trim();//无法去除字符串中间的空格
        System.out.println(s13);//sfaf
        System.out.println(s12);//         sfaf
        Cat c = new Cat();
        String s14 = String.valueOf(c);
        System.out.println(s14);//com.iweb.test.Cat@745f
~~~

注意：trim()无法去除字符串中间的空格，要用以下方法：

~~~java
        String s15 = "  hello my  friend  ";
        String s16 = s15.replaceAll("\\s+","");
        System.out.println(s16);
//使用了正则表达式\\s+来匹配一个或多个连续的空格，并将其替换为空字符串，从而实现去除空格的效果。
~~~

在Java中，`\\s+` 是一个正则表达式，表示匹配一个或多个连续的空白字符。空白字符包括空格、制表符、换行符和回车符等。

正则表达式中的 `\\s` 表示空白字符，而 `+` 表示匹配前面的元素一次或多次。因此，`\\s+` 表示匹配一个或多个连续的空白字符。

你可以使用 `\\s+` 来进行字符串的分割和匹配。以下是一些示例用法：

~~~java
String input = "Hello   World   Java";
String[] words = input.split("\\s+");

// 结果：words = ["Hello", "World", "Java"]
~~~



## 加密算法

使用 `DigestUtils.md5Hex(明文)`;

~~~java
    public static void main(String[] args) {
        String s1 = "123456";
        String s2 = DigestUtils.md5Hex(s1);
        System.out.println(s2);//e10adc3949ba59abbe56e057f20f883e
    }
~~~



sha256加密 ---- 使用`DigestUtils.sha256Hex(明文)`

~~~java
        String s3 = DigestUtils.sha256Hex(s1);
        System.out.println(s3);
~~~

## StringBuffer

可变的字符序列，它里面的字符串内容可以被改变

append(字符串) ---- 将传入的字符串追加到当前字符串后面

insert(下标，字符串) ---- 将传入的字符串插入指定下标

delete(起始下标，结束下标) ---- 删除指定下标位置开始到指定下标位置结束的子字符

~~~Java
    public static void main(String[] args){
        StringBuffer stringBuffer = new StringBuffer("hello");
        stringBuffer.append(" world");
        System.out.println(stringBuffer);//hello world
        stringBuffer.insert(3,"Tom");
        System.out.println(stringBuffer);//helTomlo world
        stringBuffer.delete(3,6);//从下标为3删到下标为6
        System.out.println(stringBuffer);//hello world

    }
~~~

## StringBuilder

和StringBuffer类似，也是可变字符序列

StringBuffer和StringBuilder的区别：

- StringBuffer是线程同步的，在多线程的项目中，安全性高，但是效率低
- StringBuilder是线程不同步的，在多线程的项目中，安全性低，但效率高

## Math

数学相关的类

sqrt ---- 平方根

random ---- [0.0,1.0) 的随机小数

abs ---- 绝对值

round ---- 四舍五入求整数部分

max ---- 最大值

min ---- 最小值

# 2023年7月15日

## Date

日期类，创建出Date对象表示当前时间，我们可以使用SimpleDateFormat对象来定义年月日时分秒的格式，格式中：y表示年，M表示月，d表示日，h表示小时，m表示分钟，s表示秒

我们可以使用SimpleDateFormat对象调用format方法传入Date对象得到符合该格式的日期字符串。

~~~java
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);//Sat Jul 15 09:19:13 CST 2023
        SimpleDateFormat sdf =
                new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
        String s = sdf.format(date);
        System.out.println(s);//2023-07-15 09-19-13
    }
~~~

#### 争锋软件面试题

```java
//1 如何获取年月日、小时分钟秒
Date date = new Date();
System.out.println(date);
//2 如何取得从1970年1月1日0时0分0秒到现在的毫秒数
System.out.println(date.getTime());
//3 如何取得某月的最后一天
YearMonth yearMonth = YearMonth.of(2023, 7);
System.out.println(yearMonth.getMonth() + "的最后一天：" + yearMonth.lengthOfMonth());
//4 如何格式化日期
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String s = sdf.format(date);
System.out.println(s);
```

## BigDecimal

大数值型，它可以在项目中进行算数运算，它的底层是字符串，没有长度限制，它也没有浮点型精度误差的问题，它提供了一些方法供我们调用：

add() ---- 加法

subtract() ---- 减法

multiply() ---- 乘法

divide() ---- 除法，在除法中，第二个参表示小数位，第三个参表示保留方式，ROUND_HALF_UP表示四舍五入的方式

计算结果也是BigDecimal对象，我们可以调用它的xxxValue()转成基本数据类型

~~~java
    public static void main(String[] args) {
        double d1 = 1.0;
        double d2 = 3.0;
        BigDecimal b1 = new BigDecimal(String.valueOf(d1));
        BigDecimal b2 = new BigDecimal(String.valueOf(d2));
        BigDecimal res = b1.add(b2);
        System.out.println(res);//4.0
        double resultDouble = res.doubleValue();
        System.out.println(resultDouble);//4.0

        BigDecimal res2 = b2.subtract(b1);
        System.out.println(res2);//2.0

        BigDecimal res3 = b1.multiply(b2);
        System.out.println(res3);//3.00

        BigDecimal res4 = b1.divide(b2, 5, BigDecimal.ROUND_HALF_UP);
        System.out.println(res4);//0.33333


    }
~~~

## 枚举型

使用enum来定义该类型，该类型的变量只能在指定的若干值中间获取

定义格式：

~~~java
enum 枚举类型名{
    值1，值2...
}
~~~

定义变量并初始化：

枚举类型 变量名 = 枚举类型.值

~~~java
public enum MyColor {
    red,blue,green,yello
}
~~~

~~~java
        MyColor m = MyColor.blue;
        System.out.println(m);//blue
        switch (m) {
            case red:
                System.out.println("红色");
                break;
            case green:
                System.out.println("绿色");
                break;
            case blue:
                System.out.println("蓝色");
                break;
            default:
                System.out.println("黄色");
                break;
        }
~~~

## 基本数据类型包装类

java中针对8种基本数据类型，分别提供了各自的包装类

当传入参数需要用到对象而不是数值的时候，就轮到包装类上场了

Integer ---- int

Character ---- char

剩下的6种，首字母转大写即可

创建包装类的对象，只需要将基本数据类型数值传入包装类的构造方法即可

从包装类对象种取出基本数据类型数值只需要调用xxxValue()即可

valueOf(字符串) ---- 将字符串中的数值取出获取最基本数据类型的包装类对象

parseXxx(字符串) ---- 将字符串中的数值取出获取该基本数据类型的数值

~~~java
    public static void main(String[] args) {
        Integer integer = new Integer(100);
        System.out.println(integer);
        int i = integer.intValue();//Integer  -> int
        System.out.println(i);

        String s = String.valueOf(i);//int -> String
        System.out.println(s);

        Integer integer1 = Integer.valueOf(s);//String  -> Integer
        System.out.println(integer1);
        
        //Integer.parseInt()
        int i1 = Integer.parseInt(s);//String -> int
        System.out.println(i1);

    }
~~~

注意：如果从字符串中解析数值，则该字符串中的数值必须符合类型规范，否则会抛出NumberFormatException异常

成员变量只声明未初始化在类初始化时会赋予默认值可以直接使用；局部变量必须赋值才可以使用，如果局部变量未赋值，**编译无法通过**。

基本数据类型的包装类对象的默认值为null



## 集合

常用的集合类：

List ---- 这是一个接口，里面存放的元素都是有序的，可重复的

List接口有一个ArrayList的实现类，它的底层是数组

add(对象) ---- 添加元素

size() ---- 获取List中元素的个数

get(下标) ---- 根据下标获取该下标位置的元素

contains(对象) ---- 判断当前集合是否包含指定对象

remove(对象) ---- 从当前集合中删除指定对象（如果有多个一模一样的对象，移除第一个匹配到的）

注意：不管是contains还是remove，传入的对象，都需要和当前集合中的某个对象相互equals才能完成操作

~~~java
		//Student类中必须重写equals方法，才能使用contains和remove方法
        System.out.println(list.contains(
                new Student("1000", "zhangsan", 12)));
        System.out.println(list.remove(
                new Student("1000", "zhangsan", 12)));
            
~~~

Iterator ---- 迭代器，它是foreach循环的底层原理，我们可以通过iterator()来获取当前集合的迭代器

常用方法：

hasNext() ---- 判断是否迭代结束

next() ---- 迭代下一个元素

remove() ---- 删除当前正在被迭代的元素，注意：必须先调用一次next()之后才可以调用remove()进行删除

~~~java
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object o = iterator.next();//迭代下一个元素
            System.out.println(o);
            iterator.remove();
        }
~~~

## Set

是个接口，里面存放的元素是无序的，不可重复的

常用方法：

add(对象) ---- 添加元素

~~~java
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(new Student("1000", "zhangsan", 12));
        set.add("hello");


        System.out.println(set.size());
        System.out.println(set);

        for (Object o : set) {
            System.out.println(o);
        }

    }
~~~

#  2023年7月17日

## Map

这是一个集合，跟List,Set不一样，它不是Collection接口下的子接口，它自己单独就是一个接口，它们里面可以存放一对一对的元素，每一对元素称为键值对，通过键可以找到值

常见的实现类：`HashMap`

`put(键,值)` ---- 往Map中添加一个键值对

注意：键不能重复，否则会覆盖map中键值对

~~~java
        Map map = new HashMap();
        map.put("1","One");
        map.put("2","Two");
        map.put("3","Three");
        map.put("1","hello");
        System.out.println(map);//{1=hello, 2=Two, 3=Three}
~~~

`get()` ---- 根据键获取对应的值 ，返回类型为Object

`containsKey(键)` ---- 判断当前集合中是否包含传入的键

`containsValue(值) `---- 判断当前集合中是否包含传入的值

~~~java
        Object o = map.get("1");
        System.out.println(o);
        System.out.println(map.containsKey("1"));//true
        System.out.println(map.containsValue("One"));//false
~~~

Map接口下的实现类除了`HashMap`还有`HashTable`，区别在于：

`HashMap`非线程同步，效率高，可以使用null作为键

`Hashtable`线程同步，效率低，不能使用null作为键

## 自动装箱、拆箱（打包、解包）

在Java中，当我们需要一个基本数据类型包装类对象时，直接传入一个基本数据类型数值即可，它会自动打包，又叫自动装箱。调用Integer.valueOf()，如：`Integer i = Integer.valueOf(1);`

当我们需要一个基本数据类型时，直接传入一个包装类即可，会自动解包，又叫自动拆箱，调用XxxValue，如：`int i = (new Integer(1)).intValue();`

## Collections

这是Collection集合的帮助类，它提供了各种静态方法对我们的集合进行操作，例如：

sort() ---- 对一个List进行大小排序

~~~Java
        List list = new ArrayList();
        list.add(100);
        list.add(32);
        list.add(53);
        list.add(5);
        list.add(13);
        list.add(87);
        list.add(6);
        list.add(99);
        System.out.println(list);//[100, 32, 53, 5, 13, 87, 6, 99]

        Collections.sort(list);
        System.out.println(list);//[5, 6, 13, 32, 53, 87, 99, 100]
~~~

## 泛型

集合对象在定义的时候，可以使用泛型来限定它里面对象的数据类型,使用<>表示其泛型的类型

格式：

~~~java
集合接口<泛型> 变量名 = new 集合类<>();
~~~

~~~java
        List<String> list = new ArrayList<>();
        list.add("hello");
        list.add(100);//编译报错
~~~

~~~java
        Map<String,Integer> map = new HashMap<>();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
~~~

~~~java
        List<Map<String,String>> list = new ArrayList<>();
        for(int i = 0;i < 10;i++){
            Map<String,String> map = new Hashtable<>();
            for(int j = 0;j < 10;j++){
                map.put("key:" + i + j,"value:" + i + j);
            }
            list.add(map);
        }

        System.out.println(list);
~~~

~~~java
        Map<String,String> map1 = new Hashtable<>();
        map1.put("sno","1001");
        map1.put("sname","1001");
        map1.put("sage","1001");
        Map<String,String> map2 = new Hashtable<>();
        map2.put("sno","1002");
        map2.put("sname","1002");
        map2.put("sage","1002");
        List<Map<String,String>> list = new ArrayList<>();
        list.add(map1);
        list.add(map2);
        for(Map<String,String> m : list){
            System.out.println(m);
        }
~~~

### 自定义泛型类

用户在使用该类的时候，指定泛型类型

~~~java
class 类名<泛型标识>{
    泛型标识 变量名;
    ...
}
~~~

~~~java
public class Generic<E> {
    private E name;


    @Override
    public String toString() {
        return "Generic{" +
                "name=" + name +
                '}';
    }

    public Generic() {

    }

    public Generic(E name) {
        this.name = name;
    }

    public E getName() {
        return name;
    }

    public void setName(E name) {
        this.name = name;
    }
}

//测试
    public static void main(String[] args) {
        Generic<String> generic = new Generic<>("hello");
        System.out.println(generic);

        Generic<Integer> generic1 = new Generic<>(122);
        System.out.println(generic1);
    }
~~~

**注意**：当使用的时候不指定泛型，那么相当于使用Object类作为泛型

**注意**：同一个类，不同泛型的对象，它们的类型还是相同的

### Random

随机数类，它的`nextXxx(上限值)`方法，可以获取某种类型，在上限值范围内的一个随机数

~~~java
    public static void main(String[] args) {
        Random random = new Random();
        int i = random.nextInt(100);//[0,100)
        System.out.println(i);
    }
~~~

~~~java
//抽奖器
public class ProductGetter<T> {

    static Random random = new Random();
    private T product;//奖品
    private List<T> list = new ArrayList<>();//奖池

    //往奖池中添加奖品

    public void addProduct(T t) {
        list.add(t);
    }

    //从奖池中抽取一个奖品
    public T getProduct() {
        this.product = this.list.get(random.nextInt(list.size()));

        return this.product;
    }

}
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();

        productGetter.addProduct("爱疯19");
        productGetter.addProduct("高木同学");
        productGetter.addProduct("日高小春");

        System.out.println(productGetter.getProduct());

        ProductGetter<Integer> productGetter1 = new ProductGetter<>();
        int[] arr1 = new int[]{1,2,3,4};
        for(int i = 0;i < arr1.length;i++){
            productGetter1.addProduct(arr1[i]);
        }
        System.out.println(productGetter1.getProduct());

    }
~~~

### 继承中的泛型

如果父类是一个泛型类，子类也是一个泛型类，那么子类在定义的时候，泛型类型必须包含父类的泛型类型

~~~java
public class ChildGeneric<E> extends Generic<E> {
    
    @Override
    public E getName(){
        return super.getName();
    }
}
~~~

如果子类不是泛型类，那么子类在定义的时候必须指明父类泛型类型

~~~java
public class ChildGeneric2 extends Generic<Integer>{
    @Override
    public Integer getName() {
        return super.getName();
    }
    
    @Override
    public void setName(Integer name){
        super.setName(name);
    }
}
~~~

### 泛型接口

定义格式：

interface 接口名<泛型标识>

1.如果实现类不是泛型类，那么实现类在定义的时候，必须指定接口的泛型类型。

2.如果实现类也是泛型类，那么实现类的泛型类型必须包含接口中的泛型类型

### 泛型方法

使用<泛型标识> 声明的方法

注意：泛型类中的方法不一定是泛型方法，一定要用<泛型标识>声明的方法才叫泛型方法

调用该方法的时候，由调用者确定泛型类型

~~~java
//在抽奖器类中添加泛型方法
    public <T> T getProduct(ArrayList<T> list){
        return list.get(random.nextInt(list.size()));
    }
//测试
    public static void main(String[] args) {
        ProductGetter<String> productGetter = new ProductGetter<>();
        ArrayList<String> list1 = new ArrayList<>();
        list1.add("高木同学");
        list1.add("日高小春");
        list1.add("古手川千纱");
        String res = productGetter.getProduct(list1);
        System.out.println(res);

        ArrayList<Integer> list2 = new ArrayList<>();
        list2.add(122);
        list2.add(4243);
        list2.add(3);
        Integer res2 = productGetter.getProduct(list2);
        System.out.println(res2);

    }

~~~

~~~java
public class ProductGetter<T> {
    public static <T,E,K> void printType1(T t,E e,K k){
        System.out.print(t + " --- " + t.getClass() + ",");
        System.out.print(e + " --- " + e.getClass() + ",");
        System.out.print(k + " --- " + k.getClass());
        System.out.println();
    }
}

    public static void main(String[] args) {
        ProductGetter.printType1("hello",100,false);
        ProductGetter.printType1(false,3.14,'a');
    }
~~~

### 可变参数的泛型方法

在泛型方法的形参中使用`泛型标识 ... 变量名` 可以声明一个方法，别人调用的时候，传入任意个数的参数

该变量接收到的是一个泛型参数的数组

~~~java
    public static <E> void printType2(E... e) {
        for (int i = 0; i < e.length; i++) {
            System.out.print(e[i] + " --- " + e[i].getClass() + ",");
        }
    }

//test
    public static void main(String[] args) {
        ProductGetter.printType2("hello", 100, false);
    }
~~~

### 泛型中的通配符

泛型没有继承性，我们可以使用`？`来定义泛型标识通配符，该泛型的类对象可以接收任何泛型的该类对象的值。

~~~java
        List<String> list = new ArrayList<>();
        List<Object> list1 = new ArrayList<>();
        List<?> list2 = new ArrayList<>();
        list1 = list;//报错
        list2 = list;

        Map<String,String> map = new HashMap<>();
        Map<String,Object> map2 = new HashMap<>();
        map2 = map;//报错
        Map<?,?> map3 = new HashMap<>();
        map3 = map;
~~~



## Maven

这是一个帮助我们下载管理jar包和构建项目的工具

`mvn -v` ---- 查看当前maven工具的版本号

中央仓库 ---- 一台搭建在国外的仓库服务器，里面保存着所有我们将使用的jar

私服仓库 ---- 本公司所能使用到的jar包，从中央仓库下载下来

阿里云的镜像仓库 ---- 这是搭建在国内的Maven镜像仓库，它每15分钟和中央仓库同步一次，保证国内程序员的下载速度

本地仓库 ---- 我们自己个人电脑上的一个文件夹，装着自己曾经下载的所有jar包

### 依赖的坐标

`groupId` ---- 公司名称

`artifactId` ---- 项目名称

`version` ---- 版本号

Maven项目之间有继承关系，在父工程下面可以包含子模块，在父工程的pom.xml中：
`<packaging>pom</packaging>`表示这是父工程
`<modules>`表示当前父工程下包含的子模块
在子模块的pom.xml中`<parent>`表示其父工程的坐标

**注意**：模块的依赖具有传递性，如果b模块依赖了a模块，那么它也会自动依赖a模块的依赖

**注意**：父工程的pom.xml中可以通过`<dependencyManagement>`来统一管理子模块的依赖版本，子模块的pom.xml中依赖的坐标版本号标签`<version>`可以省略

## `MVC`开发模型

M ---- Model ： 模型代表应用程序的数据和业务逻辑。模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。

V ---- View ：视图是用户界面的表示层，负责将数据以可视化的方式展示给用户。用户操作的前端，是用户界面的表示层，

C ---- Controller ： 控制器是模型和视图之间的桥梁，负责接收用户的输入，并根据输入更新模型和视图。Servlet连接前端和后端数据库，

## 搭建`SpringBoot`项目

1. 创建一个Maven项目
2. 在pom.xml中添加一个spring-boot-starter-parent父工程，再添加spring-boot-starter-web依赖
3. 在Java文件夹中创建一个包，包中创建启动类，该类需要添加`@SpringBootApplication`表示这时springBoot启动类
   同时添加main方法，main方法中添加`SpringApplication.run(当前类名.class, args);`
4. 在启动器类的包中添加controller包，并添加控制器类，然后在控制器类上添加`@RestController`表示这是一个控制器，在控制器中添加一个方法，返回值为String，方法上添加`@RequestMapping("/请求名")`表示接收指定的请求。方法中返回一个字符串用来在浏览器页面显示。
5. 启动main方法，并打开浏览器输入：
   `http://ip地址:端口/请求名`  完成测试

## 修改`SpringBoot`端口

在`resources`文件夹中新建一个`File`，命名为：`application.properties`
该文件中添加`server.port=新端口`
重新启动服务

# 2023年7月18日

## 面试题

ArrayList底层扩容原理：

它的底层是一个数组，长度默认为10，当调用add方法存入元素时，判断数组是否满了，如果满了，就造一个新的数组，长度是原数组的1.5倍，然后将原数组中的元素依次拷贝到新数组中，使用新数组。

~~~java
public interface List {

    void add(Object o);

    void add(int index, Object o);

    Object get(int index);

    int size();

    boolean isEmpty();

}
~~~

~~~java
public class ArrayList implements List {

    Object[] elementData;//集合底层的那个数组

    private int size;//当前集合对象中的元素个数

    public ArrayList(int count) {
        this.size = 0;
        elementData = new Object[count];
    }

    public ArrayList() {
        this.size = 0;
        elementData = new Object[4];
    }

    @Override
    public void add(Object o) {
        add(size, o);
    }

    @Override
    public void add(int index, Object o) {
        if (index < 0 || index > size) {
            throw new MyIndexOutOfBoundException("对不起数组越界");
        }
        //数组满了，需要扩容
        if (this.size == elementData.length) {
            grow();
        }
        //从指定的第index个位置开始，一次往后挪一格
        for (int i = size; i > index; i--) {
            elementData[i] = elementData[i - 1];
        }
        elementData[index] = o;
        size++;
    }

    @Override
    public Object get(int index) {
        if (index < 0 || index >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        return elementData[index];
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    private void grow() {
        //     //数组满了，需要扩容
        //     //1.造一个新数组newArray,长度是原数组的1.5倍
        //     Object[] newArray = new Object[elementData.length
        //             + (elementData.length >> 1)];//+-比移位优先级高
        //     //2.将就数组中的元素拷贝到新数组中
        //     for (int i = 0; i < elementData.length; i++) {
        //         newArray[i] = elementData[i];
        //     }
        //     //3.将就数组的引用指向新数组
        //     elementData = newArray;
        //以上代码可以通过下面一行来替代，使用Arrays帮助类中的copyOf方法
        elementData = Arrays.copyOf(elementData,
                elementData.length +
                        (elementData.length >> 1));
    }

    @Override
    public String toString() {
        String s1 = "[";

        String s2 = "]";
        if (0 == size) {
            return "[]";
        }
        StringBuffer stringBuffer = new StringBuffer("[");
        for (int i = 0; i < size - 1; i++) {
            stringBuffer.append(elementData[i] + ",");
        }

        stringBuffer.append(elementData[size - 1] + "]");
        return stringBuffer.toString();
    }
}
~~~

~~~java
public class Test8 {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(100);
        //list.add(200);
       // list.add(300);
       // list.add(3,500);
        System.out.println(list.get(0));
     //  System.out.println(list.get(1));
     //  System.out.println(list.get(2));
     //  System.out.println(list.get(3));
        System.out.println(list);
    }
}

~~~

## `SpringBoot`项目的一键部署

1. 打开`spring.io`网站，在顶端右边找到`Projects -> Spring Boot`在新页面，找到`LEARN -> 随便哪个版本的Reference.Doc -> 新页面左边蓝色字体找到Using SpringBoot -> 快捷键ctrl + F 搜索spring-boot-maven-plugin将该插件添加到pom.xml中`
2. 在Maven小窗口中的`lifeCycle`下拉菜单中双击`package`完成打包，控制台会告诉你包在什么路径
3. 使用`java -jar`命令直接启动该jar包即可，停止按`ctrl + c`

## `MySQL`数据库语法

### 分页查询

~~~sql
select 字段列表 from 表名 limit 起始条数, 每页条数;
-- for example
select * from fiction limit 6,3;
~~~

### 主键值自增长

建表语句中使用auto_increment实现，格式：

~~~plsql
create table 表名(
	字段名1 字段类型 auto_increment,
	字段名2 字段类型,
    ...
    PRIMARY KEY(主键字段)
)DEFAULT CHARSET = utf8;

-- for example
create table myuser0718(
	userid INTEGER auto_increment,
	username VARCHAR(20),
	userage INTEGER,
	PRIMARY KEY(userid)
)DEFAULT CHARSET=utf8;

~~~

### now()

当前系统时间

~~~~~plsql
select now(); -- 2023-07-18 16:55:35
~~~~~

### DATE_FORMAT(日期字段,日期格式) 

将日期型转字符串

~~~plsql
select f.fictionid,f.fictionname,DATE_FORMAT(f.createtime,'%Y-%m-%d %H:%i:%s') from fiction f;
~~~

# 2023年7月9日

## Vector

它也是List接口的实现类，它的底层是数组，Vector和ArrayList的区别：

1. Vector线程同步，效率低，ArrayList线程不同步，效率高。
2. ArrayList底层数组扩容原理是每次扩1.5倍，Vector底层数组扩容原理是根据指定的扩容量来扩容，如果没有指定扩容量，则原数组长度翻倍

## LinkedList

它也是List接口的实现类，它的底层是链表

**数组和链表的比较**：

- 数组查询快，新增删除慢
- 链表查询慢，新增删除快

#### 手写的单向链表

以下代码好像是错的，无法读取第链表中第一个数据以后再说吧//todo

~~~java
public interface List {

    public int size();

    public boolean isEmpty();

    public void add(Object o);

    public void add(int i, Object o);

    public Object get(int i);
}
~~~

~~~java
public class LinkedList implements List {

    Node head = new Node();//头节点
    int size;//当前集合中的元素个数


    public LinkedList() {
        this.size = 0;
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    @Override
    public void add(Object o) {
        this.add(size, o);
    }

    @Override
    public void add(int i, Object o) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        //找位置
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        //创建一个新节点
        Node newNode = new Node(o);
        //让新节点指向p本来指向的下一个节点
        newNode.setNext(p.next);
        //P指向新节点
        p.next = newNode;
        //元素个数加一
        this.size++;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        return p.getValue();
    }

    @Override
    public String toString() {
        StringBuffer s = new StringBuffer("[");
        Node p = head.next;
        for (int i = 0; i < size - 1; i++) {

            if (i != size - 1) {
                s.append(p.getValue() + ",");
            } else {
                s.append((p.getValue()));
            }
            p = p.next;
        }
        s.append("]");
        return s.toString();
    }
}

~~~

~~~java
public class Node {
    Object value;//当前节点的值
    Node next;//下一个节点

    public Node(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node() {
    }

    public Node(Object value, Node next) {
        this.value = value;
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", next=" + next +
                '}';
    }
}

~~~

~~~java
public class MyIndexOutOfBoundException extends RuntimeException {

    public MyIndexOutOfBoundException() {

    }

    public MyIndexOutOfBoundException(String message) {
        super(message);
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {

        List list = new LinkedList();
//        list.add(100);
//        list.add(200);
//        list.add(300);
//        list.add(400);
//        list.add(500);

        System.out.println(list);

    }
~~~



### java.util包中的LinkedList

它使用双向链表来实现

# 2023年7月20日

## 栈

这是一个容器，它的存取数据操作时是受限的。特点：先进先出，后进后出

栈的操作：

push ---- 入栈

pop ----  出栈

peek ---- 获取栈顶元素，但不出栈

## 队列

是个容器，存储数据操作时受限
特点：先进先出，后进后出，入队要从队尾入队，出队要从队首出队

队列的操作：

enqueue ---- 入队

dequeue ---- 出队

peek ---- 获取队首元素

## 双端队列

这也是一个容器，它的队尾和队首分别都可以入队和出队操作

- 如果把某一端限定了不能入队出队，则变成了一个栈
- 如果对某一段限定了只能入队，另一端只能出队，则变成了普通队列

在Java中，我们使用Deque表示一个双端队列，LinkedList是Deque的实现类，所以我们可以使用LinkedList表示一个双端队列，Deque接口是Queue接口的子接口，Queue表示队列

~~~java
//10进制转2进制
        System.out.println("请输入一个10进制整数：");
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        //String str = "";
        Deque deque = new LinkedList();
        do {
            int mod = n % 2;
            //str = mod + str;
            deque.push(mod);
            //System.out.println(mod);
            n /= 2;
        } while (n > 0);
        sc.close();
        while (!deque.isEmpty()) {
            System.out.print(deque.pop());
        }
~~~

## 树

这是一个集合，是一种在层级关系上定义的集合。一棵普通的树，根节点只有一个，往下有子节点，子节点往下还有子节点

节点的度：某个节点拥有子树的数目称为节点的度

树的度：一棵树中节点的度的最大值

叶子节点：度为0的节点

节点的层次：从当前节点开始是第一层，其子树是第二层，直到最深的叶子节点的层数

- `层次`: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1.

树的深度：树中节点的最大层次

节点之间的关系：父亲，儿子，兄弟，堂兄弟

有序树：如果将树中的各个子树看成从左至右是有次序的，则称为有序树，如果不考虑顺序，则是无序树

m叉树：一棵树的任意一个节点，往下最多有几个分支就是几叉树。

森林：若干个互不相交的树的集合

二叉树：每个节点的度均不超过2的有序树

满二叉树：每一层的节点数都要达到最大数（除了叶子节点）的二叉树

完全二叉树：在满二叉树的基础上，最下层，从最右侧起，去掉若干相邻的子节点得到的二叉树

二叉树的性质：终端节点的数量 = 度为2的节点数量 + 1

二叉树的遍历：

- 先序：根左右（先遍历根节点，然后遍历左子树，最后遍历右子树）
- 中序：左根右
- 后序：左右根

### 例题：

已知：
中序： 4 5 1 3 2 6 7
后序： 5 4 3 7 6 2 1
求先序：
思路步骤：

1. 看后序，得到1是根
2. 看中序，得到45是左孩子，3267是右孩子
3. 看后序，得到4是1的左孩子

先序：1 4 5....

4. 看中序，得到5是4的右孩子
5. 看后序，得到2是1的右孩子

先序：1 4 5 2 ....

6. 看中序，得到3是2的左孩子，67是2的右孩子

先序：1 4 5 2 3 ...

7. 看后序，得到6是7的根节点，所以6是2的右孩子

先序：1 4 5 2 3 6 7

8. 看中序，得到7是6的右孩子

### 面试题

二叉树的遍历：给出中序，先序后序给一个求另一个，

解题思路：先看先序或者后序，得到根，再看中序，得到根的左孩子或右孩子，再依次轮换着看先序或者后序和中序，然后画出实际的二叉树

### 手写二叉树

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689918641/javaStudy/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E4%BE%8B_lnreur.png](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689918641/javaStudy/二叉树示例_lnreur.png)

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:23
 * @email 1208195222@qq.com
 * @description 二叉树的接口
 */
public interface BinaryTree {

    //判断是否是空树
    public boolean isEmpty();

    //求节点数量
    public int size();

    //获取二叉树的高度
    public int getHeight();

    //查询指定的节点
    public Node findKey(Object value);

    //先序遍历
    public void preOrderTraverse();

    //中序遍历
    public void inOrderTraverse();

    //非递归的中序遍历
    public void inOrderTraverseByStack();

    //后序遍历
    public void postOrderTraverse();

    //从指定的某个节点开始进行先序遍历
    public void preOrderTraverse(Node node);

    //从指定的某个节点开始进行中序遍历
    public void inOrderTraverse(Node node);

    //从指定的某个节点开始进行后序遍历
    public void postOrderTraverse(Node node);

    //按照层次遍历
    public void levelOrderByStack();
}
~~~

~~~java
package com.iweb.test;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Queue;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:28
 * @email 1208195222@qq.com
 * @description	二叉树接口的实现类
 */
public class LinkedBinaryTree implements BinaryTree {
    Node root;

    @Override
    public String toString() {
        return "LinkedBinaryTree{" +
                "root=" + root +
                '}';
    }


    public LinkedBinaryTree() {
    }

    public LinkedBinaryTree(Node root) {
        this.root = root;
    }

    @Override
    public boolean isEmpty() {
        return this.root == null;
    }

    @Override
    public int size() {
        return this.size(root);
    }

    public int size(Node node) {
        if (node == null) {
            return 0;
        } else {
            int leftSize = this.size(node.leftChild);
            int rightSize = this.size(node.rightChild);
            return leftSize + rightSize + 1;
        }
    }

    @Override
    public int getHeight() {
        return this.getHeight(root);

    }

    public int getHeight(Node node) {
        if (node == null) {
            return 0;
        } else {
            int leftHeight = this.getHeight(node.leftChild);
            int rightHeight = this.getHeight(node.rightChild);
            return leftHeight > rightHeight ? (leftHeight + 1) : (rightHeight + 1);
        }

    }

    @Override
    public Node findKey(Object value) {
        return this.findKey(value, root);
    }

    public Node findKey(Object value, Node node) {
        if (node == null) {
            return null;
        } else if (node.value == value) {
            return node;
        } else {
            Node node1 = this.findKey(value, node.leftChild);
            Node node2 = this.findKey(value, node.rightChild);
            if (node1 != null && node1.value == value) {
                return node1;
            } else if (node2 != null && node2.value == value) {
                return node2;
            }
            return null;
        }
    }

    @Override
    public void preOrderTraverse() {
        this.preOrderTraverse(root);
    }

    @Override
    public void preOrderTraverse(Node node) {
        if (node != null) {
            System.out.print(node.value + " ");
            this.preOrderTraverse(node.leftChild);
            this.preOrderTraverse(node.rightChild);
        }

    }

    @Override
    public void inOrderTraverse() {
        this.inOrderTraverse(root);
    }

    @Override
    public void inOrderTraverseByStack() {
        System.out.println("非递归的中序遍历");
        //创建栈
        Deque<Node> stack = new LinkedList<>();
        Node current = root;
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.isEmpty()) {
                current = stack.pop();
                System.out.print(current.value + " ");
                current = current.rightChild;
            }
        }
    }

    @Override
    public void inOrderTraverse(Node node) {
        if (node != null) {
            this.inOrderTraverse(node.leftChild);
            System.out.print(node.value + " ");
            this.inOrderTraverse(node.rightChild);
        }

    }

    @Override
    public void postOrderTraverse() {
        this.postOrderTraverse(root);
    }

    @Override
    public void postOrderTraverse(Node node) {
        if (node != null) {
            this.postOrderTraverse(node.leftChild);
            this.postOrderTraverse(node.rightChild);
            System.out.print(node.value + " ");
        }

    }

    @Override
    public void levelOrderByStack() {
        System.out.println("按照层次遍历二叉树");
        if (root == null) {
            return;
        } else {
            Queue<Node> queue = new LinkedList<>();
            queue.add(root);
            while (queue.size() != 0) {
                int len = queue.size();
                for (int i = 0; i < len; i++) {
                    Node temp = queue.poll();
                    System.out.print(temp.value + " ");
                    if (temp.leftChild != null) {
                        queue.add(temp.leftChild);
                    }
                    if (temp.rightChild != null) {
                        queue.add(temp.rightChild);
                    }
                }
            }
        }
    }
}

~~~



~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:21
 * @email 1208195222@qq.com
 * @description     节点类
 */
public class Node {

    Object value;//自己的值
    Node leftChild;//左孩子地址
    Node rightChild;


    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", leftChild=" + leftChild +
                ", rightChild=" + rightChild +
                '}';
    }

    public Node() {
    }

    public Node(Object value, Node leftChild, Node rightChild) {
        this.value = value;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/21 9:01
 * @email 1208195222@qq.com
 * @description		测试lei
 */
public class Test2 {

    public static void main(String[] args) {
        Node node5 = new Node(5, null, null);
        Node node4 = new Node(4, null, node5);

        Node node7 = new Node(7, null, null);
        Node node6 = new Node(6, null, node7);

        Node node3 = new Node(3, null, null);
        Node node2 = new Node(2, node3, node6);

        Node node1 = new Node(1, node4, node2);

        LinkedBinaryTree lbt = new LinkedBinaryTree(node1);

        System.out.println(lbt);
        System.out.println(lbt.isEmpty());
        LinkedBinaryTree lbt2 = new LinkedBinaryTree();
        System.out.println(lbt2.isEmpty());

        System.out.println("先序遍历：");
        lbt.preOrderTraverse();
        System.out.println();
        System.out.println("中序遍历：");
        lbt.inOrderTraverse();
        System.out.println();
        System.out.println("后序遍历：");
        lbt.postOrderTraverse();
        System.out.println();
        System.out.println("树的深度：");
        System.out.println("height:" + lbt.getHeight());
        System.out.println("节点的个数：");
        System.out.print(lbt.size());
        System.out.println();
        System.out.println("在二叉树中查找");
        System.out.println(lbt.findKey(1));
        System.out.println();
        System.out.println("层次遍历：");
        lbt.levelOrderByStack();
        System.out.println();
        System.out.println("中序非递归遍历");
        lbt.inOrderTraverseByStack();

    }
}
~~~





## 递归算法

在一个方法的内部调用当前方法本身，它可以将一个复杂的问题层层转化为一个个相似的小问题来求解，**注意**：在写递归的时候必须要有结束调用的条件，否则就会出现栈内存溢出的错误。

~~~java
//求1加到100
    public static void main(String[] args) {

        System.out.println(myMethod(1));
    }

    public static int myMethod(int i) {
        int sum = 0;
        if (1 == i)
            return 1;
        else
            sum = i + myMethod(i - 1);
        return sum;

    }
//用高斯公式
    public static void main(String[] args) {
        System.out.println((1 + 100) * 100 / 2);
    }
~~~

## druid配置信息

写在application.propertie

~~~properties
server.port=8088

spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.url=jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8
spring.datasource.username=root
spring.datasource.password=123456
~~~

MySQL的URL要背下来：`jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8`

## SpringBoot常用注解

@RestController ---- 这实际上包含了@ResponseBody 和 @Controller两个注解

@ResponseBody ---- 表示返回的数据直接以Json格式的字符串来表示

@Controller ---- 表示这是一个控制器，它能够接收请求，并且由Spring自动创建该类对象

@RequestMapping ---- 表示定义一个请求名，当接收到该请求名的请求时，触发代码执行

@Autowired ---- 需要使用某个对象的时候，无需自己创建，由Spring容器直接推送

@Service ---- 表示这是一个业务逻辑主键，也可以由Spring自动创建该类对象

@Mapper ---- 这是一个MyBatis注解，它可以自动创建该接口的实现类并创建实现类对象，然后自动调用对应的方法去执行对应的SQL语句

@RequestParam ---- 接收请求参数并赋值该控制器方法的形参

@ModelAttribute ---- 将请求参数中的参数值赋给控制器方法形参对象的成员变量，并将该形参对象绑定到Model中

@GetMapping ---- 在控制器方法上接收get请求：用于查询

@PostMaping ---- 在控制器方法上接收Post请求：用于新增

@PutMapping ---- 在控制器方法上接收Put请求：用于修改

@DeleteMapping ---- 在控制器方法上接收Delete请求：用于删除

@CrossOrigin ---- 当前后端运行在不同域名下的时，用于解决跨域资源共享问题。



在地址栏按回车键，发送的是get请求

#  2023年7月22日

**程序** ---- 用编程语言编写的计算机指令的集合，即代码

**进程** ---- 运行中的程序

**线程** ---- 进程中的一条执行路径

**多线程** ---- 多条执行路径同时执行

## Java中创建多线程的两种方式

1. 继承Thread类，并重写run方法，然后由该类对象调用start()方法启动一个新的线程来执行run方法中的代码

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是run方法，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main方法，我执行到了： " + i);
        }
    }
}
~~~

2.实现Runnable接口并重写run方法，然后创建该类对象当作参数传入Thread构造方法来创建Thread对象，并由Thread对象调用start方法，启动一个新的线程来执行run方法中的代码

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是MyRunnable类的方法，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
        }
    }
}
~~~

第二种方式比较好，因为Java是单继承多实现，所以我们应该尽可能将继承的机会留给业务逻辑

### 线程的状态：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689989834/javaStudy/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81_xxgpwz.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689989834/javaStudy/线程的五种状态_xxgpwz.jpg)

1. 使用new Thread() 对象创建线程
2. 调用start方法来使线程进入就绪状态
3. 通过`cpu`调度使线程在就绪和运行状态间切换
4. 运行过程中如果发生了突发事件，例如Scanner类的等待输入，线程进入阻塞状态
5. 突发事件结束，线程回到就绪状态
6. 运行过程中，代码运行结束则进入终止状态

### 常用方法

`Thread.sleep(毫秒数)` ---- 使当前线程休眠指定毫秒数的时间

`interrupt()` ---- 中断该线程，使其处于终止状态

~~~java
public class TestSleep implements Runnable {

    @Override
    public void run() {
        while (true) {
            System.out.println("===========" + new Date() + "===========");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("TestSleep线程终止");
                return;
            }
        }
    }
}

~~~

~~~java
public class Test2 {

    public static void main(String[] args) {
        TestSleep testSleep = new TestSleep();
        Thread thread = new Thread(testSleep);
        thread.start();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();

    }
}

~~~

`join()` ---- 使该线程合并到当前线程中，等待该线程执行结束，才继续执行当前线程，相当于单线程

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
        }
    }
}
~~~

`yield()` ---- 在运行过程中让出`cpu`资源，让自己处于就绪状态

`setName(名字)` ---- 给当前线程设置名字

`currentThread()` ---- 获取当前线程对象

`currentThread().getName()` ---- 获取当前线程的名字

~~~java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 200; i++) {
            if(i%10 == 0){
                Thread.yield();
            }
            System.out.println("我是" +Thread.currentThread().getName() + "，我执行到了： " + i);
        }
    }
}
~~~

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        thread.setName("t1");

        for (int i = 1; i <= 200; i++) {
            System.out.println("我是main，我执行到： " + i);
            if (i % 10 == 0) {
                Thread.yield();
            }
        }
    }
}
~~~

`setPriority(级别)` ---- 设置线程优先级 

`getPriority()` ---- 获取线程优先级

注意：线程的优先级最高10，最低1，默认5

## 线程同步

当多个线程对同一个对象操作的时候，保证该对象数据一致性的一种机制叫做线程同步

线程不同步的例子：

~~~java
public class Time {
    static int count = 0;

    public void f(String str) {
        count++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(str + "你好，你是第 " + count + "个访问该对象的线程");
    }
}

~~~

~~~java
public class TestSync implements Runnable {
    Time time;

    public TestSync() {
        time = new Time();
    }

    @Override
    public void run() {
        time.f(Thread.currentThread().getName());
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {
        TestSync ts = new TestSync();

        Thread thread1 = new Thread(ts);
        Thread thread2 = new Thread(ts);

        thread1.setName("t1");
        thread2.setName("t2");

        thread1.start();
        thread2.start();
    }
}

~~~

输出结果：

~~~java
t2你好，你是第 2个访问该对象的线程
t1你好，你是第 2个访问该对象的线程
~~~

## synchronized

锁

1. 添加在方法声明处，表示当前对象在调用该方法时，锁定当前对象。某个线程在该对象上访问此方法时，其他线程无法在该对象上访问此方法。

~~~java
    public synchronized void f(String str) {
        count++;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
~~~

2. 在某段代码上使用`synchronized(对象){}` 来控制这一段代码在被执行的过程中线程同步

~~~java
    public void f(String str) {
        synchronized (this) {
            count++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(str + "你好，你是第 " + count + "个访问该对象的线程");
        }
    }
~~~

## 死锁

多个线程互相锁定着对方需要锁定的对象，导致都无法往下执行

例如：

~~~java
//简单来说，就是先锁定对象o1，然后睡觉，准备睡醒了锁o2,但是睡觉时o2被人锁了
public class TestDeadLock implements Runnable {

    private int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public int getFlag() {
        return flag;
    }

    public void setFlag(int flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag == 1) {
            synchronized (o1) {
                System.out.println("我是flag1，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                synchronized (o2) {
                    System.out.println("我是flag1，我结束工作了");
                }
            }
        } else {
            synchronized (o2) {
                System.out.println("我是flag2，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("我是flag2，我结束工作了");
                }
            }
        }
    }
}

~~~

~~~java
public class Test {


    public static void main(String[] args) {
        TestDeadLock testDeadLock1 = new TestDeadLock();
        TestDeadLock testDeadLock2 = new TestDeadLock();

        testDeadLock1.setFlag(1);
        testDeadLock2.setFlag(2);

        Thread thread1 = new Thread(testDeadLock1);
        Thread thread2 = new Thread(testDeadLock2);

        thread1.start();
        thread2.start();
    }
}

~~~

**注意**：避免死锁的一个有效方式：将加锁的粒度加粗

~~~java
package com.iweb.test3;

/**
 * @author 童 淏
 * @createTime 2023/07/22 11:53
 * @email 1208195222@qq.com
 * @description
 */
public class TestDeadLock implements Runnable {

    private int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();


    public int getFlag() {
        return flag;
    }

    public void setFlag(int flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag == 1) {
            synchronized (this) {
                System.out.println("我是flag1，我开始工作了");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("我是flag1，我结束工作了");
            }
        } else {
            synchronized (this) {
                System.out.println("我是flag2，我开始工作了");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("我是flag2，我结束工作了");
            }
        }
    }
}

~~~

~~~java
package com.iweb.test3;

/**
 * @author 童 淏
 * @createTime 2023/07/22 11:54
 * @email 1208195222@qq.com
 * @description
 */
public class Test {


    public static void main(String[] args) {
        TestDeadLock testDeadLock1 = new TestDeadLock();
        testDeadLock1.setFlag(1);
        Thread thread1 = new Thread(testDeadLock1);
        thread1.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        testDeadLock1.setFlag(2);
        Thread thread2 = new Thread(testDeadLock1);
        thread2.start();
    }
}

~~~

**注意**：当某个线程访问了某个对象上某个加锁的方法时，其他线程完全可以访问该对象上其他没有加锁的方法。

~~~java
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("m1方法结束了");
    }

    public void m2() {
        System.out.println("我是m2方法");
        System.out.println(i);
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}

~~~

**注意**：没有加锁的方法会对当前对象上其他加锁的方法产生影响

~~~java
package com.iweb.test4;

/**
 * @author 童 淏
 * @createTime 2023/07/24 9:30
 * @email 1208195222@qq.com
 * @description
 */
public class T implements Runnable {

    private int i = 0;

    public synchronized void m1() {
        i = 1;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
        System.out.println("m1方法结束了");
    }

    public void m2() {
        System.out.println("我是m2方法");
        i = 12312;
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}
//打印的i值为12312
~~~

**注意**：多个加锁的方法在同一个对象的操作上互斥

~~~java
package com.iweb.test4;

/**
 * @author 童 淏
 * @createTime 2023/07/24 9:30
 * @email 1208195222@qq.com
 * @description
 */
public class T implements Runnable {

    private int i = 100;

    public synchronized void m1() {
        i = 1000;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(i);
        System.out.println("m1方法结束了");
    }

    public synchronized void m2() {
        System.out.println("我是m2方法");
        i = 2000;
    }


    @Override
    public void run() {
        m1();
    }

    public static void main(String[] args) {
        T t = new T();
        Thread thread = new Thread(t);
        thread.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t.m2();
    }
}
//m2会等待m1执行完后才开始执行
~~~

**总结**：在一个多线程的项目上，增删改的方法需要加锁，查询的方法不需要加锁

# 2023年7月24日

## Object类中提供的一些线程相关的方法

`wait()` ---- 等待，使当前线程阻塞

`notify()` ---- 唤醒当前对象上某个wait中的线程

`notifyAll()` ---- 唤醒当前对象上所有wait中的线程

## wait()和sleep()的区别

1. wait()在Object类，它往往等待别的线程调用notify()才能被唤醒
   sleep()在Thread类，它往往等待自己睡眠时间到了而被自动唤醒
2. 当某个线程处于sleep状态下，依然保留线程锁
   当某个线程处于wait状态下，会释放线程锁

## 生产者消费者（不是很重要）

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 10:44
 * @email 1208195222@qq.com
 * @description
 */
public class ManTou {

    private int id;

    @Override
    public String toString() {
        return "ManTou{" +
                "id=" + id +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public ManTou() {
    }

    public ManTou(int id) {
        this.id = id;
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 10:45
 * @email 1208195222@qq.com
 * @description
 */
public class ManTouStack {


    ManTou[] arrs = new ManTou[6];//馒头框

    int size;//当前框中的馒头数

    //往框中扔一个馒头
    public synchronized void push(ManTou mt) {
        while (size == arrs.length) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        arrs[size] = mt;
        size++;
        System.out.println("生产了:           " + mt);
    }

    //从框中拿一个馒头
    public synchronized ManTou pop() {
        while (size == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        notify();
        size--;
        System.out.println("消费了：" + arrs[size]);
        return arrs[size];
    }
}




~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:15
 * @email 1208195222@qq.com
 * @description
 */
public class Producer implements Runnable {

    ManTouStack mts = null;

    public Producer(ManTouStack mts) {
        this.mts = mts;
    }

    public Producer() {
    }


    //生产
    @Override
    public void run() {
        for (int i = 0; i <= 20; i++) {
            ManTou manTou = new ManTou(i);
            mts.push(manTou);
            try {
                Thread.sleep((long) (Math.random()) * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }


        }
    }


}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:18
 * @email 1208195222@qq.com
 * @description
 */
public class Consumer implements Runnable {

    ManTouStack mts = null;

    public Consumer() {
    }

    public Consumer(ManTouStack mts) {
        this.mts = mts;
    }


    //消费
    @Override
    public void run() {
        for (int i = 0; i <= 20; i++) {
            ManTou mt = mts.pop();
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/24 11:20
 * @email 1208195222@qq.com
 * @description
 */
public class Test {

    public static void main(String[] args) {
        ManTouStack mts = new ManTouStack();

        Producer p1 = new Producer(mts);
        Consumer c1 = new Consumer(mts);

        new Thread(p1).start();
        new Thread(c1).start();
    }
}

~~~

## `vue`

这是一个渐进式的前端框架

## 创建`vue`项目

`vue create 项目名`

## 启动`vue`项目

`cd 项目文件夹`

`npm run serve`

## 停止项目

`ctrl + c`

## `elementUI`

这是一个基于`vue`的网站快速生成工具

在`vue`项目中添加`elementUI`：

`vue add element`

## `Axios`

这是一个发送请求到后端的连接工具，是一个独立的JavaScript库

安装`Axios`：

`cnpm install axios --save`

## `<router-link to="">`

这是`vue`中的页面跳转，to属性表示目标url

我们需要在`index.js`中配置跳转的url信息，对应to属性

## 嵌套路由

在某个主键中添加容器，路由器由children属性指向子页面，那么点击跳转的时候，子页面内容将被加载到容器中，而不是直接跳转。

## 内部样式表：

在当前页面上编写`css`代码，它的作用范围就是当前页面

## 外部样式表：

单独编写`css`文件，里面写`css`代码，在需要的页面上使用`@import url("css文件路径") `将其导入

## 全局样式表：

只需要在`index.html`的`<head>`中添加`<link rel="stylesheet" type="text/css" href="css文件路径"/>`即可实现全局样式，任何组件中都无序单独导入。

## 组件生命周期相关方法 

~~~javascript
		beforeCreate() {
			console.log("该组件即将创建");
		},
		created() {
			console.log("该组件创建完成");
		},
		beforeMount() {
			console.log("该组件即将渲染");
		},
		mounted() {
			console.log("该组件渲染完成");
		},
		beforeUpdate() {
			console.log("该组件即将被修改");
		},
		updated() {
			console.log("该组件修改完成");
		},
		beforeDestroy() {
			console.log("该组件即将被删除");
		},
		destroyed() {
			console.log("该组件删除完成");
		}
~~~

# 2023年7月25日

## 流

**流**就像一根根管道，管道的一端连接着当前计算机的CPU，另外一端连接着目标资源

数据就像管道中的水，从一个地方流到另外一个地方。

**IO** ---- input/output

流的分类：

1. 按照输入输出方向分为：输入流和输出流
   **面试题**
   写文件是输出
   读文件是输入
   （站在计算机角度看，对外部世界发送数据就是输出）
2. 按照数据传输的单位分为：字节流和字符流
3. 按照功能分为：节点流和处理流

流的Java类

`InputStream` ---- 字节输入流

`OutputStream` ---- 字节输出流

`Reader` ---- 字符输入流

`Writer` ---- 字符输出流

注意：所有的流都是继承自以上4个抽象类之一

`FileInputStream` ---- 文件字节输入流，用来读文件
read() ---- 读取文件中的一个字节，返回一个int值，如果读到末尾，则返回-1
close() ---- 关闭该输入流
`File.separator` ---- 当前操作系统的文件分隔符，在`windows`下是`\`，在`Linux`下是`/`

注意：实际开发的过程中，可以一律使用`/`，因为windows会自动将其转成`\`

~~~java
public class Test {

    public static void main(String[] args) {
        InputStream is = null;
        String path = File.separator;
        try {
            is = new FileInputStream("D:" + path + "java" + path + "MyProject" + path + "test20230725" + path + "src" + path + "com" + path + "iweb" + path + "test" + path + "Test.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

`FileOutputStream` ---- 文件字节输出流，用来写文件
write() ---- 往文件中写一个字节
close() ---- 关闭该输出流

~~~java
public class Test2 {

    public static void main(String[] args) {
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new FileInputStream("D:/java/MyProject/test20230725/src/com/iweb/test/Test.java");
            os = new FileOutputStream("D:/Desktop/Test2.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                os.write(i);
            }
            System.out.println("复制成功！");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null)
                    is.close();
                if (os != null)
                    os.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
//天下一番
~~~

`FileReader` ---- 文件字符输入流，用来读文件
read() ---- 读取文件中的一个字符，返回一个int值，如果读到末尾，则返回-1
close() ---- 关闭该输入流

~~~java
public class Test3 {

    public static void main(String[] args) {
        Reader reader = null;
        String path = File.separator;
        try {
            reader = new FileReader("D:" + path + "java" + path + "MyProject" + path + "test20230725" + path + "src" + path + "com" + path + "iweb" + path + "test" + path + "Test3.java");
            int i = 0;
            while ((i = reader.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null)
                    reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
//天下一番
~~~

`FileWriter` ---- 文件字符输出流，用来写文件
write() ---- 往文件中写一个字符
close() ---- 关闭该输出流

~~~java
public class Test4 {
    public static void main(String[] args) {
        Writer fw = null;
        try {
            fw = new FileWriter("D:/desktop/myunicode.txt");

            for (int i = 1; i < 50000; i++) {
                fw.write(i);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fw != null) {
                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

~~~

### 缓冲流

在内存开辟一块`8k`大小的缓冲区，当我们第一次读文件的时候，一次性读`8k`的内容到缓冲区，然后从缓冲区拿一个字节或字符进行使用，当缓冲区数据用完，才会再次访问硬盘读取`8k`数据，如此反复，极大地减少了对硬盘的访问次数，有效保护硬盘，并提高效率。

`BufferedInputStream `---- 字节缓冲输入流

~~~java
public class Test5 {

    public static void main(String[] args) {
        InputStream is = null;
        BufferedInputStream bis = null;
        String path = File.separator;
        try {
            is = new FileInputStream("D:" + path + "java" + path + "MyProject" + path +
                    "test20230725" + path + "src" + path + "com" + path +
                    "iweb" + path + "test" + path + "Test5.java");
            bis = new BufferedInputStream(is);
            int i = 0;
            while ((i = bis.read()) != -1) {
                System.out.print((char) i);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bis != null)
                    bis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

`BufferedReader` ---- 字符缓冲输入流

`readLine()` ---- 可以读取一行的内容到一个字符串中

`BufferedWriter `---- 字符缓冲输出流

`write() `---- 写入一个字符串到缓冲区，如果缓冲区满了，自动写入硬盘

`newLine() `---- 另起一行

`flush()` ---- 清空缓冲区的内容并将其存入硬盘

~~~java
public class Test6 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = null;
        BufferedWriter bw = null;

        try {
            bw = new BufferedWriter(new FileWriter("D:/desktop/hello.txt"));
            br = new BufferedReader(new FileReader("D:/desktop/hello.txt"));
            for (int i = 0; i < 100; i++) {
                bw.write(String.valueOf(Math.random()));
                bw.newLine();
            }
            bw.flush();
            String s = null;
            while ((s = br.readLine()) != null) {
                System.out.println(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (br != null)
                    br.close();
                if (bw != null)
                    bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

## `Axios`发送请求

### `@CrossOrigin`

控制器类添加该注解可以解决前后端分离项目存在的跨域问题

get请求 ----` this.$axios.get(url)`

post请求 ----` this.$axios.post(url,参数的json字符串)`

我们使用`querystring`对象调用`stringify(json参数)`可以将json参数转json字符串

~~~js
		mounted() {
			console.log("该组件渲染完成");
            //查询全部
			this.$axios.get('http://127.0.0.1:8088/book/queryAll')
				.then(function(response) {
					console.log(response);
				})
				.catch(function(error) {
					console.log(error);
				});
            //新增一条
			this.$axios.post('http://localhost:8088/book', qs.stringify({
					bookname: '昆虫记',
					author: '法布尔'
				}))
				.then(function(response) {
					console.log(response)
				})
				.catch(function(error) {
					console.log(error)
				});


			//修改一条
			this.$axios.put('http://localhost:8088/book', qs.stringify({
					id: '1036',
					bookname: '晚明',
					author: '柯山梦'
				}))
				.then(function(response) {
					console.log(response)
				})
				.catch(function(error) {
					console.log(error)
				});
			//删除一条
			this.$axios.delete('http://localhost:8088/book/1037')
				.then(function(response) {
					console.log(response);
				})
				.catch(function(error) {
					console.log(error);
				});
		}
~~~

`SpringMVC`中的`@PathVariable`注解

可以绑定url中的占位符到方法形参，占位符需要使用一对大括号包起来

## 全局url配置

在`main.js`中添加`Axios.defaults.baseURL = 'http://ip地址:端口'`

每个发请求的地方直接从`"/"`开始写url即可，`"/"`表示web站点根目录

## 拦截器

我们在`Axios`中可以添加拦截器拦截所有的请求，来处理请求中的数据

格式：

~~~js
//main.js中添加：
Axios.interceptors.request.use(function (config){

......

})
~~~

`config.method ` ---- 表示请求方法

`config.data `---- 表示请求参数

`js`中 == 和 === 区别：
`js`中==只会比较数值是否相等，不考虑类型
===不仅要求数值相等，而且类型必须一样

## `<button>` ---- 按钮

`<button v-on:click="方法名">`  调用一个`js`方法

alert(字符串); ---- 弹出一个对话框，展示相应字符串

## 2023年7月26日

## `PrintWriter`

打印流

可以打印日志文件，它提供了各种重载的`print()`和`println()`方法用于打印，它只有输出没有输入，它不会抛异常

它自带缓冲区，他需要调用close()进行关闭

## `InputStreamReader`

这是一个字节流转字符流的桥梁，当传入一个字节流时，会返回对应的字符流。

~~~java
public class Test {

    public static void main(String[] args) {
        PrintWriter pw = null;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        try {
            pw = new PrintWriter(new FileWriter("D:/desktop/log.txt", true));
            String s = null;
            while ((s = br.readLine()) != null) {
                if ("exit".equals(s))
                    break;

                System.out.println(s);
                pw.println(s);
                pw.println("====================");
            }

            pw.println("================" + new Date() + "================");
            pw.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (pw != null)
                pw.close();

        }

    }
}
~~~

## UTF-8

这是一种编码格式 ---- 可变长度的Unicode编码

## Socket

套接字

这是客户端的插座，它可以获取连接服务器的输入输出流

它允许计算机之间通过网络进行数据交换和通信

## `ServerSocket`

这是服务器端的插座，它可以接收来自客户端的请求，

accept() ---- 这是一个阻塞的方法，他可以等待并获取来自某个客户端的Socket对象，然后获取该客户端的输入输出流

服务器必须先启动，然后等待，由客户端主动发送请求，客户端在`OutputStream`中写入数据，服务器在`InputStream`中接收数据

`DataInputStream和DataOutputStream`

数据流

它可以在网络上进行`UTF-8`数据格式的传输

简单客户端服务器：

~~~java
//服务器
public class MyServer {
    public static void main(String[] args) {
        ServerSocket serverSocket = null;
        DataInputStream dataInputStream = null;
        Socket socket = null;

        DataOutputStream dataOutputStream = null;

        try {
            serverSocket = new ServerSocket(9527);
            while (true) {
                socket = serverSocket.accept();
                InputStream inputStream = socket.getInputStream();
                dataInputStream = new DataInputStream(inputStream);
                String str = dataInputStream.readUTF();
                System.out.println(str);


                //向客户端回信息
                //OutputStream outputStream = socket.getOutputStream();
                //dataOutputStream = new DataOutputStream(outputStream);
                //dataOutputStream.writeUTF("hello client,this is your server");
                (new DataOutputStream(socket.getOutputStream())).writeUTF(
                        "hello client,this is your server");
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dataInputStream != null)
                    dataInputStream.close();
                if (dataOutputStream != null)
                    dataOutputStream.close();
                if (serverSocket != null)
                    serverSocket.close();

            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

~~~java
//客户端
public class MyClient {
    public static void main(String[] args) {
        Socket socket = null;
        DataOutputStream dataOutputStream = null;
        DataInputStream dataInputStream = null;

        try {
            socket = new Socket("127.0.0.1", 9527);
            OutputStream outputStream = socket.getOutputStream();
            dataOutputStream = new DataOutputStream(outputStream);
            dataOutputStream.writeUTF("hello");


            //接收服务器发来的消息
            dataInputStream = new DataInputStream(socket.getInputStream());
            String str = dataInputStream.readUTF();
            System.out.println(str);


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (dataOutputStream != null)
                    dataOutputStream.close();
                if (dataInputStream != null)
                    dataInputStream.close();
                if (socket != null)
                    socket.close();


            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
~~~

## 反射

当某个类被加载到内存的时候，JVM会自动创建该类的Class对象，这就是它的反射对象，反射对象就像是一面镜子一样照射着当前正在加载的这个类，把类结构看得清清楚楚，它可以帮助我们创建该加载类对象，访问成员变量，调用方法。

**反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。**

获取Class对象的方式：

1. 对象名.getClass();
2. 类名.class
3. Class.forName("加载类的全类名")

~~~java
    public static void main(String[] args) {
        //方法1
        Person p = new Person();
        Class c1 = p.getClass();
        System.out.println(c1);
        //方法2
        Class c2 = Person.class;
        System.out.println(c2);
        //方法3
        Class c3 = null;
        try {
            c3 = Class.forName("com.iweb.test.Person");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

    }
~~~

**注意**：一个类只有唯一的一个Class对象

newInstance() ---- 反射对象调用该方法来创建加载类对象 **注意：**实际调用的是该加载类的无参构造方法

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~

打印结果：

~~~java
我是无参构造方法
com.iweb.test.Person@14ae5a5
~~~

## Field

这表示一个加载类的某个成员变量的对象

1. 如果成员变量是public
   我们使用Class对象.getField("成员变量名")就可以获取该Field对象

2. 如果成员变量是非public
   我们使用Class对象.getDeclaredField("成员变量名")就可以获取该Field对象，然后由Field对象.setAccessible(true)进行授权即可

我们使用Field对象.set(加载类的对象，成员变量值) ---- 可以给该对象的成员变量赋属性值

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
            Field f1 = p1.getClass().getField("pname");
            f1.set(p1, "张三");
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~

~~~java
public class Test4 {

    public static void main(String[] args) {
        Class<Person> c1 = Person.class;

        try {
            Person p1 = c1.newInstance();
            System.out.println(p1);
            Field f1 = c1.getField("pname");
            f1.set(p1,"张三");
            System.out.println(p1);
            Field f2 = c1.getDeclaredField("page");
            f2.setAccessible(true);
            f2.
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();

        }
    }
}
~~~

# 2023年7月27日

## Method类

表示加载类的方法，每个方法在反射看来都是一个Method对象，我们可以使用Class对象调用getMethod("方法名")来获取Method对象，然后使用Method对象.invoke(加载类对象)来完成加载类方法的调用。

~~~java
            Method m1= c1.getMethod("info");
            m1.invoke(p1);
~~~

如果方法带有参数，那么在获取Method对象时，我们需要传入参数的Class对象，同时调用invoke方法时，需要传入参数值。

~~~java
    public void display(String str) {
        System.out.println("我是" + str + "人");
    }
~~~

~~~java
            Method m2 = c1.getMethod("display",String.class);
            m2.invoke(p1,"中国");
~~~

## Field

在Java中，Field类是反射（reflection）机制的一部分，它代表了一个类的成员变量（字段）。通过Field类，我们可以在运行时获取类的字段信息，并对这些字段进行读取和写入操作，即使在编译时并不知道这些字段的名称或类型。

## getFields

通过反射对象获取加载类中的public成员变量的Field数组

`Class c = Person.class;`

`Field[] fields = c.getFields();`

## getDeclaredFields

通过反射对象获取加载类中所有成员变量的Field数组

~~~java
            Field[] fields = c1.getFields();
            System.out.println("一共有" + fields.length + "个public成员变量，他们分别是：");
            for (Field f : fields) {
                System.out.println(f);
            }

            Field[] fields2 = c1.getDeclaredFields();
            System.out.println("一共有" + fields2.length + "个成员变量，他们分别是：");
            for (Field f : fields2) {
                System.out.println(f);
            }
~~~

## getMethods()

通过反射对象获取加载类中方法的Method数组，包括它的父类的**公共**方法

## getDeclaredMethods()

通过反射对象获取加载类中方法的Method数组，不包括它的父类的任何方法。

~~~java
            Method[] methods = c1.getMethods();
            System.out.println("一个有：" + methods.length + "个方法，他们分别是：");
            for (Method m : methods) {
                System.out.println(m);
            }

            Method[] methods2 = c1.getDeclaredMethods();
            System.out.println("一共有：" + methods2.length + "个自己声明的方法，他们分别是：");
            for (Method m : methods2) {
                System.out.println(m);
            }
~~~

## Constructor

这是反射包中一个用来表示构造方法的类，我们通过反射对象调用getConstructors获取构造方法的数组

~~~java
            Constructor[] constructors = c1.getConstructors();
            System.out.println("一共有：" + constructors.length + "个构造方法，他们分别是：");
            for (Constructor c : constructors) {
                System.out.println(c);
            }
~~~

我们可以通过getConstructor(参数的Class对象列表)可以获取有参构造方法的Constructor对象，再由该对象调用newInstance()传入参数值，即可调用有参构造方法创建加载类对象

~~~java
            Constructor<Person> constructor = c1.getConstructor(String.class,int.class);
            Person p2 = constructor.newInstance("李四",20);
            System.out.println(p2);
~~~

## 设计模式

### 单例模式

一个类只能创建一个对象

格式：

1、饿汉模式编写：

构造方法私有化，提供一个`private static final 当前类型的`成员变量赋值为当前类对象

对外提供一个`public static 当前类型返回值`的方法供别人调用，返回该成员变量

~~~java
public class Singleton01 {

    private static final Singleton01 only = new Singleton01();
    private Singleton01(){}

    public static Singleton01 singleton01Factory() {
        return only;
    }
}

~~~

~~~java
public class Test {
    public static void main(String[] args) {
        Singleton01 s1 = Singleton01.singleton01Factory();
        Singleton01 s2 = Singleton01.singleton01Factory();
        System.out.println(s1 == s2);//s1和s2内存地址相同，是同一个对象
    }
}
~~~

2、懒汉模式编写：

构造方法私有化，提供一个`private static 当前类型的`成员变量赋值null

对外提供一个`public static 当前类型返回值的`方法供别人调用，判断成员变量是否为null，如果为null则调用构造方法创建该类对象，返回成员变量

**注意**：懒汉模式需要做线程同步，饿汉不需要

~~~java
public class Singleton02 {
    private static Singleton02 only = null;

    private Singleton02() {
    }


    public synchronized static Singleton02 singleton02Factory() {
        if (only == null)
            only = new Singleton02();
        return only;
    }

}
~~~

~~~java
        Singleton02 s3 = Singleton02.singleton02Factory();
        Singleton02 s4 = Singleton02.singleton02Factory();
        System.out.println(s3 == s4);//s3 和 s4是同一个对象
~~~

### 工厂模式

一个工厂类把创建实体的过程进行了封装，当用户需要一个实体类对象的时候，无需自己创建，由工厂类直接提供

1、静态工厂模式

首先提供一个Map集合的成员变量，用来存放产品对象

然后提供一个static静态代码块用来创建若干产品对象，并存入Map集合中，对外提供一个public的工厂方法，根据需求返回Map中某个产品对象

~~~java
package com.iweb.test;

public class Car {
    private int cno;
    private String cname;


    public Car() {
    }

    public Car(int cno, String cname) {
        this.cno = cno;
        this.cname = cname;
    }

    /**
     * 获取
     * @return cno
     */
    public int getCno() {
        return cno;
    }

    /**
     * 设置
     * @param cno
     */
    public void setCno(int cno) {
        this.cno = cno;
    }

    /**
     * 获取
     * @return cname
     */
    public String getCname() {
        return cname;
    }

    /**
     * 设置
     * @param cname
     */
    public void setCname(String cname) {
        this.cname = cname;
    }

    @Override
    public String toString() {
        return "Car{cno = " + cno + ", cname = " + cname + "}";
    }
}
~~~

~~~java
package com.iweb.test;

import java.util.HashMap;
import java.util.Map;

public class Factory {


    public static Map<Integer, Object> MAP = new HashMap<>(30);

    static {
        Car car1 = new Car(1001, "BWM");
        Car car2 = new Car(1002, "benz");

        MAP.put(car1.getCno(), car1);
        MAP.put(car2.getCno(), car2);
    }

    public Car getCar(int cno) {
        return (Car)MAP.get(cno);
    }

}

~~~

~~~java
public class Test {
    public static void main(String[] args) {
        Car c =Factory.getCar(1001);
        System.out.println(c);
    }
}

~~~

2、实例工厂模式

首先提供一个Map集合的成员变量用来存放产品对象

然后提供一个构造方法用来造一个工厂

还要提供一个生产的方法用来生产产品并存入Map

对外提供一个public工厂方法根据需求返回Map中某个产品对象

~~~java
package com.iweb.test4;

import java.util.HashMap;
import java.util.Map;

/**
 * @author HeartWardrum
 * @date 2023-08-17/0017 18:13
 */
public class Factory2 {

    private static final Map<Integer, Car> MAP = new HashMap<>();

    Factory2() {
        produce();
    }

    void produce() {

        Car car1 = new Car(1001, "BWM");
        Car car2 = new Car(1002, "benz");

        MAP.put(car1.getCno(), car1);
        MAP.put(car2.getCno(), car2);
    }

    public Car getCar(int cno) {
        return MAP.get(cno);
    }
}
~~~

~~~java
public class Test {
    public static void main(String[] args) {
       Factory2 factory2 = new Factory2();
       Car c2 = factory2.getCar(1002);
        System.out.println(c2);
    }
}
~~~

### 代理模式

围绕主体业务提供周边的辅助业务，并且完成主体业务的一种设计模式。

首先提供一个统一的完整业务接口给主体类和代理类分别实现。

然后需要主体类提供主体业务方法

最后提供一个代理类，包含主体类的成员变量，可以调用主体类的主体方法。并提供额外的相关业务

用户只需要面向代理类即可完成整个业务

~~~java
public class Car {
    private String carName;
    private int carPrice;

    public Car() {
    }

    public Car(String carName, int carPrice) {
        this.carName = carName;
        this.carPrice = carPrice;
    }

    @Override
    public String toString() {
        return "Car{" +
                "carName='" + carName + '\'' +
                ", carPrice=" + carPrice +
                '}';
    }
}

~~~

~~~java
public interface SaleCar {
    public Car getCar(String cno);
}

~~~

~~~java
public class CarFactory implements SaleCar {

    private static Map<String, Car> map = new HashMap<>();

    public CarFactory() {
        createCar();
    }

    void createCar() {
        map.put("宝马", new Car("宝马", 50_0000));
        map.put("奥迪", new Car("奥迪", 30_0000));
        map.put("迈巴赫", new Car("宝马", 1250_0000));

    }


    @Override
    public Car getCar(String carName) {

        return map.get(carName);
    }
}

~~~

~~~java
public class Car4S implements SaleCar{

    @Override
    public Car getCar(String carName) {
        System.out.println("销售");
        CarFactory carFactory = new CarFactory();
        return carFactory.getCar(carName);
    }
}
~~~

~~~java
public class Test {


    public static void main(String[] args) {
        Car4S car4S  = new Car4S();
        System.out.println(car4S.getCar("迈巴赫"));
    }
}
~~~





# 2023年7月28日

## JDBC

Java Database Connectivity

这是Java连接数据库的一种API

操作步骤

1. 加载数据库驱动
2. 获取数据库连接
3. 获取Statement对象
4. 执行sql语句
5. 处理查询结果
6. 关闭连接和资源

~~~java
//连接Oracle数据库中dept表
//数据库ip：192.168.77.100  端口： 1521  数据库服务名：helowin
//账号：scott  密码：123456 
public class JdbcExample {
    public static void main(String[] args) {
        String url = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
        String username = "scott";
        String password = "123456";

        Connection conn = null;//表示数据库的连接
        Statement stat = null;//表示操作SQL语句的对象
        ResultSet rest = null;//表示接收结果集的对象


        try {
            //加载数据库驱动，把Oracle驱动类手动加进内存
            Class.forName("oracle.jdbc.driver.OracleDriver");
            //获取数据库连接
            conn = DriverManager.getConnection(url, username, password);
            //获取Statement对象
            stat = conn.createStatement();
            //执行SQL语句并返回结果
            String sql = "select * from dept";
            rest = stat.executeQuery(sql);
            //循环遍历结果集并使用数据
            while (rest.next()) {
                int deptno = rest.getInt("deptno");
                String dname = rest.getString("dname");
                String loc = rest.getString("loc");
                System.out.println(deptno + ":" + dname + ":" + loc);
            }


        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭连接和资源
                if (rest != null)
                    rest.close();
                if (stat != null)
                    stat.close();
                if (conn != null)
                    conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

打印结果：

~~~java
12:喝酒部:伊豆
70:人事部:伤害
10:ACCOUNTING:NEW YORK
20:RESEARCH:DALLAS
30:SALES:CHICAGO
40:OPERATIONS:BOSTON
50:轻音部:霓虹111
~~~



## ResultSetMetaData

(好处就是可以打印列名)

表示RestSet中列相关的信息，我们可以通过

RestSet对象.getMetaData() ---- 获取它的对象。

getColumnCount() ---- 得到列数

getColumnName(列数) ---- 得到某一列的字段名

~~~java
public class Test {

    public static void main(String[] args) {
        String url = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
        String username = "scott";
        String password = "123456";

        Connection conn = null;
        Statement stat = null;
        ResultSet rest = null;
        ResultSetMetaData rsmd = null;

        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");

            conn = DriverManager.getConnection(url, username, password);

            stat = conn.createStatement();

            String sql = "select * from dept";
            rest = stat.executeQuery(sql);

            rsmd = rest.getMetaData();
            int columnCount = rsmd.getColumnCount();
            while (rest.next()) {
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = rsmd.getColumnName(i);
                    Object columnValue = rest.getObject(i);
                    System.out.print(columnName + "=" + columnValue + "    ");

                }
                System.out.println();
            }

        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null)
                    rest.close();
                if (stat != null)
                    stat.close();
                if (conn != null)
                    conn.close();

            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~

打印结果

~~~java
DEPTNO=12    DNAME=喝酒部    LOC=伊豆    
DEPTNO=70    DNAME=人事部    LOC=伤害    
DEPTNO=10    DNAME=ACCOUNTING    LOC=NEW YORK    
DEPTNO=20    DNAME=RESEARCH    LOC=DALLAS    
DEPTNO=30    DNAME=SALES    LOC=CHICAGO    
DEPTNO=40    DNAME=OPERATIONS    LOC=BOSTON    
DEPTNO=50    DNAME=轻音部    LOC=霓虹111  
~~~

## executeUpdate(SQL语句)

由Statement对象调用该方法，执行增删改语句

~~~java
public class Test2 {
    public static void main(String[] args) {
        Connection conn = null;//表示数据库的连接
        Statement stat = null;//表示操作SQL语句的对象
        try {
            //加载数据库驱动，把Oracle驱动类手动加进内存
            Class.forName("oracle.jdbc.driver.OracleDriver");
            //获取数据库连接
            conn = DriverManager.getConnection(
                    "jdbc:oracle:thin:@192.168.77.100:1521:helowin",
                    "scott",
                    "123456");
            //获取Statement对象
            stat = conn.createStatement();
            //执行SQL语句并返回结果
            String sql = "insert into dept values('60','运维部','北京')";
            int i = stat.executeUpdate(sql);
            System.out.println("成功编辑了 " + i + " 条记录");
            
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {

                if (stat != null)
                   { stat.close();}
                if (conn != null)
                    {conn.close();}
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

~~~

## 断点调试

我们在程序入口处打断点，使用Debug方式运行，程序会在断点处停下来，我们可以单步调试，如果调用方法，那么可以使用setup into进入所调用的方法继续调试，我们还可以使用resume program一次性走到下一个断点，如果没有下一个断点，则直接走完。

在调试的过程中，我们可以选中公式或表达式，点击Evalute Expression进行取值的查看，

## CallableStatement

用来调用存储过程，我们通过Connection对象调用`prepareCall("{call 存储过程名(?,?,?,...)}")`来获取该对象，然后通过`该对象.setXxx(序号，值)`给存储过程赋参数值，最后调用`execute()`来执行存储过程

~~~java
package com.iweb.test;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class TestCallableStatement {


    public static void main(String[] args) {

        String url = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
        String username = "scott";
        String password = "123456";


        Connection conn = null;
        CallableStatement callableStatement = null;

        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");
            conn = DriverManager.getConnection(url, username, password);
            callableStatement = conn.prepareCall("{call mypro(?,?,?)}");
            callableStatement.setInt(1, 90);
            callableStatement.setString(2, "扶她部");
            callableStatement.setString(3, "日本");
            callableStatement.execute();
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (callableStatement != null) {
                    callableStatement.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }

}

~~~

## confirm("字符串")

弹出一个确认框，当用户点击确定时，返回true，当用户点击取消时，返回false

## JDBC方法封装

~~~java
public class JdbcUtil {
    private static final String URL = "jdbc:oracle:thin:@192.168.77.100:1521:helowin";
    private static final String USERNAME = "scott";
    private static final String PASSWORD = "123456";

    private static Connection conn = null;
    private static Statement stat = null;
    private static ResultSet rest = null;

    public JdbcUtil() {

    }

    //获取数据库连接
    public static Connection getConn() {
        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");
            conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    //关闭所有资源和连接
    public static void closeSource() {
        try {
            if (rest != null)
                rest.close();
            if (stat != null)
                stat.close();
            if (conn != null)
                conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /*
    统一进行查询的JDBC方法
     */
    public static List<Map<String, Object>> queryBySql(String sql) {
        List<Map<String, Object>> list = new ArrayList<>();

       
        ResultSetMetaData rsmd = null;
        try {
            stat = getConn().createStatement();
            rest = stat.executeQuery(sql);
            rsmd = rest.getMetaData();
            while (rest.next()) {
                Map<String, Object> map = new HashMap<>();
                for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                    map.put(rsmd.getColumnName(i), rest.getObject(i));
                }
                list.add(map);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null)
                    rest.close();
                closeSource();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return list;
    }

    /*
    增删改
     */
    public static void editBySql(String sql) {
        try {
            stat = getConn().createStatement();
            int i = stat.executeUpdate(sql);
            System.out.println("成功编辑了" + i + "条记录");
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            closeSource();
        }
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {
       String sql = "delete from dept where deptno = 70";
       JdbcUtil.editBySql(sql);

//        String sql2 = "select * from dept";
//        System.out.println(JdbcUtil.queryBySql(sql2));
    }
}

~~~

## JDBC连接MySQL

只需要更改url、username、password、Class.forName()

~~~java
    private static final String URL =
            "jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "123456";
~~~

~~~java
            Class.forName("com.mysql.cj.jdbc.Driver");
~~~

## 模拟登录

~~~java
public class LoginService {
    public boolean login(String username, String password) {
        password = DigestUtils.md5Hex(password);
        String sql = "select count(*) cou from my_user where username = '" + username
                + "' and password = '" + password + "'";
        List<Map<String, Object>> list = JdbcUtil2.queryBySql(sql);
        Map<String, Object> map = list.get(0);
        Long rest = (Long) map.get("cou");
        return rest > 0;
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {

        String username = "root1";
        String password = "123456";
        LoginService loginService = new LoginService();
        if (loginService.login(username, password)) {
            System.out.println("登录成功！");
        } else {
            System.out.println("用户名或密码错误！");
        }

    }
}
~~~

## SQL注入

当参数值直接被拼到SQL语句中时，人为地传入部分SQL语句作为参数，可以绕过条件判断，达到查询的目的

~~~java
//使用SQL注入登录
public class Test {

    public static void main(String[] args) {

        String username = "1' or '1'='1' or '1'='1";//SQL注入
        String password = "123456";
        LoginService loginService = new LoginService();
        if (loginService.login(username, password)) {
            System.out.println("登录成功！");
        } else {
            System.out.println("用户名或密码错误！");
        }

    }
}
~~~

# 2023年7月31日

## PreparedStatement

和Statement对象类似，它也可以执行SQL语句

通过Connection调用prepareStatement(SQL语句)得到该对象

它采用参数绑定的方式来封装SQL语句，SQL语句中所有有参数的地方使用`?`

该对象调用setXxx(序号n，参数值)用来给第n个位置的`?`绑定参数值

他可以有效防止SQL注入

~~~java
//防止SQL注入，并且能传入多个参数的最终JDBC工具类
public class JdbcUtil2 {
    private static final String URL =
            "jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "123456";

    private static Connection conn = null;
    private static PreparedStatement pstat = null;
    private static ResultSet rest = null;

    public JdbcUtil2() {

    }

    //获取数据库连接
    public static Connection getConn() {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    //关闭所有资源和连接
    public static void closeSource() {
        try {
            if (rest != null)
                rest.close();
            if (pstat != null)
                pstat.close();
            if (conn != null)
                conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /*
    统一进行查询的JDBC方法
     */
    public static <T> List<Map<String, Object>> queryBySql(String sql, T... t) {
        List<Map<String, Object>> list = new ArrayList<>();

        ResultSetMetaData rsmd = null;
        try {
            pstat = getConn().prepareStatement(sql);
            for (int i = 0; i < t.length; i++) {
                pstat.setObject(i + 1, t[i]);
            }
            rest = pstat.executeQuery();
            rsmd = rest.getMetaData();
            while (rest.next()) {
                Map<String, Object> map = new HashMap<>();
                for (int i = 1; i <= rsmd.getColumnCount(); i++) {
                    map.put(rsmd.getColumnName(i), rest.getObject(i));
                }
                list.add(map);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rest != null)
                    rest.close();
                closeSource();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return list;
    }

    /*
    增删改
     */
    public static <T> void editBySql(String sql, T... t) {
        int result = 0;
        try {
            pstat = getConn().prepareStatement(sql);
            for (int i = 0; i < t.length; i++) {
                pstat.setObject(i + 1, t[i]);
            }
            result = pstat.executeUpdate();
            System.out.println("成功编辑了" + result + "条记录");
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            closeSource();
        }
    }
}
~~~

~~~java
public class LoginService {
    public boolean login(String username, String password) {
        password = DigestUtils.md5Hex(password);
        String sql = "select count(*) cou from my_user where username = ? and password = ?";
        List<Map<String, Object>> list = JdbcUtil2.queryBySql(sql,username,password);
        Map<String, Object> map = list.get(0);
        long rest = (long) map.get("cou");
        System.out.println(rest);


        return rest > 0;
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {
//        String username = "root";
//        //String username = "1' or '1'='1' or '1'='1";//SQL注入
//        String password = "123456";
//        LoginService loginService = new LoginService();
//        if (loginService.login(username, password)) {
//            System.out.println("登录成功！");
//        } else {
//            System.out.println("用户名或密码错误！");
//        }

//
        String sql = "insert into mybook values(null,?,'')";
        JdbcUtil2.editBySql(sql,"海的房间","黄利群");


    }
}

~~~

# 2023年8月1日

## Tomcat

1. 这是一个流行的web容器，用来部署发布网站的工具，它需要运行在Java环境的服务器上
2. 修改Tomcat端口：配置根目录/conf/server.xml中的`<connector>`中的port属性

## URL地址结构

`http://ip地址:端口号/web应用的名称/请求名`

~~~
http://ip地址:端口号/web应用的名称/请求名
|__________________|		   |
     web站点根目录               |
|_______________________________|
		web应用的根目录
~~~

web站点根目录：`http://ip地址:端口号`

web应用的根目录：`web站点的根目录/web应用的名字`

完整的URL：`web应用的根目录/请求名`

**注意**：请求名对应web.xml中的`<url-pattern>`

## servlet

狭义上：Servlet是一个接口，他可以接收请求返回响应，广义上讲，servlet是一个实现了Servlet接口的实现类，它重写了接口中的抽象方法，包括生命周期相关的方法：

生命周期方法：

调用构造方法实例化 ---- 只有一个实例化的Servlet对象

init() ---- 初始化方法

service() ---- 接收到一个请求，并返回响应

destroy() ---- 销毁当前servlet对象

**注意**：init方法只会执行一次，而service方法在每次请求到来的时候都被执行一次，destroy方法在tomcat停止的时候被执行一次

~~~
//ChatGPT:
Java Servlet的生命周期由Servlet容器管理，它在Servlet的整个生命周期中调用不同的方法。以下是Servlet生命周期的主要阶段和相应的方法：

1. 加载和实例化阶段：
   - 当Servlet容器启动时，它会查找并加载Web应用程序中的Servlet类。
   - 然后，Servlet容器通过调用Servlet类的构造函数来实例化Servlet对象。
   - 只会在Servlet容器启动时加载一次，并在后续请求中共享同一个Servlet实例。

2. 初始化阶段：
   - 实例化后，Servlet容器会调用Servlet的init()方法进行初始化。
   - 在init()方法中，可以执行一些初始化任务，比如读取配置信息、建立数据库连接等。
   - 每个Servlet实例只会初始化一次。

3. 请求处理阶段：
   - 一旦Servlet初始化完成，它就可以处理客户端发来的请求了。
   - 当有新的请求到达时，Servlet容器会在单独的线程中调用Servlet的service()方法。
   - service()方法根据请求的类型（GET、POST等）调用doGet()、doPost()等具体的处理方法。

4. 销毁阶段：
   - 当Servlet容器关闭时，或者Web应用程序被卸载时，Servlet容器会调用Servlet的destroy()方法。
   - 在destroy()方法中，可以执行一些资源释放的操作，比如关闭数据库连接、保存状态等。

值得注意的是，当Servlet容器检测到Servlet类的代码或配置文件发生改变时，它会自动重新加载和实例化Servlet，然后再次调用init()方法进行初始化。因此，在Web应用程序运行过程中，Servlet可能会多次初始化和销毁。

Servlet生命周期的管理使得Servlet容器可以高效地管理资源，并在需要时重新加载和更新Servlet，从而实现Web应用程序的动态性和灵活性。
~~~



## web.xml

这是web项目中的核心配置文件，它配置了各个请求对应的servlet类

格式：

~~~xml
<servlet>标签子标签
<servlet-name> ---- 当前servlet名字
<servlet-class> ---- 当前servlet类的全类名
<servlet-mapping> ---- 表示一个servlet的映射信息，包含两个子标签：
<servlet-name> ---- 当前servlet名字
<url-pattern> ---- 表示当前请求名   
~~~

~~~xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.iweb.test.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/myfirstrequest</url-pattern>
    </servlet-mapping>
~~~

**注意**：一个`<servlet>`可以对应多个`<servlet-mapping>`，由此，多个请求名都会进入该servlet类

~~~xml
    <servlet>
        <servlet-name>second</servlet-name>
        <servlet-class>com.iweb.test.MySecondServlet</servlet-class>
        <load-on-startup>0</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>second</servlet-name>
        <url-pattern>/second</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>second</servlet-name>
        <url-pattern>/second02</url-pattern>
    </servlet-mapping>
~~~



## `<load-on-startup>`

配置在`<servlet>`中，表示当前servlet被初始化的时机，如果配置非负整数，则表示tomcat启动进行初始化

~~~xml
<load-on-startup>0</load-on-startup>
~~~

多个servlet的加载顺序是按照`<load-on-startup>`值从小到大进行加载，0最先被加载，数字越大越靠后

## 通配符

`<url-pattern>`中的通配符

1. `/*` ---- 任意请求都能进这个servlet（除非有其他明确指定的）
2. `/` ---- 功能大致类似`/*`
3. `*.do` ---- do为自定义后缀，可以更改

~~~xml
ChatGPT:
/*：匹配所有URL。
/test/*：匹配所有以/test/开头的URL，如/test/foo和/test/bar。
/test/abc：仅匹配/test/abc这个具体的URL。
*.html：匹配所有以.html结尾的URL，如/page.html和/docs/index.html。
/user/*/profile：匹配类似/user/123/profile和/user/john/profile的URL
~~~

## 2023年8月2日

## ServletConfig

这是当前Servlet大管家，他可以获取当前servlet中方方面面的信息

getInitParameter() ---- 获取当前servlet的初始化参数

**注意**：初始化参数使用`<init-param>`配置在`web.xml`的`<servlet>`中

~~~xml
    <servlet>
        <servlet-name>second</servlet-name>
        <servlet-class>com.iweb.test.MySecondServlet</servlet-class>
        <init-param>
            <param-name>username</param-name>
            <param-value>root</param-value>
        </init-param>
        <load-on-startup>0</load-on-startup>
    </servlet>
~~~

~~~java
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("当前servlet被初始化了");
        String username = servletConfig.getInitParameter("username");
        System.out.println(username);//打印root
    }
~~~

getServletName(); ---- 获取当前servlet的名字

## ServletContext

这是当前Web应用的大管家，它可以获取当前整个Web应用方方面面的信息

我们可以通过ServletConfig对象调用getServletContext()来获取ServletContext对象

ServletContext常用方法 ：

getInitParameter(参数名) ---- 获取当前web应用的初始化参数的参数值

注意：web应用的初始化参数配在`<servlet>`外，使用`<context-param>`标签来配置

~~~xml
    <context-param>
        <param-name>password</param-name>
        <param-value>123456</param-value>
    </context-param>
~~~

~~~java
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        ServletContext servletContext = servletConfig.getServletContext();
        String password = servletContext.getInitParameter("password"); 
    }
~~~

getRealPath(文件在项目中的位置) ---- 获取指定文件在部署发布后的绝对路径

getContextPath() ---- 获取当前web应用的根目录

## ServletRequest

表示当前请求

getParameter(参数名) ----- 根据参数名得到对应的参数值

## 前端向servlet发起请求的方式

1. url地址栏写url，按回车键
2. `<a>`通过href属性配置url-pattern
3. `<form>`通过action属性配置url-pattern
4. ajax

## 关于传参

url地址栏可以使用`？`带参数，参数之间使用&符号分割

`<a>`可以使用href带参数

`<form>`可以使用name属性对应参数名，value属性对应参数值

## servlet项目中get和post请求方式区别

url地址栏发请求一定是get请求

 `<a>`发请求一定是get请求

`<form>`默认是get请求，method属性设置为post则为post请求

区别：

1. get请求的参数会显示在地址栏，post参数隐藏在消息体中
2. get请求参数长度不能超过1k，post没有长度限制
3. get请求是幂等的，多次相同的get请求会返回相同的结果，不会对服务器产生影响，post不一定是幂等的。
4. get请求可以被浏览器缓存，提高性能。

## ServletResponse

表示servlet返回的响应，我们可以调用该对象的getWriter()得到一个PrintWriter对象，再由PrintWriter对象调用print方法，完成返回内容的打印
# 2023年8月4日

## servlet登录

~~~java
//src\main\java\com.iweb.test\Login
public class Login implements Servlet {

    ServletContext sc;

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        sc = servletConfig.getServletContext();
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

        String username = sc.getInitParameter("username");
        String password = sc.getInitParameter("password");
        //页面上填写的账号密码
        String usernameParam = servletRequest.getParameter("username");
        String passwordParam = servletRequest.getParameter("password");

        PrintWriter pw = servletResponse.getWriter();
        if (username.equals(username) && password.equals(passwordParam)) {
            pw.print("hello " + usernameParam);
        } else {
            pw.print("sorry " + usernameParam);
        }

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

~~~

~~~xml
<!-- web\WEB-INF\web.xml   -->
    <context-param>
        <param-name>username</param-name>
        <param-value>admin</param-value>
    </context-param>


    <context-param>
        <param-name>password</param-name>
        <param-value>123456</param-value>
    </context-param>


    <servlet>
        <servlet-name>login</servlet-name>
        <servlet-class>com.iweb.test.Login</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>login</servlet-name>
        <url-pattern>/login</url-pattern>
    </servlet-mapping>
~~~

~~~html
<!-- web\login.html   -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户登录</title>
</head>
<body>
<h3>用户登录</h3>
<form action="login" method="post">
    账号：<input type="text" name="username"/>
    <br/><br/>
    密码：<input type="password" name="password"/>
    <br/><br/>
    <input type="submit" value="登录"/>
</form>
</body>
</html>
~~~

## HttpServletRequest

它是ServletRequest的子接口，它拥有了ServletRequest中所有的方法，我们浏览器发起的请求实际上全都是HttpServletRequest类型

常用方法：

getServletContext() ---- 获取当前ServletContext对象

```java
@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println("来了一个请求");
    System.out.println(servletRequest instanceof HttpServletRequest);
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    ServletContext sc = request.getServletContext();
    System.out.println(sc.getInitParameter("username"));
}
```

getRequestURI() ---- 获取当前请求URL中的URI部分（URI =URL - web站点根目录）

getMethod() ---- 获取当前请求的请求方式

getServletPath() ----  获取当前请求名

getContextPath() ---- 获取当前web应用根目录

~~~java
   @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("来了一个请求");
        System.out.println(servletRequest instanceof HttpServletRequest);
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        ServletContext sc = request.getServletContext();
        System.out.println(sc.getInitParameter("username"));
        String uri = request.getRequestURI();
        String method = request.getMethod();
        System.out.println(method);
        String urlpattern = request.getServletPath();
        System.out.println(urlpattern);
        String contextPath = request.getContextPath();
        System.out.println(contextPath);
    }
~~~

## HttpServlet

这是一个抽象类，它实现了Servlet接口，它重写了接口中生命周期相关的方法，它将ServletRequest和ServletResponse向下转型成了HttpServletRequest和HttpServletResponse然后它调用了getMethod()判断当前请求的请求方式，并提供了doGet和doPost供我们重写

在实际开发中，我们无序实现Servlet接口，只需要继承HttpServlet，并重写doGet或者doPost方法即可，可以专注于业务逻辑的开发。

## Git

git config -l ---- 查看git配置信息

git config --global user.name "xxx" ---- 配置自己的姓名

git config --global user.email "xxx@xxx.xxx" ---- 配置自己的邮箱地址

工作目录 ---- 自己写代码的文件夹

暂存区 ---- 保存代码的临时修改

本地资源仓库 ---- 存放本地待提交的数据

远程仓库 ---- 用来保存数据共享和交换的真实仓库

git add ---- 将工作目录提交到暂存区

git commit ---- 将暂存区的数据提交到本地仓库

git push ---- 将本地仓库的数据提交到远程仓库

git pull ---- 从远程仓库下载代码到本地工作目录

git init ---- 初始化一个git工作目录

git status ---- 查看git文件夹中的状态

`git add . `---- 将git文件夹中所有新文件添加到暂存区

`git commit -m "消息内容"` ---- 将暂存区的数据提交到本地仓库

test cmd

### 小组合作使用git远程仓库步骤

组长操作：

1. 新建一个SpringBoot项目
2. 新建一个gitee仓库
3. 本地新建一个git文件夹
   在一个空文件夹中，使用git命令行窗口输入git init
4. 将gitee仓库克隆到该文件夹：
   使用git clone地址
5. 将clone好的仓库文件夹中的.git和.gitignore拷贝到SpringBoot项目文件夹中
6. 在idea工具中上传该项目到gitee远程仓库

组员操作：

1. 打开idea工具，File ---- New ---- Project from version Controller...
   git的url填写当前gitee仓库的url
   点击“clone”
2. 安排一位同学上传配置文件：pom.xml  application.properties等，其他同学右键点击项目 ---- git ---- pull这些配置文件
3. 所有人将自己模块的包，类。接口...从自己的项目中复制到现在下载的git项目中，然后测试功能，不报错的情况下，上传到远程仓库
4. 对于公共文件，先pull，再知会组内其他成员，然后修改后上传

### 小组合作使用git远程仓库步骤（HBuild工具）

在Hbuild工具中，右键项目名 ---- git ---- 添加

添加完之后点击 Commit 提交，之后点击push，刷新仓库页面

**注意**：添加的时



其他组员clone该项目到HBuilder

完成之后各自启动测试，测试完成之后各自添加自己的文件，各自add、commit 和 push

对于公共文件，先pull，再知会组内其他成员，然后修改后上传
# 2023年8月7日

## JSP

JavaServer Pages

前后端混合编写的技术

前端代码使用HTML编写，后端的Java代码写在`<% %>`中

JSP技术必须写在后缀名是.jsp的文件中

~~~jsp
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
  hello
   <%
     System.out.println("hello jsp");
   %>
  </body>
</html>
~~~

当我们编写好JSP文件，随着Tomcat启动，它会自动翻译出一个Servlet，并执行
所以JSP的本质是一个Servlet
JSP是后端技术

## 将字符串打印到页面

1. `out.print("字符串)`
2. `<%="字符串"%>`

~~~jsp
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
  hello
   <%
     out.println("1");
   %>
  <%="2"%>
  </body>
</html>

~~~

## JSP九大隐含对象

rrosacppe

**隐含对象**：在JSP中无序定义可以直接使用的对象

out ---- JspWriter类的对象，可以打印字符串到网页上

request ---- HttpServletRequest类的对象，表示当前请求

response ---- HttpServletResponse类的对象，表示当前响应

pageContext ---- PageContext类的对象，表示当前页面上下文，它可以获取其他八位的对象

session ---- HttpSession类的对象，表示当前会话，会话指的是一次浏览器的打开到关闭的过程

application ---- ServletContext类的对象，是Servlet的大管家

config ---- 当前JSP翻译出的哪个Servlet类的ServletConfig对象

page ---- 当前JSP翻译出来的哪个Servlet类的对象

exception ---- 当前JSP抛出的异常对象

#### ChatGPT:

JSP（JavaServer Pages）中有九个隐含对象，它们是预先定义好的变量，开发人员可以在JSP页面中直接使用，用于访问与请求、会话、上下文等相关的信息。以下是这九个隐含对象的列表和简要说明：

1. **request（请求对象）**：表示当前HTTP请求的对象，可以用于获取请求参数、头信息等。

2. **response（响应对象）**：表示当前HTTP响应的对象，可以用于设置响应头、写入响应内容等。

3. **out（输出对象）**：用于向客户端浏览器输出内容，类似于`System.out`，但用于输出到浏览器。

4. **session（会话对象）**：表示用户的会话，可以用于在不同请求之间存储和获取用户的数据。

5. **application（应用上下文对象）**：表示整个Web应用程序的上下文信息，可以用于在不同会话之间共享数据。

6. **config（配置对象）**：表示JSP页面的配置信息，例如JSP的初始化参数。

7. **pageContext（页面上下文对象）**：表示JSP页面的上下文信息，包括其他隐含对象和一些有用的方法。

8. **page（页面对象）**：表示JSP页面本身的对象，相当于Java类的this。

9. **exception（异常对象）**：用于捕获页面中发生的异常，并进行相应的处理。

这些隐含对象在每个JSP页面中都是自动可用的，开发人员可以直接在页面中使用它们，从而方便地访问与请求、会话、上下文等相关的信息，实现更丰富的功能。

-------------

index.jsp表示首页,它的文件名可以不写就直接展示

~~~jsp
<html>
<head>
    <title>MyFirstJSP</title>
</head>
<body>
This is my first JSP

<%
String age = request.getParameter("age");
out.print("age = " + age);
int ageInt = Integer.valueOf(age);
if(ageInt >= 18){
    out.print("您已经成年了");
}else{
    out.print("未成年人禁止访问");
}
%>

</body>
</html>
~~~

**注意**：在同一个JSP文件中，各个JSP代码块是相通的

~~~jsp
<html>
<head>
    <title>MyFirstJSP</title>
</head>
<body>
This is my first JSP

<%
String age = request.getParameter("age");
%>
<br/>
<%
out.print("age = " + age);
%>
<br/>
<%
int ageInt = Integer.valueOf(age);
if(ageInt >= 18){
%>
您已经成年了
<%
}else{
%>
未成年爬！
<%
}
%>

</body>
</html>
~~~

注释：

`<%-- --%>`

## 四大域对象

pageContext

request

session

application

他们可以分别进行存值和取值的操作

存值 ---- setAttribute("键"，"值")

取值 ---- getAttribute("键"，"值")

删除值 ---- removeAttribute("键"，"值")

**作用范围**：

pageContext ---- 当前页面

request ---- 一次请求

session ---- 一次会话，浏览器的打开到关闭称为一次会话

application ---- 当前web应用，tomcat的启动到关闭

**注意**：实际开发中，用的最多的是request

~~~jsp
<html>
<head>
    <title>MyFirstJSP</title>
</head>
<body>
This is my first JSP

<%

    pageContext.setAttribute("pageKey", "pageValue");
    request.setAttribute("reqKey", "reqValue");
    session.setAttribute("sessionKey", "SessionValue");
    application.setAttribute("applicationKey", "applicationValue");
%>

<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("reqKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>
<br/>

<a href="mySecondJSP.jsp">跳转到第二个页面</a>
</body>
</html>
~~~

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
第二个页面
<br/>
<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("reqKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>
<br/>
</body>
</html>
~~~

## 请求转发

1. 采用当前request对象调用getRequestDispatcher(路径)得到RequestDispatcher对象
2. 通过RequestDispatcher对象调用 forward(request,response)完成转发

~~~java
public class TestForward extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了个请求，即将转发去下一个页面");
        //转发去下一个页面
        String path = "/test2.jsp";
        //获取转发器
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(path);
        requestDispatcher.forward(req,resp);//完成转发

    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>testForward</servlet-name>
        <servlet-class>com.iweb.TestForward</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testForward</servlet-name>
        <url-pattern>/testForward</url-pattern>
    </servlet-mapping>
~~~

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
test1

<a href="testForward">to test2.jsp</a>

</body>
</html>
~~~

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
test2
</body>
</html>
~~~

##  重定向

通过HttpServletResponse对象调用sendRedirect(路径)即可

~~~java
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将重定向去下一个页面");
        String path = "/test20230807/test2.jsp";
        resp.sendRedirect(path);

    }
~~~

### 面试题：请求转发和重定向的区别

**本质区别**：

转发在转发前和转发后是同一个请求
重定向在重定向前后是两个不同的请求

**细节上的区别**：

1. 路径中的斜杠含义不同，转发的时候，斜杠表示web应用根目录，重定向的时候，表示web站点根目录
2. url地址栏的显示不同，转发的时候，显示的是初次发起的请求名，重定向的时候，显示的是最终到达的目标资源
3. 转发的时候可以使用request对象携带数据，重定向是时候不可以使用request对象携带数据
4. 转发只能转到当前web应用以内的资源，重定向可以重定向到任何资源

**注意**：转发和重定向不仅可以跳转到页面，还可以向下一个Servlet发送请求

~~~java
public class TestResult extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是测试servlet");

    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>testResult</servlet-name>
        <servlet-class>com.iweb.TestResult</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testResult</servlet-name>
        <url-pattern>/testResult</url-pattern>
    </servlet-mapping>
~~~

~~~java
public class TestForward extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了个请求，即将转发去下一个页面");
        //转发去下一个页面
        //String path = "/test2.jsp";
        String path = "/testResult";

        req.setAttribute("key01","value01");
        //获取转发器
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(path);
        requestDispatcher.forward(req,resp);//完成转发

    }
}
~~~

## 关于路径的问题

在web.xml中，`<url-pattern>`的斜杠/表示web应用的根目录，我们发起请求所写的路径必须和该路径一致，

在页面上`<a>`和`<form>`中的斜杠/表示web站点的根目录

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
我是d1下的test1
<a href="/test20230807/testForward">请求转发</a>
<a href="/test20230807/testRedirect">重定向</a>
</body>
</html>
~~~

## errorPage属性

当前页面如果报错，则跳转到某个提示页面

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" errorPage="error.jsp" language="java" %>
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
 <%
   int i = 0;
 %>
  <%=100/i%>
  </body>
</html>

~~~

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Error</title>
</head>
<body>
对不起，系统正在维护
</body>
</html>
~~~

isErrorPage="true" ---- 表示当前页面可以使用exception隐含对象展示简要的错误信息

## `<%@include file="目标页面"%>`

将目标JSP合并到当前JSP中

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" errorPage="error.jsp" language="java" %>
<%@include file="error.jsp"%>
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
这里是index.jsp
  </body>
</html>

~~~

## 参数中的中文乱码问题

在接收请求参数之前，首先使用request对象，调用setCharacterEncoding("utf-8")，完成转码

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>test3</title>
</head>
<body>
This is test3.jsp

<br/>
<form action="<%=request.getContextPath()%>/test3" method="post">
    <input type="text" name="username"/>
    <br/>
    <input type="submit" value="提交"/>
</form>
</body>
</html>
~~~

~~~java
public class Test3 extends HttpServlet {

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        System.out.println("我是post请求");
        String str = req.getParameter("username");
        System.out.println(str);
    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>test3</servlet-name>
        <servlet-class>com.iweb.Test3</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>test3</servlet-name>
        <url-pattern>/test3</url-pattern>
    </servlet-mapping>
~~~





# 2023年8月10日

## EL

使用${} 表示EL表达式

它可以从域对象中取值，格式：

${xxxScope.键} ---- 根据键获取对应值

~~~jsp
<body>
我是测试页面
<%
    pageContext.setAttribute("key01", "value01");
    request.setAttribute("key02", "value02");
    session.setAttribute("key03", "value03");
    application.setAttribute("key04", "value04");

%>
<br/>
${pageScope.key01};
<br/>
${requestScope.key02};
<br/>
${sessionScope.key03};
<br/>
${applicationScope.key04};

</body>
~~~

getAttribute方法后面的小数点全部都是get方法

例如：`${pageScope.key01.bookname};`中，第一个小数点相当于getAttribute方法，第二个小数点相当于get方法

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    pageContext.setAttribute("key01", book);
    request.setAttribute("key02", book);
    session.setAttribute("key03", book);
    application.setAttribute("key04", book);

%>
<br/>
${pageScope.key01.bookname};
<br/>
${requestScope.key02.id};
<br/>
${sessionScope.key03.author};
<br/>
${applicationScope.key04.bookname};

</body>
~~~

xxxScope可以省略不写，如果不写，则按照与对象取值范围从小到大的顺序依次寻找，找到为止

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    Book book2 = new Book(1001, "许三观卖血记", "余华");


    pageContext.setAttribute("key01", book);
    request.setAttribute("key01", book2);

%>
<br/>
${key01.bookname};

</body>
~~~

打印结果：

~~~jsp
活着
~~~

**注意**： `${pageContext.request.contextPath}`表示web应用根目录

扩展用法：

1. 当字符串中自带 . 时
   ~~~jsp
   ${requestScope["com.iweb.test"]}
   ~~~

2. ${param.参数}

## JSTL

JavaServer Pages Standard Tag Library

这是JSP标准标签库，它和EL表达式搭配，可以简化页面开发

操作步骤：

1、下载依赖
2、使用<%@taglib %>导入JSTL
3、使用<c:>标签来完成各种功能

例如：

~~~jsp
<c:forEach>表示循环遍历一个域对象中的集合</c:forEach>
item属性表示域对象的key,var属性表示定义用来循环的变量

      <c:forEach items="${books}" var="book">
          <tr>
              <td>${book.id}</td>
              <td>${book.bookname}</td>
              <td>${book.author}</td>
              <td><a href="<%=request.getContextPath()%>/toEdit.book?id=${book.id}">Edit</a></td>
              <td><a class="del" href="<%=request.getContextPath()%>/delete.book?id=${book.id}">Delete</a></td>
          </tr>
      </c:forEach>

~~~

~~~jsp
<c:redirect>重定向到某个页面</c:redirect>
例如：
<c:redirect url="/user/login.jsp"></c:redirect>
原版JSP代码：
<jsp:forward page="/user/login.jsp" />
效果相同
~~~

~~~jsp
<c:import>导入某个页面到当前页面中，可以是当前web应用以内或以外的资源</c:import>
例如：
<c:import url="http://www.baidu.com" charEncoding="utf-8"></c:import> <!--导入了百度-->
~~~

## Cookie

这是存放在浏览器电脑上的小文本文件，它对应服务器上的一个Cookie类的对象，当浏览器第一次向服务器发送请求时，由服务器创建Cookie对象，随响应带回浏览器，然后浏览器将其保存为文本文件，下一次再发请求时，浏览器会自动携带该Cookie文件去往服务器，服务器会自动比对确认两次请求来自同一个浏览器。

~~~jsp
<body>

<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

Cookie中携带的时键值对

默认Cookie中携带的一个键叫做JSESSIONID，值是一个16进制数的键值对，它表示当前这个会话

~~~jsp
<body>
<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
        }
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

我们可以通过new Cookie(键，值)来创建一个自己的Cookie对象，然后通过response.addCookie(Cookie对象)将cookie对象绑定到response中带回浏览器

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        response.addCookie(cookie);
    }
%>
</body>
~~~

Cookie默认都是会话级别，它会随浏览器的关闭而消失

我们可以将其设置为持久级别：

使用Cookie对象的setMaxAge(秒数)表示当前cookie对象存活的时间，它不再 受到当前会话的影响。

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        cookie.setMaxAge(30);//设置存活时间之后，就成为了持久层cookie
        response.addCookie(cookie);
    }
%>
</body>
~~~

如果使用cookie.setMaxAge(0) ---- 表示立即删除

如果秒数为负数，例如：`cookie.setMaxAge(-1312312)`，则相当于这句话没写

~~~jsp
<%
    String username = request.getParameter("username");
    if (username == null) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (int i = 0; i < cookies.length; i++) {
                if ("username".equals(cookies[i].getName())) {
                    username = cookies[i].getValue();
                }
            }
        }
    }else{
        Cookie cookie = new Cookie("username",username);
        cookie.setMaxAge(30);
        response.addCookie(cookie);
    }
    if(username == null){
        response.sendRedirect(request.getContextPath() + "/user/login.jsp");
    }
%>
~~~

# 2023年8月11日

## Session

HttpSession类的对象，表示当前会话

是用于在服务器端跟踪用户状态和存储用户数据的机制。，

getId() ---- 获取当前会话的JSESSIONID

isNew() ---- 判断当前会话是否是新的会话

getCreationTime() ---- 获取当前会话的创建时间

getLastAccessedTime() ---- 获取当前会话中上次请求的时间

getMaxInactiveInterval() ---- 获取使当前会话失效的两次请求的间隔时间

~~~jsp

<body>
<h3>test3页面</h3>
<%=session.getId()%>
<br/>
<%=session.isNew()%>
<br/>
<%=session.getCreationTime()%>
<br/>
<%=session.getLastAccessedTime()%>
<br/>
<%=session.getMaxInactiveInterval()%>
</body>
~~~

session.invalidate(); ---- 使当前会话立即失效

### Session的应用

在单点项目中：

1. 使用Session来存放用户的登录信息
2. 用来防止重复提交

### 重复提交

1. 连续点击提交按钮
2. 点击“提交”后转发到成功页面，刷新该页面，也是重复提交
3. 点击“提交”后，请求转发到成功页面，点击“后退”，再点击提交，也是重复提交

**不是重复提交**：如果点击“提交”后，请求转发到成功页面，点击“后退”，再点击刷新，再点击“刷新”则不是重复提交

## AJAX

Asynchronous JavaScript and XML

偷偷摸摸发请求的技术

无需刷新页面而使得前后端通信的一种技术

### 原生态的AJAX

原生态的AJAX是围绕一个叫做XMLHttpRequest的对象展开，该对象包括以下方法：

open(请求方式，url) ---- 装载请求

send() ---- 发送请求

当请求被发送，会调用onreadystatechange方法

在该方法中，我们通常判断readyState属性来了解发送的状态：0表示初始化，1表示正在加载，2表示已经加载，3表示交互中，4表示完成

当该属性值为4时，表示响应已经返回，这时我们还需要判断http协议的状态码，200表示成功，304表示没有改变

这时，我们可以通过responseText得到后端的返回值，进行页面的局部更新

~~~jsp
    <script type="text/javascript">
        window.onload = function () {
            var strNode = document.getElementById("str");
            strNode.onkeyup = function () {
                var request = new XMLHttpRequest();//定义一个AJAX的核心对象
                var method = "GET";
                var url = "<%=request.getContextPath()%>/test6";
                request.open(method, url);//装载
                request.send(null);
                request.onreadystatechange = function () {
                    if (request.readyState == 4) {
                        if (request.status == 200 || request.status == 304) {
                            var resp = request.responseText;
                            document.getElementById("message").innerHTML=resp;
                        }
                    }
                }
            }
        }
    </script>
~~~

~~~java
public class HelloAJAX extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        System.out.println("来了个请求");
        resp.getWriter().print("你好，这是我给你的返回值");
    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>test6</servlet-name>
        <servlet-class>com.iweb.test.HelloAJAX</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>test6</servlet-name>
        <url-pattern>/test6</url-pattern>
    </servlet-mapping>
~~~

ChatGPT：

~~~jsp
这段 JavaScript 代码是一个用于实现 AJAX 功能的示例。它的主要作用是在用户在输入框中输入内容时，通过 AJAX 向服务器发送请求并接收响应，然后将响应的内容更新到页面上。

以下是逐行解释代码的各部分：

1. `window.onload = function () { ... }`：当整个页面加载完毕后，执行包含在这个函数中的代码。

2. `var strNode = document.getElementById("str");`：获取具有 id 为 "str" 的 HTML 元素，通常是一个输入框元素。

3. `strNode.onkeyup = function () { ... }`：当用户在输入框中松开键盘按键时，执行包含在这个函数中的代码。

4. `var request = new XMLHttpRequest();`：创建一个 XMLHttpRequest 对象，用于发送和接收数据。

5. `var method = "GET";`：设置请求的方法为 "GET"，即向服务器获取数据。

6. `var url = "<%=request.getContextPath()%>/test6";`：构建请求的 URL，其中 `<%=request.getContextPath()%>` 用于获取当前 Web 应用的上下文路径。`/test6` 是服务器上处理这个请求的路径。

7. `request.open(method, url);`：配置 XMLHttpRequest 对象，指定请求的方法和 URL。

8. `request.send(null);`：发送请求。在这个示例中，请求没有发送额外的数据，因此参数为 `null`。

9. `request.onreadystatechange = function () { ... }`：设置一个回调函数，在状态改变时进行处理。

10. `if (request.readyState == 4) { ... }`：当请求状态变为 4，表示请求已完成。

11. `if (request.status == 200 || request.status == 304) { ... }`：当响应状态码为 200（成功）或 304（未修改）时，表示请求成功。

12. `var resp = request.responseText;`：获取响应的文本内容。

13. `document.getElementById("message").innerHTML=resp;`：将响应的文本内容更新到 id 为 "message" 的 HTML 元素中，从而在页面上显示。

总之，这段代码展示了如何使用原生 JavaScript 和 XMLHttpRequest 对象来实现一个简单的 AJAX 请求，以及如何将服务器响应的内容更新到页面上。
~~~



**修改版**

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function () {
            var strNode = document.getElementById("str");
            strNode.onkeyup = function () {
                var strvalue = this.value;
                var request = new XMLHttpRequest();//定义一个AJAX的核心对象
                var method = "GET";
                var url = "<%=request.getContextPath()%>/test6?str=" + strvalue;
                request.open(method, url);//装载
                request.send(null);
                request.onreadystatechange = function () {
                    if (request.readyState == 4) {
                        if (request.status == 200 || request.status == 304) {
                            var resp = request.responseText;
                            document.getElementById("message").innerHTML=resp;
                        }
                    }
                }
            }

        }
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

~~~java
public class HelloAJAX extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        String str = req.getParameter("str");
        System.out.println("来了个请求");
        resp.getWriter().print("你好，这是我给你的返回值" + str);
        //test the second git repository
    }
}
~~~

## JSON

这是一个数据格式，以`{`开头，以`}`结尾，中间是键值对，键值对的键和值以冒号分割，键值对之间以逗号分割，一般来讲，键都是字符串，值是任意类型

在JS中，JSON数据是以JSON对象的形式存在的

~~~jsp
    <script type="text/javascript">
        window.onload = function () {
            var jsonObj = {
                "name": "iweb",
                "age": 10,
                "address": {
                    "city": "Nanjing",
                    "school": "南信大"
                }
            };
            alert(jsonObj.name);
            alert(jsonObj.address.school);

        }
    </script>
~~~

### JSON字符串转JSON对象

1、eval函数 ---- 可以将字符串中的js代码解析出来

~~~javascript
            var str = "alert(\"hello\");";
            eval(str);
~~~

**注意**：如果是JSON字符串，那么eval函数中的字符串左右两边需要添加左小括号和右小括号

~~~JavaScript
            var str2 = "{\"name\":\"iweb\"}";
            var jsonObj2 = eval("(" +str2+")");
            alert(jsonObj2.name);
~~~

2、JSON.parse(JSON字符串)； ---- 直接转json对象

~~~JavaScript
            var str3= "{\"name\":\"iweb\"}";
            var jsonObj3 = JSON.parse(str3);
            alert(jsonObj3.name);
~~~

## jQuery提供的AJAX相关方法

1、load(url) ---- 某控件调用该方法，发起AJAX请求，返回值直接回填到该控件中

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $("#message").load(url);
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

后端servlet还有XML和原生态AJAX时候一样

**注意**：load方法如果传入一个url参数，则表示发送get请求，如果传入一个url参数和另一个JSON格式的请求参数，则发送POST请求

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function(){
                var inputValue = $("#str").val();
                var jsonObj = {"inputValue":inputValue};
                var url = "<%=request.getContextPath()%>/ajax";
                $("#message").load(url,jsonObj);
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

2、$.get(url，参数，回调方法) ---- 发起一个get请求

3、$.post(url，参数，回调方法) ---- 发起一个post请求

**注意**：回调方法的参数自由定义，它表示后端返回的字符串

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $.get(url,jsonObj,function(data){
                   $("#message").html(data);
                });
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

#### 简单的用户名重复性校验

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").change(function () {
                var param = $("#str").val();
                //这个jsonObj和下面url中?加参数分别对应POST请求和GET请求，二者择一j
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $.post(url, jsonObj, function (data) {
                    var resultObj = JSON.parse(data);
                    if (resultObj.flag == 1) {
                        $("#message").css("color", "green").html("恭喜您，该用户名可以使用");
                    } else {
                        $("#message").css("color", "red").html("对不起，该用户名已存在");
                    }
                });
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message"></span>
</body>
</html>

~~~

~~~java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        List<String> list = new ArrayList<>();
        list.add("Tom");
        list.add("Jerry");
        String result = "";
        String str = req.getParameter("str");
        if (list.contains(str)) {
            result = "{\"flag\":0}";
        } else {
            result = "{\"flag\":1}";
        }
        System.out.println("来了个POST请求");
        resp.getWriter().print(result);
    }
~~~

# 2023年8月12日

## Filter ---- 过滤器

是一种用于在 Servlet 请求和响应之间执行过滤任务的组件

我们创建的过滤器需要实现javax.servlet包下的Filter接口

我们重写接口中的doFilter方法

当拦截到一个请求的时候，该方法会被执行，除此之外init表示初始化，它在tomcat启动时自动执行，destroy表示销毁，它在tomcat停止时自动执行。

我们需要配置web.xml

格式：

~~~xml
<filter>
<filter-name>过滤器名</filter-name>
<filter-class>过滤器类的全类名</filter-class>
</filter>
<filter-mapping>
<filter-name>过滤器名</filter-name>
<url-pattern>拦截的资源或请求</url-pattern>
</filter-mapping>

~~~

例如：

~~~xml
    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~java
public class HelloFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了一个请求");
    }

    @Override
    public void destroy() {

    }
}
~~~

### 过滤器的放行

在doFilter方法中使用filterChain对象调用doFilter(servletRequest,servletResponse)即可放行

如果该过滤器之后还有其他过滤器，则放行到下一个过滤器，如果没有其他过滤器，则放行到目标资源



**注意**：过滤器也可以拦截去往servlet的请求

~~~java
//servlet
public class TestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是Servlet");
    }
}

~~~

~~~java
//filter
public class TestFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("我拦截到了一个去往testServlet的请求");
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("我是TestFilter，我宣布放行！");

    }

    @Override
    public void destroy() {

    }
}

~~~

~~~xml
<!-- web.xml -->
    <servlet>
        <servlet-name>testServlet</servlet-name>
        <servlet-class>com.iweb.test.TestServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testServlet</servlet-name>
        <url-pattern>/testServlet</url-pattern>
    </servlet-mapping>


    <filter>
        <filter-name>testFilter</filter-name>
        <filter-class>com.iweb.test.TestFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>testFilter</filter-name>
        <url-pattern>/testServlet</url-pattern>
    </filter-mapping>
~~~

FilterConfig ---- 当前Filter的大管家，可用获取当前过滤器方方面面的信息，用法和ServletConfig一样

~~~xml
    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
        <init-param>
            <param-name>username</param-name>
            <param-value>xunyi</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~java
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String username = filterConfig.getInitParameter("username");
        System.out.println(username);
    }
~~~

多级过滤器，他们的顺序，是web.xml中`<filter-mapping>`排列的先后顺序决定的。# 2023年8月14日

## Listener ---- 监听器

监听着我们web项目中的域对象什么时候被创建，什么时候被销毁

我们通常所说的监听器，指的是实现了监听器接口的实现类，该实现类需要在web.xml中配置`<listener>`标签，该标签包含`<listener-class>`指向当前监听器类。

1、ServletContextListener： 它监听着ServletContext对象什么时候被创建，什么时候被销毁，当它被创建的时候，会自动执行contextInitialized方法，当他被销毁的时候，会自动执行contextDestroyed方法

web.xml:

~~~xml
    <listener>
        <listener-class>com.iweb.test.HelloListener</listener-class>
    </listener>
~~~

HelloListener.java:

~~~java
package com.iweb.test;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class HelloListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被创建了");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了");

    }
}
~~~

2、HttpSessionListener:它监听着一个会话什么时候创建，什么时候销毁
当它创建的时候调用sessionCreated方法
当它销毁的时候，调用sessionDestroyed方法

~~~java
package com.iweb.test;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class HelloListener implements ServletContextListener, HttpSessionListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被创建了");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了");

    }

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话创建了");
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话销毁了");
    }
}
 
~~~

**注意**：当关闭浏览器的时候，仅仅是当前会话不再可以被使用，而没有立即销毁，当调用invalidate方法时，会话立即销毁

~~~jsp
<%
    session.invalidate();
%>
~~~

3、ServletRequestListener:他监听着一个请求什么时候被创建，什么时候倍销毁

requestInitialized() ---- 一个请求倍创建时自动调用该方法

requestDestroyed() ---- 一个请求被销毁自动调用该方法

~~~java
public class HelloListener implements ServletContextListener, HttpSessionListener, ServletRequestListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被创建了");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了");

    }

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话创建了");
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话销毁了");
    }

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        System.out.println("一个请求被创建了");
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        System.out.println("一个请求被销毁了");
    }
}

~~~

## Spring

### 两大核心

IoC ---- 控制反转，又称依赖注入（DI），反转了资源提供的方向，原本需要自己去创建对象，现在由Spring推送，自己的程序被动地接收

AOP ---- 面向切面的编程，将所有与业务逻辑无关，但是每个模块都必须编写的代码（如：日志管理，转码工作）抽取出来做成一个切面，它自动切入指定的模块，完成它的工程，我们只需要专注自己模块的业务逻辑即可。

### 搭建Spring项目的步骤

1. 创建一个Maven工程
2. 在pom.xml中添加spring-core，spring-beans，spring-context依赖
3. 在resources文件夹中添加applicationContext.xml配置文件，并在该文件的<beans>下添加<bean>表示一个对象，<bean>中包含id属性表示该Bean的唯一标识符，class属性指向该对象的类，<property>标签表示该对象的属性，name表示属性名，value表示属性值
4. 创建测试类，使用ApplicationContext对象调用getBean方法获取Spring容器中的对象。

工程详见：HelloSpring20230814 

pom.xml:

~~~xml
<!-- Spring基础的三个依赖  主要用来使用IoC       
<!-- https://mvnrepository.       com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.6</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-beans -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>5.3.6</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.6</version>
        </dependency>
~~~



resources文件夹下的applicationContext.xml文件：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="stu1" class="com.iweb.test.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="张三"></property>
        <property name="sage" value="20"></property>

    </bean>
</beans>
~~~

Student.java

~~~java

package com.iweb.test;

public class Student {

    private String sno;
    private String sname;
    private String sage;

    public String getSno() {
        return sno;
    }

    @Override
    public String toString() {
        return "Student{" +
                "sno='" + sno + '\'' +
                ", sname='" + sname + '\'' +
                ", sage='" + sage + '\'' +
                '}';
    }

    public void setSno(String sno) {
        this.sno = sno;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getSage() {
        return sage;
    }

    public void setSage(String sage) {
        this.sage = sage;
    }

    public Student() {
    }

    public Student(String sno, String sname, String sage) {
        this.sno = sno;
        this.sname = sname;
        this.sage = sage;
    }
}

~~~

Test.java

~~~java

package com.iweb.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        Student student1 = (Student) ac.getBean("stu1");
        System.out.println(student1);
    }
}

~~~

**注意**：当Spring容器被加载的时候，它就会利用反射调用容器中对象所在的类的无参构造方法创建对象，并且调用set方法为该对象赋属性值

**注意**：Spring容器中的<property> name属性对应的是实体类set方法的方法名去掉set剩下的部分首字母转小写。

**注意**：getBean不仅可以传入id值获取对象，还可以传入类名.class获取对象

当某个对象的某个属性是另外一个对象的时候，那么我们在<property>中使用ref引入另外一个对象的<bean>作为当前的属性值

~~~xml
    <bean id="stu1" class="com.iweb.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="Jerry"></property>
        <property name="sage" value="20"></property>
        <property name="school" ref="school1"></property>
    </bean>

    <bean id="school1" class="com.iweb.School">
        <property name="schoolName" value="nuist"></property>
        <property name="schoolAddress" value="nanjing"></property>
    </bean>
~~~

在Spring容器中，我们可以使用<constructor-arg>来调用实体类中有参的构造方法来创建对象

~~~xml
    <bean id="stu1" class="com.iweb.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="Jerry"></property>
        <property name="sage" value="20"></property>
        <property name="school" ref="school1"></property>
    </bean>

   <bean id="school1" class="com.iweb.School">
       <constructor-arg name="schoolName" value="nuist"></constructor-arg>
       <constructor-arg name="schoolAddress" value="nanjing232323"></constructor-arg>
   </bean>
~~~

name属性对应构造方法的参数名

value属性对应传入参数的值

`<property>`和`<constructor-arg>`标签的区别：

- 使用 `<property>` 标签配置属性时，Spring 将会在创建对象后，通过对应的 setter 方法设置属性的值。这意味着 `School` 类必须有对应的 setter 方法。
- 使用 `<constructor-arg>` 标签配置构造函数参数时，Spring 将会在创建对象时直接调用指定的构造函数，传递设置的参数值。这意味着 `School` 类必须有一个与参数列表匹配的构造函数。

### 扫描器

Spring的容器中，可以使用扫描器去扫描一个包，包内所有带@Component的类都会自动创建对象，无需再手动配置Spring Beans

添加扫描器的步骤：

1. 添加context命名空间和验证文件（从Spring官网拷入）
   ~~~xml
   <!-- 添加了xmlns:context那行和最后两行 -->
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
         					  https://www.springframework.org/schema/context/spring-context.xsd"><!--这里面添加两行-->
   
   </beans>
   ~~~

2. 添加<context:component-scan>标签，并在base-package属性中配置需要扫描的包名

   ~~~xml
   <!-- 添加了xmlns:context那行和最后两行 -->
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
         					  https://www.springframework.org/schema/context/spring-context.xsd"><!--这里面添加两行-->
       
       
   <context:component-scan base-package="com.iweb"></context:component-scan><!-- 写下这一行，自此，com.iweb包下面的所有类，只要加了@Component注解，就不用再写<bean>配置来创建对象了 -->
       
   </beans>
   
   
   ~~~

### Spring框架可以对工厂模式进行很好的支持

在<bean>标签中，我们可以使用class执行工厂类，factory-method指向工厂方法，<constructor-arg>给工厂方法传参来获取对应的产品对象。

Car.java

~~~Java
package com.iweb.factory;

public class Car {

    private String cno;
    private String brand;
    private String price;
    private String maxSpeed;

    @Override
    public String toString() {
        return "Car{" +
                "cno='" + cno + '\'' +
                ", brand='" + brand + '\'' +
                ", price='" + price + '\'' +
                ", maxSpeed='" + maxSpeed + '\'' +
                '}';
    }

    public String getCno() {
        return cno;
    }

    public void setCno(String cno) {
        this.cno = cno;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getPrice() {
        return price;
    }

    public void setPrice(String price) {
        this.price = price;
    }

    public String getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(String maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public Car() {
    }

    public Car(String cno, String brand, String price, String maxSpeed) {
        this.cno = cno;
        this.brand = brand;
        this.price = price;
        this.maxSpeed = maxSpeed;
    }
}

~~~

CarFactory1.java

~~~java
package com.iweb.factory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CarFactory1 {


  static   Map<String, Car> cars = new HashMap<>();

    static {

        cars.put("1001", new Car("1001", "Audi", "30,0000", "240"));
        cars.put("1001", new Car("1002", "Ford", "15,0000", "220"));
        cars.put("1001", new Car("1003", "Volov", "13,0000", "240"));
        cars.put("1001", new Car("1004", "BMW", "35,0000", "300"));

    }

    public static Car getCar(String cno){
        return cars.get(cno);
    }
}

~~~

applicationContext.xml

~~~xml
    <bean id="car1" class="com.iweb.factory.CarFactory1" factory-method="getCar">
        <constructor-arg name="cno" value="1001"></constructor-arg>
    </bean>
~~~

如果是实例工厂模式，则首先需要创建工厂的<bean>对象，然后在产品的<bean>对象中，使用factory-bean指向工厂的<bean> factory-method指向工厂方法

CarFactory2.java

~~~java
package com.iweb.factory;

import java.util.HashMap;
import java.util.Map;

public class CarFactory2 {


    static Map<String, Car> cars = new HashMap<>();

    public CarFactory2() {
        cars.put("1001", new Car("1001", "Audi", "30,0000", "240"));
        cars.put("1001", new Car("1002", "Ford", "15,0000", "220"));
        cars.put("1001", new Car("1003", "Volov", "13,0000", "240"));
        cars.put("1001", new Car("1004", "BMW", "35,0000", "300"));

    }


    public  Car getCar(String cno) {
        return cars.get(cno);
    }
}

~~~

applicationContext.xml

~~~java
    <bean id="factory2" class="com.iweb.factory.CarFactory2"></bean>
    <bean id="car2" factory-bean="factory2" factory-method="getCar">
        <constructor-arg name="cno" value="1001"></constructor-arg>
    </bean>
~~~

除了以上两种工厂模式，spring还提供了一个FactoryBean接口，我们只需要将自己的工厂类实现该接口并重写三个方法：getObject()中返回产品对象，getObjetType()中返回产品对象的类型，isSingleton()返回是否是单例
然后将该工厂类配到spring容器中即可



main方法的执行可以先不加载当前类

## AOP

AOP开发步骤：

1. 添加spring-aspects依赖和spring-aop依赖
2. 添加纯净版的业务逻辑类
3. 添加通知类
4. 再Spring容器中田家庵纯净版业务逻辑类的对象和通知类的对象
5. 在Spring容器中添加`<aop:config>`标签并配置切点表达式指向业务逻辑类的方法，添加`<aop:advisor>`来绑定切点表达式和通知类的`<bean>`
6. 编写测试类，完成测试



首先配置pom.xml
~~~xml
       <!-- 使用AOP需要加的依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>5.3.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>5.3.6</version>
        </dependency>
~~~

再配置applicationContext.xml

添加了 ` xmlns:aop="http://www.springframework.org/schema/aop"`

和 `http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd`

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd

 http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

</beans>
~~~

首先需要一个纯净版的业务逻辑类

MyArithmetic2.java

~~~java
package com.iweb.test;

public class MyArithmetic2 {
//不带打印日志的语句

    public int add(int a,int b){

        int result = a + b;
        return result;
    }

    public int subtract(int a,int b){

        int result = a - b;
        return result;
    }


    public int multiply(int a,int b){

        int result = a * b;
        return result;
    }


    public int divide(int a,int b){

        int result = a / b;
        return result;
    }

}
~~~

还需要一个前置类

MyBeforeAdvice.java

~~~java
package com.iweb.test;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName() +
                " start , get params: " + objects[0] + " and " + objects[1]);

    }
}
~~~

在applicationContext.xml中添加<bean>

~~~xml
    <aop:config>
        <aop:pointcut id="myPoint" expression="execution(* com.iweb.test.MyArithmetic2.*(..))"/>
        <aop:advisor advice-ref="myBeforeAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>

    <bean id="myArithmetic2" class="com.iweb.test.MyArithmetic2"></bean>
    <bean id="myBeforeAdvice" class="com.iweb.test.MyBeforeAdvice"></bean>
~~~

测试类：

~~~java
package com.iweb.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test7 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        MyArithmetic2 ma = (MyArithmetic2) ac.getBean("myArithmetic2");
        int i = ma.add(1,2);
        System.out.println(i);
    }
}

~~~

### 通知类：

MethodBeforeAdvice ---- 前置通知

AfterReturningAdvice ---- 后置返回通知

添加后置返回通知：
MyBeforeAdvice.java

~~~java
package com.iweb.test;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName() +
                " start , get params: " + objects[0] + " and " + objects[1]);

    }
}

~~~

修改applicationContext.xml

~~~xml
    <aop:config>
        <aop:pointcut id="myPoint" expression="execution(* com.iweb.test.MyArithmetic2.*(..))"/>
        <aop:advisor advice-ref="myBeforeAdvice" pointcut-ref="myPoint"></aop:advisor>
        <aop:advisor advice-ref="myAfterAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>

    <bean id="myArithmetic2" class="com.iweb.test.MyArithmetic2"></bean>
    <bean id="myBeforeAdvice" class="com.iweb.test.MyBeforeAdvice"></bean>
    <bean id="myAfterAdvice" class="com.iweb.test.MyAfterAdvice"></bean>
~~~

### 使用注解的方式来完成AOP

1. 我们创建通知类，添加@Component和@Aspect注解，在通知类中添加@Before表示前置通知，切点表达式写在注解中
2. 在Spring容器中配置扫描器扫描通知类的包和业务逻辑包
3. 在Spring容器中添加`<aop:aspectj-autoproxy>`使得注解生效
4. 编写测试类完成测试

通知类的注解：

@Before("切点表达式") --- 前置注解

@After("切点表达式") --- 后置注解

@`AfterReturning(value="切点表达式"，returning="返回值变量名，例如：result")` ---- 后置返回通知
然后在方法中必须要有Object 类型的参数，参数名要和上面的一样
例如：`public void afterMethod(JoinPoint joinPoint,Object result)`

@After和@AfterReturning的区别：
如果程序报错（比如：除0），@After依旧会触发，@AfterReturning不会触发，因为没有返回值

MyArithmetic3.java

```java
package com.iweb.test2;


import org.springframework.stereotype.Component;

@Component
public class MyArithmetic3 {
//不带打印日志的语句

    public int add(int a,int b){

        int result = a + b;
        return result;
    }

    public int subtract(int a,int b){

        int result = a - b;
        return result;
    }


    public int multiply(int a,int b){

        int result = a * b;
        return result;
    }


    public int divide(int a,int b){

        int result = a / b;
        return result;
    }

}
```

前置通知：

```java
package com.iweb.test2;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyBeforeAdvice2 {


    @Before("execution(* com.iweb.test2.MyArithmetic3.*(..))")
    public void beforeMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();//获取切入的方法名
        Object[] args = joinPoint.getArgs();
        System.out.println(methodName + " start ,get params : " + args[0] + " and " + args[1]);
    }
}
```

测试：

```java
package com.iweb.test2;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test8 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        int result = ((MyArithmetic3) ac.getBean(MyArithmetic3.class)).subtract(30,2);
        System.out.println(result);

    }
}
```

applicationContext.xml

```xml
<context:component-scan base-package="com.iweb.test2"></context:component-scan>
<!-- 使aop注解生效 -->
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

后置通知：

```java
package com.iweb.test2;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAfteAdvice2 {


    @After("execution(* com.iweb.test2.MyArithmetic3.*(..))")
    public void afterMethod(JoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + " ends!");
    }
}
```

带返回值的后置通知：

```java
package com.iweb.test2;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAfteAdvice3 {


    @AfterReturning(value="execution(* com.iweb.test2.MyArithmetic3.*(..))",returning = "result")
    public void afterMethod(JoinPoint joinPoint,Object result){
        String methodName = joinPoint.getSignature().getName();

        System.out.println(methodName + " ends! result: " + result);


    }


}
```# 2023年8月15日

### `<url-pattern>`中的`/ ` 和  `/* `区别

`/*` 是拦截所有请求

`/`是拦截`.jsp`以外的所有请求

## SpringMVC

这是一个封装了Servlet的框架，它能够接收请求，返回响应

搭建步骤：

1. 创建一个Maven项目，添加框架的支持，选择springMVC
2. 在pom.xml中添加spring-webmvc和servlet的依赖
3. 在web.xml中将`<url-pattern>`修改为`/`，并在请求分发器的`<servlet>`添加初始化参数指向spring配置文件（dispatcher-servlet.xml）
4. 修改spring配置文件，添加扫描器扫描控制器所在的包
5. 修改spring配置文件，添加视图解析器，指向返回页面的前缀和后缀
6. 在控制器类中添加@Controller注解，方法上添加@RequestMapping("请求名")表示接收指定的请求，返回值为响应的页面文件名
7. 启动Tomcat，完成测试。

pom.xml中添加依赖：

~~~xml
        <!-- SpringMVC -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.6</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
~~~

web.xml中进行修改

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
    </context-param>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
         <!-- 添加了4行 -->
        <init-param>      
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/dispatcher-servlet.xml</param-value>
        </init-param>
        
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>  <!-- 修改了 -->
    </servlet-mapping>
</web-app>
~~~

修改dispatcher-servlet.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/context
      					  https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 使用了扫描器 -->
    <context:component-scan base-package="com.iweb.test.controller"></context:component-scan>
</beans>
~~~

被扫描的类

```java
package com.iweb.test.controller;
import org.springframework.stereotype.Controller;

@Controller
public class HelloSpringMVC {

    @RequestMapping("/hellospringmvc")
    public String hello() {
        System.out.println("来了个请求！");
        return "hello";
    }
```

在dispatcher-servlet.xml中加入视图解析器：

~~~xml
    <!-- 视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/jsp/"></property><!-- 前缀 -->
        <property name="suffix" value=".jsp"></property><!-- 后缀 -->
        <!-- 前缀后后缀中间缺少的，就是@Controller中return的字符串，例如HelloSpringMVC.java中的return "hello" -->
    </bean>
~~~

## ModelAndView

这是一个类，用来返回响应到指定页面，并且在request中携带数据

我们的控制器方法可以返回该类型

addObject("键"，"值") ---- 存放数据到request中

setViewName() ---- 设置返回页面的路径

```java
@RequestMapping("/test2")
public ModelAndView test(ModelAndView mv) {
    System.out.println("来了个ModelAndView请求！");
    mv.addObject("myKey","myValue");
    mv.setViewName("hello");
    return mv;
}
//前端使用${requestScope.myKey}来打印
```

在SpringMVC的控制器方法中，我们可以定义HttpSession和HttpRequestRequest参数，由SpringMVC传递给我们使用

```java
@RequestMapping("/test2")
public ModelAndView test(ModelAndView mv, HttpSession session,
                         HttpServletRequest request) {
    System.out.println("来了个ModelAndView请求！");
    mv.addObject("myKey", "myValue");
    mv.setViewName("hello");
    session.setAttribute("sessionKey", "sessionValue");
    request.setAttribute("requestKey","requestValue");
    ServletContext application = request.getServletContext();
    application.setAttribute("applicationKey","applicationValue");
    return mv;
}
```

```jsp
${requestScope.myKey}
<br/>
${sessionScope.sessionKey}
<br/>
${requestScope.requestKey}
<br/>
${applicationScope.applicationKey}
```

在@RequestMapping注解中，

method = RequestMethod.GET表示只接受get请求
method = RequestMethod.POST表示只接受post请求

## @RequestParam

接收请求参数

```java
    @RequestMapping(value = "/test2", method = RequestMethod.GET)
    public ModelAndView func(ModelAndView mv, @RequestParam String username, @RequestParam String password) {
        mv.setViewName("world");//去world.jsp prefix是/jsp/  suffix是.jsp
        System.out.println("username = " + username);
        System.out.println("password = " + password);
        return mv;
    }
```

## CharacterEncodingFilter过滤器

完成参数转码，解决中文乱码的问题。

在web.xml中

```xml
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>utf-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## @PathVariable

可以绑定url中的占位符到控制器方法的形参中，占位符部分使用{参数名}表示

```jsp
<a href="<%=request.getContextPath()%>/test3/1001">test3</a>
```

```java
@RequestMapping("/test3/{id}")
public String test3(@PathVariable("id") String id){
    System.out.println(id);
    return "hello";//跳转到hello.jsp
}
```

## Model 

这时ModelAndView中的Model，它可以绑定数据到request中

addAttribute("键"，"值") ---- 将键值对存入request中。

```java
@RequestMapping("/test3/{id}")
public String test3(@PathVariable("id") String id, Model model) {
    System.out.println(id);
    model.addAttribute("modelKey", "modelValue");
    return "hello";//跳转到hello.jsp
}
```

## @ModelAttribute

可以把一个对象绑定到Model中

```java
@RequestMapping("/test4")
public String test4(@ModelAttribute User user){
    user.setUsername("xunyi");
    user.setFullname("xunyi lannister");
    user.setPassword("213");
    return "hello";
}
```

```jsp
${requestScope.user.fullname}
```

@ModelAttribute可以绑定同名参数到某个对象的同名属性中

```java
@RequestMapping("/test5")
public String test5(@ModelAttribute User user){
    return "hello";
}
```

# 2023年8月16日

## SpringMVC中对静态文件的放行

在web.xml中，请求分发器配置了斜杠,他能够拦截`.jsp`以外的所有请求，当我们需要导入静态文件的时候，它也会拦截，我们需要对静态文件放行，具体操作：

添加<servlet-mapping>里面包含<servlet-name>为default，<url-pattern>为*.后缀

具体的某个后缀的静态文件就会被放行

```xml
<!-- 放行*.js -->
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.js</url-pattern>
</servlet-mapping>
```

新版：检测用户名是否存在

```jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2023-08-16/0016
  Time: 8:47
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>

    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#username").change(function () {
                var username = $(this).val();
                var jsonObj = {
                    "username": username
                };
                var url = "<%=request.getContextPath()%>/checkedUser"
                $.post(url, jsonObj, function (data) {
                    var resultObj = JSON.parse(data);
                    if (resultObj.flag == 1) {
                        $("#message").css("color", "green").html("恭喜，用户名可用");
                        $("#sub").prop("disabled", false);
                    } else {
                        $("#message").css("color", "red").html("对不起，用户名已存在");
                        $("#sub").prop("disabled", true);//提交按钮置灰
                    }
                })
            })
        })
    </script>
</head>
<body>
<form action="<%=request.getContextPath()%>/test5" method="post">
    username<input type="text" name="username" value="" id="username"/>
    <span id="message"></span>
    <br/>
    password<input type="text" name="password" value=""/>
    <br/>
    fullname<input type="text" name="fullname" value=""/>
    <br/>
    <input type="submit" value="提交" id="sub"/>
</form>
</body>
</html>

```

```java
package com.iweb.test.controller;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Controller
public class CheckedUsername {


    @RequestMapping("/checkedUser")
    public void checkedUser(HttpServletResponse response, @RequestParam String username) throws IOException {
        List<String> users = new ArrayList<>();
        users.add("tom");
        users.add("jerry");
        String result = "";
        if (users.contains(username)) {
            result = "{\"flag\":0}";
        } else {
            result = "{\"flag\":1}";
        }
        System.out.println("校验用户名是否存在");
        response.getWriter().print(result);

    }

}
```

## SpringMVC中的跳转

1. 转发到页面：默认返回的字符串，需要拼上前缀后缀。

2. 转发到下一个控制器：返回的字符串格式：“forward:/url地址”

   ```java
   @RequestMapping("forwardToController1")
   public String next1(){
       System.out.println("即将请求转发到下一个控制器");
       return "forward:/next";//不会去读前缀后缀
   }
   ```

   ```java
   package com.iweb.test.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.RequestMapping;
   
   @Controller
   public class NextController {
   
       @RequestMapping("/next")
       public String next() {
           System.out.println("我是下一个控制器");
           return "hello";
       }
   
   }
   ```

   ```jsp
   <a href="<%=request.getContextPath()%>/forwardToController1">转发去下一个控制器</a>
   ```

用ModelAndView的写法：

```java
@RequestMapping("/forwardToController1")
public ModelAndView next2(ModelAndView mv){
    System.out.println("即将请求转发到下一个控制器");
    mv.setViewName("forward:/next");
    return mv;
}
```

3 、重定向到下一个页面：返回的字符串格式："redirect:url地址" ，支持String和ModelAndView的返回值

```java
    @RequestMapping("/redirectToPage")
    public ModelAndView next3(ModelAndView mv){
        System.out.println("即将重定向到下一个页面");
        mv.setViewName("redirect:/jsp/hello.jsp");
        return mv;
    }
```

4、重定向到下一个控制器

```java
@RequestMapping("/redirectToController")
public ModelAndView next4(ModelAndView mv){
    System.out.println("即将重定向到下一个控制器");
    mv.setViewName("redirect:/next");
    return mv;
}
```

## 控制器之间传递数据

1、使用session

第一个控制器：

```java
@RequestMapping("/redirectToController")
public ModelAndView next4(ModelAndView mv,HttpSession session){
    System.out.println("即将重定向到下一个控制器");
    session.setAttribute("message","ni hao");
    mv.setViewName("redirect:/next");
    return mv;
}
```

第二个控制器：

```java
@RequestMapping("/next")
public String next(HttpSession session) {
    System.out.println("我是下一个控制器");
    System.out.println(session.getAttribute("message"));
    session.removeAttribute("message");
    return "hello";
}
```

2、使用RedirectAttributes用于在重定向的时候传递数据

`addFlashAttribute("键"，"值") `---- 用来存值

在接收端通过`@ModelAttribute( "键") ` 来接收数据

同时在spring容器种添加` <mvc:annotation-driven`>使其生效

了解即可，做项目基本不用

# 2023年8月17日

## MyBatis

这是一个持久化层的框架，这是一个ORM的框架

持久化：泛指所有针对数据库的操作

ORM：Object-Relational Mapping 对象关系映射，数据库中的一张表和Java中的一个实体类对应，表中的一个字段和Java中的一个成员变量对应，表中的一行记录和Java中的一个对象对应

### 搭建MyBatis框架的步骤

1、创建Maven项目，导入MyBatis和数据库的依赖
2、在pom.xml中指明配置文件的路径
3、添加实体类对应数据库中的表
4、添加MyBatis总的配置文件
5、添加SQL语句的配置文件
6、在总的配置文件中加载SQL语句的配置文件
7、添加测试类，配置二级缓存和一级缓存，完成测试

pom.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.iweb</groupId>
    <artifactId>MyBatis20230817</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>


    <dependencies>

        <!--    MyBatis    -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.6</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>


    </dependencies>


    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
        </resources>
    </build>
</project>
```

src/main/resources/mybatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration


        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>


    </environments>


    <mappers>
        <mapper resource="com/iweb/dao/MyBook.xml"/>
    </mappers>
</configuration>
```

项目的dao包中的配置文件 MyBook.xml:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mybook">
    <select id="queryById" parameterType="int" resultType="com.iweb.model.MyBook">
        select * from mybook  where id = #{id}
    </select>
</mapper>
```

测试类：

```java
package com.iweb.test;

import com.iweb.model.MyBook;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class Test1 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        SqlSession sqlSession = null;

        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
            //由工厂的建造者拿着inputStream材料去建一座生产SqlSession的工厂 ，SqlSessionFactory成为MyBatis的二级缓存
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //工厂开始生产SqlSession对象 , sqlSession成为MyBatis的一级缓存
            sqlSession = sqlSessionFactory.openSession();
            //由SqlSession对象调用方法执行SQL语句
            int id = 1001;
            MyBook myBook = sqlSession.selectOne("mybook.queryById", id);
            sqlSession.commit();
            System.out.println(myBook);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (sqlSession != null)
                sqlSession.close();

        }
    }
}
```

### MyBatis常用方法

selectOne() ---- 查询一条语句

selectList() ---- 查询多条记录

```java
List<MyBook> myBooks = sqlSession.selectList("mybook.queryAll");
```

```xml
<select id="queryAll"  resultType="com.iweb.model.MyBook">
    select * from mybook
</select>
```

insert() ---- 新增一条记录

```java
MyBook myBook = new MyBook(null, "The Little Prince", "Richard Howard");
int i = sqlSession.insert("mybook.addOne",myBook);
sqlSession.commit();
System.out.println(i);
```

```xml
<insert id="addOne" parameterType="com.iweb.model.MyBook">
    insert into mybook values(null,#{bookname},#{author})
</insert>
```

delete() ---- 删除一条记录

```java
int i = sqlSession.delete("mybook.deleteOne",id);
```

update() ---- 修改一条记录

```java
int id = 1113;
MyBook myBook = sqlSession.selectOne("mybook.queryById",id);
myBook.setBookname("琼恩兰尼斯特的费伦之旅");
myBook.setAuthor("博德之门");
int i = sqlSession.update("mybook.updateOne",myBook);
```

```xml
<update id="updateOne" parameterType="com.iweb.model.MyBook">
    update mybook set bookname = #{bookname} , author = #{author} where id = #{id}
</update>
```

**注意**：在MyBatis中，任何传参和返回值在没有ORM的时候，都可以使用Map来封装数据

查询全部：

```java
List<Map<String, Object>> myBooks = sqlSession.selectList("mybook.queryAll2");
sqlSession.commit();
System.out.println(myBooks);
```

```xml
<select id="queryAll2" resultType="java.util.HashMap">
    select * from mybook
</select>
```

新增一条：

```java
Map<String, Object> map = new HashMap<>();
map.put("id", null);
map.put("bookname", "1984");
map.put("author", "George Orwell");
int i = sqlSession.insert("mybook.addOne2", map);
System.out.println(i);
```

```xml
<insert id="addOne2" parameterType="java.util.HashMap">
    insert into mybook values(null,#{bookname},#{author})
</insert>
```

###  `<resultMap>`

创造一个ORM对象的映射

type表示实体类

`<result>`表示具体的对应关系

`property`表示成员变量

`column表示字段

新的MyBook类：

```java
package com.iweb.model;

public class MyBook2 {
    private Integer my_id;
    private String  my_bookname;
    private String  my_author;
```

```xml
<resultMap id="myResult" type="com.iweb.model.MyBook2">
    <result property="my_id" column="id"></result>
    <result property="my_bookname" column="bookname"></result>
    <result property="my_author" column="author"></result>
</resultMap>

<select id="queryAll3" resultMap="myResult">
    select * from mybook
</select>
```

```java
List<MyBook2> myBook2s = sqlSession.selectList("mybook.queryAll3");
System.out.println(myBook2s);
```

### 动态SQL

在MyBatis中，我们使用<if>标签来动态拼接SQL语句

test属性表示判断条件，当条件满足就会拼上<if>标签对中的子语句

```xml
<select id="queryByParam" parameterType="java.util.Map" resultType="com.iweb.model.MyBook">
    select * from mybook
    where 1=1
    <if test="id!=null">
        and id = #{id}
    </if>
    <if test="bookname!=null">
        and bookname = #{bookname}
    </if>
    <if test="author!=null">
        and author = #{author}
    </if>
</select>
```

```java
Map<String,Object> map = new HashMap<>();
map.put("bookname","1984");
List<MyBook> myBooks = sqlSession.selectList("mybook.queryByParam",map);
System.out.println(myBooks);
```

### 面向接口编程

1、接口名、配置文件名、命名空间名一致
2、接口中方法名和配置文件中SQL语句的id一致
3、接口中方法的参数和SQL语句的参数类型一致
4、接口中方法的返回值类型和SQL语句的返回值类型一致
满足以上四点，当我们调用接口中的方法，会自动执行SQL语句完成数据库操作。

model文件夹下User类：

```java
package com.iweb.model;

public class User {
    private String id;
    private String username;
    private String password;


    public User() {
    }

    public User(String id, String username, String password) {
        this.id = id;
        this.username = username;
        this.password = password;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```

dao文件夹下UserDao接口：

```java
package com.iweb.dao;

import com.iweb.model.User;

import java.util.List;

public interface UserDao {

    public void addOne(User user);

    public List<User> queryAll();

    public User queryById(String id);

    public void updateOne(User user);

    public void deleteOne(String id);

}
```

dao文件夹下，UserDao.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.UserDao">
    <insert id="addOne" parameterType="com.iweb.model.User">
        insert into my_user values(#{id},#{username},#{password})
    </insert>

    <select id="queryAll" resultType="com.iweb.model.User">
        select * from my_user
    </select>

    <select id="queryById" parameterType="java.lang.String" resultType="com.iweb.model.User">
        select * from my_user where id = #{id}
    </select>

    <update id="updateOne" parameterType="com.iweb.model.User" >
        update my_user set username = #{username} , password = #{password} where id = #{id}
    </update>

    <delete id="deleteOne" parameterType="java.lang.String" >
        delete from my_user where id = #{id}
    </delete>
</mapper>
```

修改mybatis-config.xml,在<mapper>标签中添加一行：

```xml
<mappers>
    <mapper resource="com/iweb/dao/MyBook.xml"/>
    <mapper resource="com/iweb/dao/UserDao.xml"/>   <!-- 添加了这一行 -->
</mappers>
```

测试类：

```java
package com.iweb.test;

import com.iweb.dao.UserDao;
import com.iweb.model.MyBook;
import com.iweb.model.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Test2 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        SqlSession sqlSession = null;

        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
            //由工厂的建造者拿着inputStream材料去建一座生产SqlSession的工厂 ，SqlSessionFactory成为MyBatis的二级缓存
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //工厂开始生产SqlSession对象 , sqlSession成为MyBatis的一级缓存
            sqlSession = sqlSessionFactory.openSession();
            //由SqlSession对象调用方法执行SQL语句


            //主要修改的是这边
            UserDao ud = sqlSession.getMapper(UserDao.class);
            List<User> users = ud.queryAll();
            System.out.println(users);
            
            
            sqlSession.commit();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (sqlSession != null)
                sqlSession.close();

        }
    }
}
```

查询一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
User user = ud.queryById("1005");
System.out.println(user);
```

新增一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
User user = new User("1007","lannister","7788");
ud.addOne(user);
```

修改一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
User user = ud.queryById("1007");
user.setUsername("join_lannister");
user.setPassword("3223");
ud.updateOne(user);
```

删除一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
ud.deleteOne("1007");
```

### 一对一级联查询

1、首先确定主从表，查询主表带出从表
2、编写各自实体类和接口，主表的实体类中包含从表类型的成员变量 
3、在主表查询语句中编写`<resultMap>`创建ORM对象关系映射，其中关联条件的`<result>`中的property对应成员变量，column对应关联字段，select对应从表的关联查询语句的id，javatype对应从表关联查询的返回值类型

Card实体类：

```java
package com.iweb.model;

public class Card {
    private String cardid;
    private String address;
    private String pname;
    private String starttime;

    public Card() {
    }

    public Card(String cardid, String address, String pname, String starttime) {
        this.cardid = cardid;
        this.address = address;
        this.pname = pname;
        this.starttime = starttime;
    }

    public String getCardid() {
        return cardid;
    }

    public void setCardid(String cardid) {
        this.cardid = cardid;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public String getStarttime() {
        return starttime;
    }

    public void setStarttime(String starttime) {
        this.starttime = starttime;
    }

    @Override
    public String toString() {
        return "Card{" +
                "cardid='" + cardid + '\'' +
                ", address='" + address + '\'' +
                ", pname='" + pname + '\'' +
                ", starttime='" + starttime + '\'' +
                '}';
    }
}
```

Person实体类：	

```java
package com.iweb.model;

public class Person {
    private String pid;
    private String pname;
    private Integer age;
    private String gender;
    private Card card;


    public Person() {
    }

    public Person(String pid, String pname, Integer age, String gender, Card card) {
        this.pid = pid;
        this.pname = pname;
        this.age = age;
        this.gender = gender;
        this.card = card;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Card getCard() {
        return card;
    }

    public void setCard(Card card) {
        this.card = card;
    }

    @Override
    public String toString() {
        return "Person{" +
                "pid='" + pid + '\'' +
                ", pname='" + pname + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                ", card=" + card +
                '}';
    }

```

CardDao:

```java
package com.iweb.dao;

import com.iweb.model.Card;

public interface CardDao {

    //根据cardid查询一张身份证信息
    public Card queryById(String cardid);


}
```

CardDao.xml:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.CardDao">

    <select id="queryById" parameterType="java.lang.String" resultType="com.iweb.model.Card">
        select c.cardid, c.pname, c.address, date_format(c.starttime, '%Y-%m-%d') starttime
        from card c
        where c.cardid = #{cardid}
    </select>
</mapper>
```

PersonDao:

```java
package com.iweb.dao;

import com.iweb.model.Person;

public interface PersonDao {

    //根据pid查询一个人的信息,以及他的身份证信息
    public Person queryById(String pid);

}
```

PersonDao.xml:

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.PersonDao">

    <!--  根据pid查询一个人的信息,以及他的身份证信息  -->
    <select id="queryById" parameterType="java.lang.String" resultMap="personResult">
        select *
        from person p
        where p.pid = #{pid}
    </select>

    <resultMap id="personResult" type="com.iweb.model.Person">
        <result property="pid" column="pid"></result>
        <result property="pname" column="pname"></result>
        <result property="age" column="age"></result>
        <result property="gender" column="gender"></result>
        <association property="card" column="cardid"
                     select="com.iweb.dao.CardDao.queryById"
                     javaType="com.iweb.model.Card"></association>
    </resultMap>
</mapper>
```

mybatis-config.xml中加两行：

```xml
<mappers>
    <mapper resource="com/iweb/dao/MyBook.xml"/>
    <mapper resource="com/iweb/dao/UserDao.xml"/>
    <mapper resource="com/iweb/dao/CardDao.xml"/>
    <mapper resource="com/iweb/dao/PersonDao.xml"/>
</mappers>
```

测试类：

```java
PersonDao pd = sqlSession.getMapper(PersonDao.class);
Person person = pd.queryById("p001");
System.out.println(person);
```

### 一对多级联查询

如果查询多的一端带出一的一端，还是使用`<association>`

如果查询一的一端带出多的一端，使用`<collection>`标签property对应成员变量，column对应关联字段，select对应多的一端表的关联查询语句的id，javatype为List，oftype为List中的泛型





