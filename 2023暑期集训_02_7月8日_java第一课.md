# 2023年7月8日

java之父 ：James Gosling 詹姆斯·高斯林

## java -- 面向对象

`JavaSE `： Java标准版

`JavaEE`：Java企业版

`JavaME`：Java移动版（用于塞班系统，已经接近淘汰）

### java的特性

1、跨平台：一次编译到处运行
java是运行在虚拟机（JVM）上的，虚拟机跨平台，shell语言和python语言都是运行在操作系统上的
JRE ---- Java运行环境（包含了JVM，还包含了别人写好的代码）
JDK ---- Java开发工具包

2、垃圾回收
在内存中释放没用的变量

### 环境变量

1、`JAVA_HOME` ---- java安装程序的根目录

2、`path` ---- 根目录下的bin文件夹，使得当前系统能够直接找到bin文件夹中的所有开发工具

3、`CLASSPATH` ---- 首先在当前目录寻找java代码，然后在根目录下的`lib`中寻找java代码

### 命令行运行java

java文件后缀是`.java`，这是原文件我们需要通过`javac`命令对它进行编译，得到编译后文件，也就是.class文件

运行java程序，使用`javac名` + 类名

~~~shell
javac Hello.java

java Hello
~~~

### java规范

1、类名首字母大写，并且和文件名同名
2、多写注释：

~~~java
/* 开头
xxxx
xxx
*/结尾 它能注释一段
    
    //它能注释一行
~~~

### 标识符

字母数字下划线和$，不能以数字开头

所有标识符必须遵循见名知意和驼峰原则

变量名和方法名：首字母小写，后面单词首字母大写   lowerCamelCase

类名：所有单词首字母大写											UpperCamelCase

包名：全小写	

常量名：全大写

### 整型的取值范围

byte ---- -2^7 到 2^7- 1

short ---- -2^15 -> 2^15 -1

int ---- -2^31 -> 2^31-1

long ---- -2^63 -> 2^63-1

默认整型为int型

### 浮点型

float ---- -2^128 -> 2^127

double ---- -2^1024 -> 2^1023

默认浮点型为double型

### 字符型char

### 布尔型boolean

注意：\表示转义字符，它有特殊的含义

\n ---- 换行

\t ---- 缩进（水平制表符）

\\\ ---- 打印反斜杠

注意：局部变量的作用范围是它所定义的语句所在的当前的一对大括号

### 自动类型转换

容量小的数据类型和容量大的数据类型作运算时，会自动将容量小的类型转容量大的类型，然后再运算。

当容量小的数据类型的值赋给容量大的数据类型的变量时，也会自动将类型转大，再赋值。

容量的大小问题：
1、byte,short,char  这三种并列最小，当它们之间进行运算时，统一转成int，然后运算
注意：这三者哪怕是相同的类型在进行运算，也会转为int

~~~java
		short s5 = 200;
		short s6 = 300;
		short s7 = s5 + s6;//s5 + s6还是会转换成int进行运算，因此报错
~~~

注意：char型在运算的时候，使用的是UNICODE编码

2、除此以外，从小到大的顺序：int->long->float->double

### 强制类型转换 

---- 容量大的数据类型转容量小的数据类型需要使用一对小括号（目标类型）来完成

强制类型转换可能会有精度的溢出

# 2023年7月10日

## String --- 字符串

字符串在跟其他任何数据类型运算的时候，只有加号+，加号的含义不是加法，而是字符串的拼接

~~~java
	String s3 = "hello";
	int i3 = 12;
	char c1 = 'a';
	System.out.println(s3 + i3 + c1);//hello12a
	System.out.println(i3 + c1 + s3);//109hello
	System.out.println(c1 + s3 + i3);//ahello12
~~~

## ++和--

++a : 先自增再使用变量
a++ ：先使用变量再自增 

if语句的条件判断必须传入boolean值，否则编译报错

赋值运算符“=”，本身也是有值的，它的值就是等号右边的值。

## 逻辑运算符

单&时，左边无论真假，右边都进行运算
双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算

`|`和`||`区别同理

## 位运算符

n >> m ---- n右移m位，相当于n除以2的m次方

n << m ---- n左移m位，相当于乘以2的m次方

## 三元运算符

条件表达式?值1：值2 ---- 条件表达式成立则位值1，否则为值2

注意：当多种运算符并存的时候，不用考虑优先级的高低，只需要使用一对小括号把自己认为先算的括起来即可

## 分支语句

注意：在if语句中，如果某个分支只有一行代码，那么该分支的一对大括号可以省略。

~~~java
class Test4 {
	public static void main(String[] args){
		int x = 4,y = 1;
		if(x>2){
			if(y>2)
				System.out.println(x + y);//if语句只管这一行
			System.out.println("ss");//这一行不会报错
		}else
			System.out.println("x = " + x);
		System.out.println("hello world");
	}
}
~~~

## 键盘输入Scanner

~~~java
import java.util.Scanner;

class Test4 {
	public static void main(String[] args){
		/*
		控制台打印：请输入一个年份
		打印该年份是不是闰年
		闰年条件：
		1.如果该年份能被4整除，但不能被100整除，那么就是软年
		2.如果该年份能被400整除，也是
		*/
		
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个年份");
		int year = sc.nextInt();
		if((0 == year%4 && 0 != year%100)||0 == year%400){
			System.out.println("是闰年");
		}else{
			System.out.println("不是闰年");
		}
		sc.close();//关闭流	
	}
}
~~~

## switch

~~~java
switch(变量名){
    case 值1:
        代码块1;
        break;
    case 值2:
        代码块2;
        break;
        ...
    default:
        代码块n;
    break;
}
~~~

注意：多个case可以公用一个代码块。

### 面试题

switch语句允许传入哪些数据类型的变量？

byte short int char Enum 
1.7及以后版本的jdk中允许传入String

## 循环四要素

1.初始化表达式
2.布尔值测试表达式
3.循环体
4.更改表达式

### 嵌套循环

一个循环是另外一个循环的循环体，那么该循环就是内层循环，另一个就是外层循环。
内层循环执行结束，外层循环才执行一次
外层循环执行结束，内层循环执行了内层*外层的次数

## break 

结束当前循环，
注意：在嵌套循环中，它结束当前这一层循环

## 无限循环

循环的布尔值测试表达式为true，循环一直执行

while(true)

for(;;){}

## continue

结束当前这一次循环，开启下一次循环

## return

用来结束当前这个方法

注意：当被调用的方法有指定的返回值类型时，该方法中必须写`return 该类型对象`  给调用者，当执行到return语句时，方法也会提前结束。

# 2023年7月11日

## 数组

这是一个容器，可以用来存放指定类型的数值。

定义数组：
1.动态初始化：

~~~java
数组类型[] 数组名 = new 数组类型[长度];
int[] arr = new int[3];
~~~

2.静态初始化：

~~~java
int[] arr = new int[]{1,2,3,4};
//注意：还可以简写
 int[] arr2 = {1,2,3,4};
~~~

~~~java
数组名.length ---- 获取数组长度
~~~

注意：数组一旦初始化，那么它的长度就不能被修改

数组的遍历：

~~~java
int[] arr = new int[]{1,2,3,4};
//1.for循环遍历
for(int i = 0;i < arr.length;i++){
    System.out.println(arr[i]);
}

//2.forEach遍历
for(int j:arr){
	System.out.println(j);
}
~~~

注意：forEach的缺点在于，它只要遍历，就一次性直接遍历完，中途无法获取当前遍历元素的下标

### 冒泡排序

相邻两个数进行比较，如果需要，那么就交换位置，一轮结束，最小的数就排到了第一位，第二轮结束，第二小的数排到了第二位

~~~java
   public static void bubbleSort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {5, 2, 8, 12, 1, 6, 4};
        bubbleSort(array);
        for (int i : array) {
            System.out.print(i + " ");
        }
    }
~~~

## 快速排序

1. 选定Pivot中心轴
2. 将大于Pivot的数字放在Pivot的右边
3. 将小于Pivot的数字防在Pivot的左边
4. 分别对左右子序列重复前三步的操作



注意：实际项目中如果需要排序，则直接调用`java.util.Arrays`包中的`Arrays.sort(数组名)`即可

~~~java
Arrays.toString(数组名); //将数组转成字符串
System.out.println(Arrays.toString(arr));//可以打印数组所有内容
~~~

## 二维数组

一个一维数组中的每个小格子装的都是一个一维数组，那么这就是二维数组

动态初始化：

~~~java
数组类型[][] 数组名 = new 数组类型[长度][长度];
		int[][] arr = new int[3][2];
		arr[0][0] = 101;
		arr[0][1] = 102;
		arr[1][0] = 201;
		arr[1][1] = 202;
		arr[2][0] = 301;
		arr[2][1] = 302;
		
		for(int[] childArr:arr){
			for(int i: childArr){
				System.out.println(i+" ");
			}
			System.out.println();
		}
~~~

静态初始化：

~~~java
		int[][] arr = {{101,102},{201,202},{301,302}};

		System.out.println(arr.length);//3
		for(int i = 0;i < arr.length;i++){
			for(int j = 0;j < arr[i].length;j++){
				System.out.print(arr[i][j] + " ");
			}
			System.out.println();
		}
~~~



### 面试题

动态初始化和静态初始化的区别：

动态初始化的初始化语句和赋值语句分开写。而静态初始化的初始化语句和赋值语句是同一句话

## java中的默认值

整型：0

浮点型：0.0

字符型：'\u0000'

布尔型：false

引用类型：null

注意：当我们使用动态初始化定义一个数组，那么它里面每个小格子都装着一个默认值



## 面向对象的编程思路：

1. 找名词
2. 名词分两类，实体和属性
3. 将每个实体定义成一个类，每个属性定义成类中的一个成员变量
4. 确定类和类之间的关系，编写方法

注意：将某个类的对象传入另一个类的某个方法中，可以体现它们之间的关联关系

## 创建对象

~~~java
new 构造方法();
~~~

## 成员变量

定义在方法外的变量，用来描述类中的某个属性

## 构造方法

与类同名，并且没有返回值，也不能写void，它只能被new调用，用来创建对象，当我们不写构造方法，系统将默认提供一个无参构造方法。

一般来讲，我们会将给对象赋属性值的动作写入构造方法。当被调用时需要传入参数为属性赋值

注意：通常当我们写了一个有参的构造方法，最好再写一个无参的构造方法，提供给别人调用。

## 内存解析

**栈内存** ---- 存放局部变量，方法的运行也在栈内存中

**堆内存** ---- 存放所有的对象

**方法区** ---- 存放所有的代码，它里面还包含常量池

**本地方法栈** ---- 和操作系统相关（仅作了解）

**程序计数器** ---- 和cpu相关（仅作了解）

注意：当栈空间中的局部变量是引用类型，那么它存放的一定是一个地址，这是一个堆空间中某个对象的地址。当局部变量的作用范围结束，它会立即从占空间中被删除，然后堆空间中的对象会变成垃圾。在未来的某个时刻被垃圾回收器gc收走，释放内存

# 2023年7月12日

## 重载

在一个类中有多个方法，他们的方法名是一样的，他们的参数不一样（参数不一样体现在：参数的个数、参数的类型），根据调用者传入的参数决定调用的是哪个方法

注意：构造方法也是可以重载的，根据传参决定由哪个构造方法创建对象

注意：不要以参数名的不同来定义重载，那不是重载，那就是相同的方法

## this

它是一个引用，它存放当前对象的地址，我们可以使用`this.成员变量`来访问当前对象的成员变量，`this.方法`来调用当前对象所在类的方法。

~~~java
public class Leaf {
    int i;

    public Leaf() {
    }

    public Leaf(int i) {
        this.i = i;
    }

    public Leaf increment() {
        this.i++;
        return this;
    }

    public void print() {
        System.out.println(this.i);
    }

    public static void main(String[] args) {
        Leaf leaf = new Leaf(1);
        leaf.increment().increment().increment().print();//链式调用
    }
}
~~~



## static

静态的，它可以用来修饰成员变量和方法

被static修饰的成员变量被成为静态成员变量，它被该类所有的对象共享，它在内存中只有一份，存放在内存中的常量区

static的成员变量可以由类名直接调用，它可以用来计数

~~~java
public class Cat {

    int id;
    String name;
    static int sid;

    Cat() {
        this.id = sid++;
    }


    Cat(String name) {
        this.id = sid++;
        this.name = name;
    }

    public static void main(String[] args) {
        Cat.sid = 1;
        Cat c1 = new Cat();
        c1.name = "Tom";

        Cat c2 = new Cat("小白");

        System.out.println(c1.id + "," + c1.name);//1,Tom
        System.out.println(c2.id + "," + c2.name);//2,小白

    }
}
~~~

被static修饰的方法被称为静态方法，静态方法又称为类方法，在静态方法中不能直接使用非静态的成员变量或非静态的方法。静态方法中不能用this

# 2023年7月13日

## 包

package

为了解决类名冲突的问题，Java引入了包的机制，我们往往先创建bao，再创建类，类名上方出现package语句用来描述当前类所在的包。

注意：

- 通过一个包下不能出现相同的包名
- 如果需要使用不同的包下的类，必须编写全类名（带包名的类名），或者使用`import`语句将该类导入

注意：`import`语句中的 `* `表示通配符，它可以导入某个包下的所有类

java.lang是整个JDK唯一一个无需导包就可以直接使用的包，它里面都是一些非常常用的类。

注意：通常对于包名的命名都会采用所在公司域名的倒写。

## 继承

“xxx”是一种“yyy”，只要这句话能说得通，这两个类就具有继承关系，被继承的类称为父类（基类，超类），继承的类称为子类（派生类）

子类自动拥有父类中所有的成员变量和方法，除此之外，子类还可能拥有其他新增加的属性和方法

创建子类语法：

~~~java
class 类名 extends 父类类名{
    
}
~~~

Java语言是单继承，一个子类不能同时继承多个父类，但是，继承有传递性

## 访问控制符

| 访问控制符 | 同一个类 | 同一个包 | 子类 | 任何地方 |
| ---------- | -------- | -------- | ---- | -------- |
| private    | √        |          |      |          |
| default    | √        | √        |      |          |
| protected  | √        | √        | √    |          |
| public     | √        | √        | √    | √        |

public修饰的类可以在任何地方使用，否则只能在当前包下使用

**子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

注意：子类拥有父类中的private方法，单子类不能使用该方法

## JavaBean

一个实体类，应该将所有成员变量私有化，并提供公共的get/set方法给外界调用，来堆成员变量存值和取值

至少提供一个无参构造器来创建对象。

JavaBean体现了面向对象的封装性。

## 重写

子类继承父类，子类对父类的方法不满意，那么子类可以重写父类中的方法，被重写的方法和重写的方法必须有相同的声明部分。它们的方法实现不一样，根据调用者的类型来决定调用哪个方法。

我们可以在重写的方法上方使用@Override注解来检查是不是重写

## super

这是一个引用，它在每个对象内部，它存放着当前对象的父类对象的内存地址，我们可以使用super.成员变量来访问父类对象的属性，我们可以使用super.方法来调用父类的方法。

父类在内存中会包含父类的部分：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689219257/javaStudy/%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E7%B1%BB%E4%B9%9F%E4%BC%9A%E5%AF%B9%E5%BA%94%E7%94%9F%E6%88%90%E4%B8%A4%E4%B8%AA%E7%88%B6%E7%B1%BB_a9u2hy.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689219257/javaStudy/如果有两个子类也会对应生成两个父类_a9u2hy.jpg)

~~~java
//父类
public class FatherClass {
    int value;
}
//子类1
public class SubClass extends FatherClass{
}
//子类2
public class SubClass2 extends FatherClass{
}
//测试
public class Test {

    public static void main(String[] args) {
        SubClass subClass = new SubClass();
        SubClass2 subClass2 = new SubClass2();
        subClass.value = 1;
        subClass2.value = 2;
        System.out.println(subClass.value);//1
        System.out.println(subClass2.value);//2
        //事实证明子类的对象包含父类的部分，并且并不想通
    }
}
~~~

## 继承中的构造方法

1. 子类在构造的过程中必须首先调用父类的构造方法来构造父类对象。
2. 在子类的构造方法中可以使用super(参数)来调用父类指定的某个构造方法构造父类对象。
3. super()可以不写，那么默认调父类无参构造方法，如果写了，则必须写在子类构造方法的第一行
4. 如果不写super()而父类中又没有无参构造方法，则编译报错

## this()

在某个构造方法中调用其他构造方法来创建对象

## Object

这是所有类的父类，当我们定义的某个类不继承任何类，那么它就直接继承了Object类，所有类都拥有并可以使用Object类中的方法。

## toString()

用一个字符串的形式来描述当前对象

## 父类引用指向子类对象

子类对象当作父类对象去使用（向上转型）

向上转型又称为父类引用指向子类对象。

当父类引用指向子类对象的时候，父类引用无法访问子类对象中新增加的成员。

注意：父类引用指向子类对象的好处：代码可扩展性比较好

~~~java
//假设Cat、Dog、Bird都是Animal的子类，分别有自己的一些独立方法
public class Test {

    public static void main(String[] args) {
        Animal a1 = new Cat("猫", "蓝色");
        Animal a2 = new Dog("狗", "红色");
        Animal a3 = new Bird("鸟", "绿色");

        f(a1);
    }
    //可扩展性体现在此
    static void f(Animal a) {
        System.out.println();
        if (a instanceof Cat) {
            System.out.println(((Cat) a).getEyesColor());
        } else if (a instanceof Dog) {
            System.out.println(((Dog) a).getFurColor());
        } else if (a instanceof Bird) {
            System.out.println(((Bird) a).getColor());
        }
    }
}

~~~



## instanceof

用来判断某个对象是否是某个类或该类子类的对象。

~~~java
    //假设Cat类和Dog类都是Animal类的子类
public static void main(String[] args) {
        Animal a = new Animal();
        Cat c = new Cat();
        a = new Cat();

        System.out.println(a instanceof Animal);//true
        System.out.println(a instanceof Cat);//true
        System.out.println(a instanceof Dog);//false
    }
~~~

## 向下转型

将父类变量使用`(子类类型)`转成子类类型，向下转型之后，该引用就可以访问子类中新增加的成员。

~~~java
        Animal a = new Cat();
        Cat c  = (Cat)a;
        c.eyeColor();
~~~

## 多态

运行时多态：当父类引用指向子类对象的时候，父类引用调用父类的方法，实际上调用到的是子类重写过后的方法，

多态是面向对象的核心机制，它的存在使得我们的代码可扩展性达到了最好

## 抽象类和抽象方法

只有声明而没有实现的方法

抽象类：含有抽象方法的类

抽象方法和抽象类都必须被abstract关键词修饰

抽象类不能被实例化，抽象类都是用来被继承的，继承了抽象类，就必须要重写该抽象类中所有的抽象方法
