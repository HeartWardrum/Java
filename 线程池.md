# 线程池

## 线程池优势

1. 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗
2. 提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行
3. 方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更会导致占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率。
4. 更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。

## ThreadPoolExecutor

ThreadPoolExecutor源码：

~~~java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
~~~

参数解析：

`corePoolSize`:指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中去

`maximumPoolSize` : 指定了线程池中的最大线程数量，这个参数会根据你使用workQueue任务队列的类型，决定线程池会开辟的最大线程数量

`keepAliveTime`:当线程池中空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁

`unit`:是`keepAliveTime`的单位

`workQueue`:任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列，有界任务队列、无界任务队列、优先任务队列几种。

`threadFactory`:线程工厂，用于创建线程，一般用默认即可

`handler`:拒绝策略；当任务太多来不及处理时，如何拒绝任务

## workQueue任务队列

一般分为“直接提交队列”、“有界任务队列”、“无界任务队列”、“优先任务队列”

### 直接提交队列

设置为SynchronousQueue队列，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，每执行一个插入操作就会阻塞，需要执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。

```java
package com.iweb.test7;

import java.util.concurrent.*;

public class ThreadPool {
    private static ExecutorService pool;

    public static void main(String[] args) {
        //maximumPoolSize设置为2，拒绝策略为AbortPolic策略，直接抛出异常
        pool = new ThreadPoolExecutor(1,
                2,
                1000,
                TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>(),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        for (int i = 0; i < 3; i++) {
            pool.execute(new ThreadTask());
        }
    }
}
```

```java
package com.iweb.test7;

public class ThreadTask implements Runnable {
    public ThreadTask() {

    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

}
```

输出结果：

~~~java
pool-1-thread-1
pool-1-thread-2
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.iweb.test7.ThreadTask@5cad8086 rejected from java.util.concurrent.ThreadPoolExecutor@6e0be858[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at com.iweb.test7.ThreadPool.main(ThreadPool.java:19)

~~~

可以看到，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接直接执行了拒绝策略抛出异常。

使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略。

### 有界的任务队列

有界的任务队列可以使用ArrayBlockingQueue实现，如下所示：

```java
pool = new ThreadPoolExecutor(1,
        2,
        1000,
        TimeUnit.MILLISECONDS,
        new ArrayBlockingQueue<Runnable>(10),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy()
);
```

使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。

若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，

若大于maximumPoolSize，则执行拒绝策略，在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。

自己的理解：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1694582633/javaStudy/%E6%9C%89%E7%95%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97_owiaq2.png](https://res.cloudinary.com/dvqgs9esp/image/upload/v1694582633/javaStudy/有界任务队列_owiaq2.png)

### 无界的任务队列

无界的任务队列可以使用LinkedBlockingQueue实现，如下：

```java
pool = new ThreadPoolExecutor(1,
        2,
        1000,
        TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy()
);
```

使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是corePoolSize设置的数量，也就是说在这种情况下，