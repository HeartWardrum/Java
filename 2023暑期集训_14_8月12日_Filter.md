# 2023年8月12日

## Filter ---- 过滤器

是一种用于在 Servlet 请求和响应之间执行过滤任务的组件

我们创建的过滤器需要实现javax.servlet包下的Filter接口

我们重写接口中的doFilter方法

当拦截到一个请求的时候，该方法会被执行，除此之外init表示初始化，它在tomcat启动时自动执行，destroy表示销毁，它在tomcat停止时自动执行。

我们需要配置web.xml

格式：

~~~xml
<filter>
<filter-name>过滤器名</filter-name>
<filter-class>过滤器类的全类名</filter-class>
</filter>
<filter-mapping>
<filter-name>过滤器名</filter-name>
<url-pattern>拦截的资源或请求</url-pattern>
</filter-mapping>

~~~

例如：

~~~xml
    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~java
public class HelloFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了一个请求");
    }

    @Override
    public void destroy() {

    }
}
~~~

### 过滤器的放行

在doFilter方法中使用filterChain对象调用doFilter(servletRequest,servletResponse)即可放行

如果该过滤器之后还有其他过滤器，则放行到下一个过滤器，如果没有其他过滤器，则放行到目标资源



**注意**：过滤器也可以拦截去往servlet的请求

~~~java
//servlet
public class TestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是Servlet");
    }
}

~~~

~~~java
//filter
public class TestFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("我拦截到了一个去往testServlet的请求");
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("我是TestFilter，我宣布放行！");

    }

    @Override
    public void destroy() {

    }
}

~~~

~~~xml
<!-- web.xml -->
    <servlet>
        <servlet-name>testServlet</servlet-name>
        <servlet-class>com.iweb.test.TestServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testServlet</servlet-name>
        <url-pattern>/testServlet</url-pattern>
    </servlet-mapping>


    <filter>
        <filter-name>testFilter</filter-name>
        <filter-class>com.iweb.test.TestFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>testFilter</filter-name>
        <url-pattern>/testServlet</url-pattern>
    </filter-mapping>
~~~

FilterConfig ---- 当前Filter的大管家，可用获取当前过滤器方方面面的信息，用法和ServletConfig一样

~~~xml
    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
        <init-param>
            <param-name>username</param-name>
            <param-value>xunyi</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~java
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String username = filterConfig.getInitParameter("username");
        System.out.println(username);
    }
~~~

多级过滤器，他们的顺序，是web.xml中`<filter-mapping>`排列的先后顺序决定的。