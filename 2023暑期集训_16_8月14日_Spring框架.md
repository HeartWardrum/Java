## Spring

### 两大核心

IoC ---- 控制反转，又称依赖注入（DI），反转了资源提供的方向，原本需要自己去创建对象，现在由Spring推送，自己的程序被动地接收

AOP ---- 面向切面的编程，将所有与业务逻辑无关，但是每个模块都必须编写的代码（如：日志管理，转码工作）抽取出来做成一个切面，它自动切入指定的模块，完成它的工程，我们只需要专注自己模块的业务逻辑即可。

### 搭建Spring项目的步骤

1. 创建一个Maven工程
2. 在pom.xml中添加spring-core，spring-beans，spring-context依赖
3. 在resources文件夹中添加applicationContext.xml配置文件，并在该文件的<beans>下添加<bean>表示一个对象，<bean>中包含id属性，class属性指向该对象的类，<property>标签表示该对象的属性，name表示属性名，value表示属性值
4. 创建测试类，使用ApplicationContext对象调用getBean方法获取Spring容器中的对象。

工程详见：HelloSpring20230814

pom.xml:

~~~xml
<!-- Spring基础的三个依赖  主要用来使用IoC       
<!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.6</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-beans -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>5.3.6</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.6</version>
        </dependency>
~~~



resources文件夹下的applicationContext.xml文件：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="stu1" class="com.iweb.test.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="张三"></property>
        <property name="sage" value="20"></property>

    </bean>
</beans>
~~~

Student.java

~~~java

package com.iweb.test;

public class Student {

    private String sno;
    private String sname;
    private String sage;

    public String getSno() {
        return sno;
    }

    @Override
    public String toString() {
        return "Student{" +
                "sno='" + sno + '\'' +
                ", sname='" + sname + '\'' +
                ", sage='" + sage + '\'' +
                '}';
    }

    public void setSno(String sno) {
        this.sno = sno;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getSage() {
        return sage;
    }

    public void setSage(String sage) {
        this.sage = sage;
    }

    public Student() {
    }

    public Student(String sno, String sname, String sage) {
        this.sno = sno;
        this.sname = sname;
        this.sage = sage;
    }
}

~~~

Test.java

~~~java

package com.iweb.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        Student student1 = (Student) ac.getBean("stu1");
        System.out.println(student1);
    }
}

~~~

**注意**：当Spring容器被加载的时候，它就会利用反射调用容器中对象所在的类的无参构造方法创建对象，并且调用set方法为该对象赋属性值

**注意**：Spring容器中的<property> name属性对应的是实体类set方法的方法名去掉set剩下的部分首字母转小写。

**注意**：getBean不仅可以传入id值获取对象，还可以传入类名.class获取对象

当某个对象的某个属性是另外一个对象的时候，那么我们在<property>中使用ref引入另外一个对象的<bean>作为当前的属性值

~~~xml
    <bean id="stu1" class="com.iweb.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="Jerry"></property>
        <property name="sage" value="20"></property>
        <property name="school" ref="school1"></property>
    </bean>

    <bean id="school1" class="com.iweb.School">
        <property name="schoolName" value="nuist"></property>
        <property name="schoolAddress" value="nanjing"></property>
    </bean>
~~~

在Spring容器中，我们可以使用<constructor-arg>来调用实体类中有参的构造方法来创建对象

~~~xml
    <bean id="stu1" class="com.iweb.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="Jerry"></property>
        <property name="sage" value="20"></property>
        <property name="school" ref="school1"></property>
    </bean>

   <bean id="school1" class="com.iweb.School">
       <constructor-arg name="schoolName" value="nuist"></constructor-arg>
       <constructor-arg name="schoolAddress" value="nanjing232323"></constructor-arg>
   </bean>
~~~

name属性对应构造方法的参数名

value属性对应传入参数的值

### 扫描器

Spring的容器中，可以使用扫描器去扫描一个包，包内所有带@Component的类都会自动创建对象

添加扫描器的步骤：

1. 添加context命名空间和验证文件（从Spring官网拷入）
   ~~~xml
   <!-- 添加了xmlns:context那行和最后两行 -->
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
         					  https://www.springframework.org/schema/context/spring-context.xsd"><!--这里面添加两行-->
   
   </beans>
   ~~~

2. 添加<context:component-scan>标签，并在base-package属性中配置需要扫描的包名

   ~~~xml
   <!-- 添加了xmlns:context那行和最后两行 -->
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
         					  https://www.springframework.org/schema/context/spring-context.xsd"><!--这里面添加两行-->
       
       
   <context:component-scan base-package="com.iweb"></context:component-scan><!-- 写下这一行，自此，com.iweb包下面的所有类，只要加了@Component注解，就不用再写<bean>配置来创建对象了 -->
       
   </beans>
   
   
   ~~~

### Spring框架可以对工厂模式进行很好的支持

在<bean>标签中，我们可以使用class执行工厂类，factory-method指向工厂方法，<constructor-arg>给工厂方法传参来获取对应的产品对象。

Car.java

~~~Java
package com.iweb.factory;

public class Car {

    private String cno;
    private String brand;
    private String price;
    private String maxSpeed;

    @Override
    public String toString() {
        return "Car{" +
                "cno='" + cno + '\'' +
                ", brand='" + brand + '\'' +
                ", price='" + price + '\'' +
                ", maxSpeed='" + maxSpeed + '\'' +
                '}';
    }

    public String getCno() {
        return cno;
    }

    public void setCno(String cno) {
        this.cno = cno;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getPrice() {
        return price;
    }

    public void setPrice(String price) {
        this.price = price;
    }

    public String getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(String maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public Car() {
    }

    public Car(String cno, String brand, String price, String maxSpeed) {
        this.cno = cno;
        this.brand = brand;
        this.price = price;
        this.maxSpeed = maxSpeed;
    }
}

~~~

CarFactory1.java

~~~java
package com.iweb.factory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CarFactory1 {


  static   Map<String, Car> cars = new HashMap<>();

    static {

        cars.put("1001", new Car("1001", "Audi", "30,0000", "240"));
        cars.put("1001", new Car("1002", "Ford", "15,0000", "220"));
        cars.put("1001", new Car("1003", "Volov", "13,0000", "240"));
        cars.put("1001", new Car("1004", "BMW", "35,0000", "300"));

    }

    public static Car getCar(String cno){
        return cars.get(cno);
    }
}

~~~

applicationContext.xml

~~~xml
    <bean id="car1" class="com.iweb.factory.CarFactory1" factory-method="getCar">
        <constructor-arg name="cno" value="1001"></constructor-arg>
    </bean>
~~~

如果是实例工厂模式，则首先需要创建工厂的<bean>对象，然后在产品的<bean>对象中，使用factory-bean指向工厂的<bean> factory-method指向工厂方法

CarFactory2.java

~~~java
package com.iweb.factory;

import java.util.HashMap;
import java.util.Map;

public class CarFactory2 {


    static Map<String, Car> cars = new HashMap<>();

    public CarFactory2() {
        cars.put("1001", new Car("1001", "Audi", "30,0000", "240"));
        cars.put("1001", new Car("1002", "Ford", "15,0000", "220"));
        cars.put("1001", new Car("1003", "Volov", "13,0000", "240"));
        cars.put("1001", new Car("1004", "BMW", "35,0000", "300"));

    }


    public  Car getCar(String cno) {
        return cars.get(cno);
    }
}

~~~

applicationContext.xml

~~~java
    <bean id="factory2" class="com.iweb.factory.CarFactory2"></bean>
    <bean id="car2" factory-bean="factory2" factory-method="getCar">
        <constructor-arg name="cno" value="1001"></constructor-arg>
    </bean>
~~~

除了以上两种工厂模式，spring还提供了一个FactoryBean接口，我们只需要将自己的工厂类实现该接口并重写三个方法：getObject()中返回产品对象，getObjetType()中返回产品对象的类型，isSingleton()返回是否是单例
然后将该工厂类配到spring容器中即可



main方法的执行可以先不加载当前类

## AOP

AOP开发步骤：

1. 添加spring-aspects依赖和spring-aop依赖
2. 添加纯净版的业务逻辑类
3. 添加通知类
4. 再Spring容器中田家庵纯净版业务逻辑类的对象和通知类的对象
5. 在Spring容器中添加`<aop:config>`标签并配置切点表达式指向业务逻辑类的方法，添加`<aop:advisor>`来绑定切点表达式和通知类的`<bean>`
6. 编写测试类，完成测试



首先配置pom.xml
~~~xml
       <!-- 使用AOP需要加的依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>5.3.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>5.3.6</version>
        </dependency>
~~~

再配置applicationContext.xml

添加了 ` xmlns:aop="http://www.springframework.org/schema/aop"`

和 `http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd`

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd

 http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

</beans>
~~~

首先需要一个纯净版的业务逻辑类

MyArithmetic2.java

~~~java
package com.iweb.test;

public class MyArithmetic2 {
//不带打印日志的语句

    public int add(int a,int b){

        int result = a + b;
        return result;
    }

    public int subtract(int a,int b){

        int result = a - b;
        return result;
    }


    public int multiply(int a,int b){

        int result = a * b;
        return result;
    }


    public int divide(int a,int b){

        int result = a / b;
        return result;
    }

}
~~~

还需要一个前置类

MyBeforeAdvice.java

~~~java
package com.iweb.test;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName() +
                " start , get params: " + objects[0] + " and " + objects[1]);

    }
}
~~~

在applicationContext.xml中添加<bean>

~~~xml
    <aop:config>
        <aop:pointcut id="myPoint" expression="execution(* com.iweb.test.MyArithmetic2.*(..))"/>
        <aop:advisor advice-ref="myBeforeAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>

    <bean id="myArithmetic2" class="com.iweb.test.MyArithmetic2"></bean>
    <bean id="myBeforeAdvice" class="com.iweb.test.MyBeforeAdvice"></bean>
~~~

测试类：

~~~java
package com.iweb.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test7 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        MyArithmetic2 ma = (MyArithmetic2) ac.getBean("myArithmetic2");
        int i = ma.add(1,2);
        System.out.println(i);
    }
}

~~~

### 通知类：

MethodBeforeAdvice ---- 前置通知

AfterReturningAdvice ---- 后置返回通知

添加后置返回通知：
MyBeforeAdvice.java

~~~java
package com.iweb.test;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName() +
                " start , get params: " + objects[0] + " and " + objects[1]);

    }
}

~~~

修改applicationContext.xml

~~~xml
    <aop:config>
        <aop:pointcut id="myPoint" expression="execution(* com.iweb.test.MyArithmetic2.*(..))"/>
        <aop:advisor advice-ref="myBeforeAdvice" pointcut-ref="myPoint"></aop:advisor>
        <aop:advisor advice-ref="myAfterAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>

    <bean id="myArithmetic2" class="com.iweb.test.MyArithmetic2"></bean>
    <bean id="myBeforeAdvice" class="com.iweb.test.MyBeforeAdvice"></bean>
    <bean id="myAfterAdvice" class="com.iweb.test.MyAfterAdvice"></bean>
~~~

### 使用注解的方式来完成AOP

1. 我们创建通知类，添加@Component和@Aspect注解，在通知类中添加@Before表示前置通知，切点表达式写在注解中
2. 在Spring容器中配置扫描器扫描通知类的包和业务逻辑包
3. 在Spring容器中添加`<aop:aspectj-autoproxy>`使得注解生效
4. 编写测试类完成测试

通知类的注解：

@Before("切点表达式") --- 前置注解

@After("切点表达式") --- 后置注解

@`AfterReturning(value="切点表达式"，returning="返回值变量名，例如：result")` ---- 后置返回通知
然后在方法中必须要有Object 类型的参数，参数名要和上面的一样
例如：`public void afterMethod(JoinPoint joinPoint,Object result)`

@After和@AfterReturning的区别：
如果程序报错（比如：除0），@After依旧会触发，@AfterReturning不会触发，因为没有返回值

MyArithmetic3.java

```java
package com.iweb.test2;


import org.springframework.stereotype.Component;

@Component
public class MyArithmetic3 {
//不带打印日志的语句

    public int add(int a,int b){

        int result = a + b;
        return result;
    }

    public int subtract(int a,int b){

        int result = a - b;
        return result;
    }


    public int multiply(int a,int b){

        int result = a * b;
        return result;
    }


    public int divide(int a,int b){

        int result = a / b;
        return result;
    }

}
```

前置通知：

```java
package com.iweb.test2;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyBeforeAdvice2 {


    @Before("execution(* com.iweb.test2.MyArithmetic3.*(..))")
    public void beforeMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();//获取切入的方法名
        Object[] args = joinPoint.getArgs();
        System.out.println(methodName + " start ,get params : " + args[0] + " and " + args[1]);
    }
}
```

测试：

```java
package com.iweb.test2;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test8 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        int result = ((MyArithmetic3) ac.getBean(MyArithmetic3.class)).subtract(30,2);
        System.out.println(result);

    }
}
```

applicationContext.xml

```xml
<context:component-scan base-package="com.iweb.test2"></context:component-scan>
<!-- 使aop注解生效 -->
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

后置通知：

```java
package com.iweb.test2;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAfteAdvice2 {


    @After("execution(* com.iweb.test2.MyArithmetic3.*(..))")
    public void afterMethod(JoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + " ends!");
    }
}
```

带返回值的后置通知：

```java
package com.iweb.test2;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAfteAdvice3 {


    @AfterReturning(value="execution(* com.iweb.test2.MyArithmetic3.*(..))",returning = "result")
    public void afterMethod(JoinPoint joinPoint,Object result){
        String methodName = joinPoint.getSignature().getName();

        System.out.println(methodName + " ends! result: " + result);


    }


}
```