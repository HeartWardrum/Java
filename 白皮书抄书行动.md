## 短路

短路的意思就是惰性运算，当符号左边的式子已经可以确认最后结果时，符号右边的式子就不进行计算了。

短路与是Java语言中的一个逻辑运算符，记作&&，与编程语言中的与（&）相似，但是具有短路性质：在使用&进行运算时，不论左边为true或者false，右边的表达式都会进行运算，而如果使用&&进行运算，当左边为false时，右边的表达式不会进行运算，因此&&被称为短路与。
短路或是Java语言中的一个逻辑运算符，记作||，与编程语言中的或（|）相似，但是具有短路性质：在使用|进行运算时，不论左边为true或者false，右边的表达式都会进行运算，而如果使用||进行运算，当左边为true时，右边的表达式不会进行运算，因此||被称为短路或。

## final 修饰的变量 究竟怎么不可变

引用变量不可变，引用变量指向的对象依然可变，即 对其初始化之后就不能再让它指向另一个变量

被final指定的实例变量必须显式地指定其初始值

## 接口中的默认方法

java 8 中允许接口中包含具有具体实现的方法，称为默认方法，用“default”关键词修饰

~~~java
public interface MyInterface {
    default String getMsg(String srcMsg){
        return "======"+srcMsg;
    }
}
~~~

接口中的默认方法，有一个**“类优先”**原则：

若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了同一个同名的方法时：

- 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称的参数的默认方法会被忽略。
- 接口冲突。如果一个父接口提供一个默认方法，而另一个接口中也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。


示例一：
~~~java
public interface MyInterface1 {
    default String getMsg(String srcMsg){
        return "===我是MyInterface1111111==="+srcMsg;
    }
}
///////////////////////////////////////////////////////
public class MyClass1 {
    public String getMsg(String srcMsg){
        return "===我是MyClass11111==="+srcMsg;
    }
}
///////////////////////////////////////////////////////
public class MySubClass1 extends MyClass1 implements MyInterface1 {
}

///////////////////////////////////////////////////////
public class InterfaceTest {

    public static void main(String[] args) {
        MySubClass1 ms1 = new MySubClass1();

        String srcMsg = "Java 牛逼！！";
        //MySubClass1 类继承了 MyClass1 类，实现了MyInterface1 接口，根据类优先原则，调用同名方法时，会忽略掉接口 MyInterface1 中的默认方法。
        System.out.println(ms1.getMsg(srcMsg));//输出结果：===我是MyClass11111===Java 牛逼！！

    }
}
~~~

示例二：
~~~java
public interface MyInterface2 {
    default String getMsg(String srcMsg){
        return "===我是MyInterface2222222==="+srcMsg;
    }
}
////////////////////////////////////////////////////////////////
public class MySubClass2 implements MyInterface1,MyInterface2 {
    @Override
    public String getMsg(String srcMsg) {
        //同时实现了 MyInterface1,MyInterface2  接口，根据 类优先 原则，两个父接口中都提供了相同的方法，那么子类中就必须重写这个方法来解决冲突。
        return MyInterface1.super.getMsg(srcMsg);
        //return MyInterface2.super.getMsg(srcMsg);
        //return "------"+srcMsg;
    }
}
////////////////////////////////////////////////////////////////
public class InterfaceTest {

    public static void main(String[] args) {
        MySubClass2 ms2 = new MySubClass2();

        //MySubClass2 重新实现了两个父接口中都存在的相同名称的方法。
        System.out.println(ms2.getMsg(srcMsg));//输出结果：===我是MyInterface1111111===Java 牛逼！！
    }
}
~~~

## 接口中的静态方法
在Java8中，接口中允许添加 静态方法，使用方式：“接口名.方法名”。
~~~java
public interface MyInterface3 {
    static String getMsg(String msg){
        return "我是接口中的静态方法："+msg;
    }

    static void main(String[] args) {
        System.out.println(MyInterface3.getMsg("Java牛逼！！"));
    }
}
~~~

