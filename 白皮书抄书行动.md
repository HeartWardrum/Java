## 短路

短路的意思就是惰性运算，当符号左边的式子已经可以确认最后结果时，符号右边的式子就不进行计算了。

短路与是Java语言中的一个逻辑运算符，记作&&，与编程语言中的与（&）相似，但是具有短路性质：在使用&进行运算时，不论左边为true或者false，右边的表达式都会进行运算，而如果使用&&进行运算，当左边为false时，右边的表达式不会进行运算，因此&&被称为短路与。
短路或是Java语言中的一个逻辑运算符，记作||，与编程语言中的或（|）相似，但是具有短路性质：在使用|进行运算时，不论左边为true或者false，右边的表达式都会进行运算，而如果使用||进行运算，当左边为true时，右边的表达式不会进行运算，因此||被称为短路或。

## final 修饰的变量 究竟怎么不可变

引用变量不可变，引用变量指向的对象依然可变，即 对其初始化之后就不能再让它指向另一个变量

被final指定的实例变量必须显式地指定其初始值

## 接口中的默认方法

java 8 中允许接口中包含具有具体实现的方法，称为默认方法，用“default”关键词修饰

~~~java
public interface MyInterface {
    default String getMsg(String srcMsg){
        return "======"+srcMsg;
    }
}
~~~

接口中的默认方法，有一个**“类优先”**原则：

若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了同一个同名的方法时：

- 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称的参数的默认方法会被忽略。
- 接口冲突。如果一个父接口提供一个默认方法，而另一个接口中也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。


示例一：
~~~java
public interface MyInterface1 {
    default String getMsg(String srcMsg){
        return "===我是MyInterface1111111==="+srcMsg;
    }
}
///////////////////////////////////////////////////////
public class MyClass1 {
    public String getMsg(String srcMsg){
        return "===我是MyClass11111==="+srcMsg;
    }
}
///////////////////////////////////////////////////////
public class MySubClass1 extends MyClass1 implements MyInterface1 {
}

///////////////////////////////////////////////////////
public class InterfaceTest {

    public static void main(String[] args) {
        MySubClass1 ms1 = new MySubClass1();

        String srcMsg = "Java 牛逼！！";
        //MySubClass1 类继承了 MyClass1 类，实现了MyInterface1 接口，根据类优先原则，调用同名方法时，会忽略掉接口 MyInterface1 中的默认方法。
        System.out.println(ms1.getMsg(srcMsg));//输出结果：===我是MyClass11111===Java 牛逼！！

    }
}
~~~

示例二：
~~~java
public interface MyInterface2 {
    default String getMsg(String srcMsg){
        return "===我是MyInterface2222222==="+srcMsg;
    }
}
////////////////////////////////////////////////////////////////
public class MySubClass2 implements MyInterface1,MyInterface2 {
    @Override
    public String getMsg(String srcMsg) {
        //同时实现了 MyInterface1,MyInterface2  接口，根据 类优先 原则，两个父接口中都提供了相同的方法，那么子类中就必须重写这个方法来解决冲突。
        return MyInterface1.super.getMsg(srcMsg);
        //return MyInterface2.super.getMsg(srcMsg);
        //return "------"+srcMsg;
    }
}
////////////////////////////////////////////////////////////////
public class InterfaceTest {

    public static void main(String[] args) {
        MySubClass2 ms2 = new MySubClass2();

        //MySubClass2 重新实现了两个父接口中都存在的相同名称的方法。
        System.out.println(ms2.getMsg(srcMsg));//输出结果：===我是MyInterface1111111===Java 牛逼！！
    }
}
~~~

## 接口中的静态方法
在Java8中，接口中允许添加 静态方法，使用方式：“接口名.方法名”。
~~~java
public interface MyInterface3 {
    static String getMsg(String msg){
        return "我是接口中的静态方法："+msg;
    }

    static void main(String[] args) {
        System.out.println(MyInterface3.getMsg("Java牛逼！！"));
    }
}
~~~

## 抽象类与接口

- 抽象类和接口的区别在于使用动机。使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性
  - 抽象方法只能放在抽象类中

- 抽象类和它的子类之间应该是一般和特殊的关系，而接口仅仅是它的子类应该实现的一组规则。
- 抽象类需要定义子类的行为，又要为子类提供通用的功能

**复用**：减少重复代码的书写

## 实例方法与类方法

类方法：static 修饰的方法
实例方法：由类创建的实例调用的方法
区别：
- 实例方法

## 各种变量
### 全局变量
又叫做成员变量
- 声明在类里、函数，静态语句块外
- 全局变量又分为**类变量(静态变量)**、**实例变量(对象变量)**两种
~~~java
private int i;//实例变量
private static int j;//类变量
~~~
#### 实例变量
实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。
存储在堆内存中
#### 类变量
而由static修饰的类变量在类装载的时候就会被初始化，也就是说由所有的对象公用，一处修改多处改变
可以直接使用类名调用，而且所有对象的同一个类变量都是共享同一块内存空间的
可以被类名调用
存储在方法区(共享数据区)的静态区
### 局部变量
方法内定义的变量叫作局部变量，只能在方法内部使用，不能用`private`,`public`,`protected`来修饰
#### 全局变量与局部变量的区别
##### 全局变量
1. 定义在类中，整个类中都可以访问
2. - 实例变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中
	- 类变量随着类的加载而存在...

3. 成员变量有默认初始化值
##### 局部变量
1. 局部变量只定义在局部范围内，如：函数内，语句内，只在所属的区域有效
2. 局部变量只存在于栈内存中，作用的范围结束，变量空间会自动释放
3. 局部变量没有默认初始化值

## 编译时多态和运行时多态
编译时多态：主要是方法的重载，通过参数列表的不同来区分不同的方法。

运行时多态：也叫作动态绑定，一般是指在执行期间（非编译期间）判断引用对象的实际类型，根据实际类型判断并调用相应的属性和方法。主要用于继承父类和实现接口时，父类引用指向子类对象。

