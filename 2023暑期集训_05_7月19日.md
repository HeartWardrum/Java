# 2023年7月9日

## Vector

它也是List接口的实现类，它的底层是数组，Vector和ArrayList的区别：

1. Vector线程同步，效率低，ArrayList线程不同步，效率高。
2. ArrayList底层数组扩容原理是每次扩1.5倍，Vector底层数组扩容原理是根据指定的扩容量来扩容，如果没有指定扩容量，则原数组长度翻倍

## LinkedList

它也是List接口的实现类，它的底层是链表

**数组和链表的比较**：

- 数组查询快，新增删除慢
- 链表查询慢，新增删除快

#### 手写的单向链表

~~~java
public interface List {

    public int size();

    public boolean isEmpty();

    public void add(Object o);

    public void add(int i, Object o);

    public Object get(int i);
}
~~~

~~~java
public class LinkedList implements List {

    Node head = new Node();//头节点
    int size;//当前集合中的元素个数


    public LinkedList() {
        this.size = 0;
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    @Override
    public void add(Object o) {
        this.add(size, o);
    }

    @Override
    public void add(int i, Object o) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        //找位置
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        //创建一个新节点
        Node newNode = new Node(o);
        //让新节点指向p本来指向的下一个节点
        newNode.setNext(p.next);
        //P指向新节点
        p.next = newNode;
        //元素个数加一
        this.size++;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        return p.getValue();
    }

    @Override
    public String toString() {
        StringBuffer s = new StringBuffer("[");
        Node p = head.next;
        for (int i = 0; i < size - 1; i++) {

            if (i != size - 1) {
                s.append(p.getValue() + ",");
            } else {
                s.append((p.getValue()));
            }
            p = p.next;
        }
        s.append("]");
        return s.toString();
    }
}

~~~

~~~java
public class Node {
    Object value;//当前节点的值
    Node next;//下一个节点

    public Node(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node() {
    }

    public Node(Object value, Node next) {
        this.value = value;
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", next=" + next +
                '}';
    }
}

~~~

~~~java
public class MyIndexOutOfBoundException extends RuntimeException {

    public MyIndexOutOfBoundException() {

    }

    public MyIndexOutOfBoundException(String message) {
        super(message);
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {

        List list = new LinkedList();
//        list.add(100);
//        list.add(200);
//        list.add(300);
//        list.add(400);
//        list.add(500);

        System.out.println(list);

    }
~~~



### java.util包中的LinkedList

它使用双向链表来实现

# 2023年7月20日

## 栈

这是一个容器，它的存取数据操作时是受限的。特点：先进先出，后进后出

栈的操作：

push ---- 入栈

pop ----  出栈

peek ---- 获取栈顶元素，但不出栈

## 队列

是个容器，存储数据操作时受限
特点：先进先出，后进后出，入队要从队尾入队，出队要从队首出队

队列的操作：

enqueue ---- 入队

dequeue ---- 出队

peek ---- 获取队首元素

## 双端队列

这也是一个容器，它的队尾和队首分别都可以入队和出队操作

- 如果把某一端限定了不能入队出队，则变成了一个栈
- 如果对某一段限定了只能入队，另一端只能出队，则变成了普通队列

在Java中，我们使用Deque标识一个双端队列，LinkedList是Deque的实现类，所以我们可以使用LinkedList表示一个双端队列，Deque接口是Queue接口的子接口，Qeueu表示队列

~~~java
//10进制转2进制
        System.out.println("请输入一个10进制整数：");
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        //String str = "";
        Deque deque = new LinkedList();
        do {
            int mod = n % 2;
            //str = mod + str;
            deque.push(mod);
            //System.out.println(mod);
            n /= 2;
        } while (n > 0);
        sc.close();
        while (!deque.isEmpty()) {
            System.out.print(deque.pop());
        }
~~~

## 树

这是一个集合，是一种在层级关系上定义的集合。一棵普通的树，根节点只有一个，往下有子节点，子节点往下还有子节点

节点的度：某个节点拥有子树的数目称为节点的度

树的度：一棵树中节点的度的最大值

叶子节点：度为0的节点

节点的层次：从当前节点开始是第一层，其子树是第二层，直到最深的叶子节点的层数

树的深度：树中节点的最大层次树

节点之间的关系：父亲，儿子，兄弟，堂兄弟

有序树：如果将树中的各个子树看成从左至右是有次序的，则称为有序树，如果不考虑顺序，则是无序树

m叉树：一棵树的任意一个节点，往下最多有几个分支就是几叉树。

森林：若干个互不相交的树的集合

二叉树：每个节点的度均不超过2的有序树

满二叉树：每一层的节点数都要达到最大数（除了叶子节点）的二叉树

完全二叉树：在满二叉树的基础上，最下层，从最右侧起，去掉若干相邻的子节点得到的二叉树

二叉树的性质：终端节点的数量 = 度为2的节点数量 + 1

二叉树的遍历：

- 先序：根左右（先遍历根节点，然后遍历左子树，最后遍历右子树）
- 中序：左根右
- 后序：左右根

### 例题：

已知：
中序： 4 5 1 3 2 6 7
后序： 5 4 3 7 6 2 1
求先序：
思路步骤：

1. 看后序，得到1是根
2. 看中序，得到45是左孩子，3267是右孩子
3. 看后序，得到4是1的左孩子

先序：1 4 5....

4. 看中序，得到5是4的右孩子
5. 看后序，得到2是1的右孩子

先序：1 4 5 2 ....

6. 看中序，得到3是2的左孩子，67是2的右孩子

先序：1 4 5 2 3 ...

7. 看后序，得到6是7的根节点，所以6是2的右孩子

先序：1 4 5 2 3 6 7

8. 看中序，得到7是6的右孩子

### 面试题

二叉树的遍历：给出中序，先序后序给一个求另一个，

解题思路：先看先序或者后序，得到根，再看中序，得到根的左孩子或右孩子，再依次轮换着看先序或者后序和中序，然后画出实际的二叉树

### 手写二叉树

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689918641/javaStudy/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E4%BE%8B_lnreur.png](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689918641/javaStudy/二叉树示例_lnreur.png)

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:23
 * @email 1208195222@qq.com
 * @description 二叉树的接口
 */
public interface BinaryTree {

    //判断是否是空树
    public boolean isEmpty();

    //求节点数量
    public int size();

    //获取二叉树的高度
    public int getHeight();

    //查询指定的节点
    public Node findKey(Object value);

    //先序遍历
    public void preOrderTraverse();

    //中序遍历
    public void inOrderTraverse();

    //非递归的中序遍历
    public void inOrderTraverseByStack();

    //后序遍历
    public void postOrderTraverse();

    //从指定的某个节点开始进行先序遍历
    public void preOrderTraverse(Node node);

    //从指定的某个节点开始进行中序遍历
    public void inOrderTraverse(Node node);

    //从指定的某个节点开始进行后序遍历
    public void postOrderTraverse(Node node);

    //按照层次遍历
    public void levelOrderByStack();
}
~~~

~~~java
package com.iweb.test;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Queue;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:28
 * @email 1208195222@qq.com
 * @description	二叉树接口的实现类
 */
public class LinkedBinaryTree implements BinaryTree {
    Node root;

    @Override
    public String toString() {
        return "LinkedBinaryTree{" +
                "root=" + root +
                '}';
    }


    public LinkedBinaryTree() {
    }

    public LinkedBinaryTree(Node root) {
        this.root = root;
    }

    @Override
    public boolean isEmpty() {
        return this.root == null;
    }

    @Override
    public int size() {
        return this.size(root);
    }

    public int size(Node node) {
        if (node == null) {
            return 0;
        } else {
            int leftSize = this.size(node.leftChild);
            int rightSize = this.size(node.rightChild);
            return leftSize + rightSize + 1;
        }
    }

    @Override
    public int getHeight() {
        return this.getHeight(root);

    }

    public int getHeight(Node node) {
        if (node == null) {
            return 0;
        } else {
            int leftHeight = this.getHeight(node.leftChild);
            int rightHeight = this.getHeight(node.rightChild);
            return leftHeight > rightHeight ? (leftHeight + 1) : (rightHeight + 1);
        }

    }

    @Override
    public Node findKey(Object value) {
        return this.findKey(value, root);
    }

    public Node findKey(Object value, Node node) {
        if (node == null) {
            return null;
        } else if (node.value == value) {
            return node;
        } else {
            Node node1 = this.findKey(value, node.leftChild);
            Node node2 = this.findKey(value, node.rightChild);
            if (node1 != null && node1.value == value) {
                return node1;
            } else if (node2 != null && node2.value == value) {
                return node2;
            }
            return null;
        }
    }

    @Override
    public void preOrderTraverse() {
        this.preOrderTraverse(root);
    }

    @Override
    public void preOrderTraverse(Node node) {
        if (node != null) {
            System.out.print(node.value + " ");
            this.preOrderTraverse(node.leftChild);
            this.preOrderTraverse(node.rightChild);
        }

    }

    @Override
    public void inOrderTraverse() {
        this.inOrderTraverse(root);
    }

    @Override
    public void inOrderTraverseByStack() {
        System.out.println("非递归的中序遍历");
        //创建栈
        Deque<Node> stack = new LinkedList<>();
        Node current = root;
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.isEmpty()) {
                current = stack.pop();
                System.out.print(current.value + " ");
                current = current.rightChild;
            }
        }
    }

    @Override
    public void inOrderTraverse(Node node) {
        if (node != null) {
            this.inOrderTraverse(node.leftChild);
            System.out.print(node.value + " ");
            this.inOrderTraverse(node.rightChild);
        }

    }

    @Override
    public void postOrderTraverse() {
        this.postOrderTraverse(root);
    }

    @Override
    public void postOrderTraverse(Node node) {
        if (node != null) {
            this.postOrderTraverse(node.leftChild);
            this.postOrderTraverse(node.rightChild);
            System.out.print(node.value + " ");
        }

    }

    @Override
    public void levelOrderByStack() {
        System.out.println("按照层次遍历二叉树");
        if (root == null) {
            return;
        } else {
            Queue<Node> queue = new LinkedList<>();
            queue.add(root);
            while (queue.size() != 0) {
                int len = queue.size();
                for (int i = 0; i < len; i++) {
                    Node temp = queue.poll();
                    System.out.print(temp.value + " ");
                    if (temp.leftChild != null) {
                        queue.add(temp.leftChild);
                    }
                    if (temp.rightChild != null) {
                        queue.add(temp.rightChild);
                    }
                }
            }
        }
    }
}

~~~



~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/20 11:21
 * @email 1208195222@qq.com
 * @description     节点类
 */
public class Node {

    Object value;//自己的值
    Node leftChild;//左孩子地址
    Node rightChild;


    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", leftChild=" + leftChild +
                ", rightChild=" + rightChild +
                '}';
    }

    public Node() {
    }

    public Node(Object value, Node leftChild, Node rightChild) {
        this.value = value;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }
}

~~~

~~~java
package com.iweb.test;

/**
 * @author 童 淏
 * @createTime 2023/07/21 9:01
 * @email 1208195222@qq.com
 * @description		测试lei
 */
public class Test2 {

    public static void main(String[] args) {
        Node node5 = new Node(5, null, null);
        Node node4 = new Node(4, null, node5);

        Node node7 = new Node(7, null, null);
        Node node6 = new Node(6, null, node7);

        Node node3 = new Node(3, null, null);
        Node node2 = new Node(2, node3, node6);

        Node node1 = new Node(1, node4, node2);

        LinkedBinaryTree lbt = new LinkedBinaryTree(node1);

        System.out.println(lbt);
        System.out.println(lbt.isEmpty());
        LinkedBinaryTree lbt2 = new LinkedBinaryTree();
        System.out.println(lbt2.isEmpty());

        System.out.println("先序遍历：");
        lbt.preOrderTraverse();
        System.out.println();
        System.out.println("中序遍历：");
        lbt.inOrderTraverse();
        System.out.println();
        System.out.println("后序遍历：");
        lbt.postOrderTraverse();
        System.out.println();
        System.out.println("树的深度：");
        System.out.println("height:" + lbt.getHeight());
        System.out.println("节点的个数：");
        System.out.print(lbt.size());
        System.out.println();
        System.out.println("在二叉树中查找");
        System.out.println(lbt.findKey(1));
        System.out.println();
        System.out.println("层次遍历：");
        lbt.levelOrderByStack();
        System.out.println();
        System.out.println("中序非递归遍历");
        lbt.inOrderTraverseByStack();

    }
}
~~~





## 递归算法

在一个方法的内部调用当前方法本身，它可以将一个复杂的问题层层转化为一个个相似的小问题来求解，**注意**：在写递归的时候必须要有结束调用的条件，否则就会出现栈内存溢出的错误。

~~~java
//求1加到100
    public static void main(String[] args) {

        System.out.println(myMethod(1));
    }

    public static int myMethod(int i) {
        int sum = 0;
        if (1 == i)
            return 1;
        else
            sum = i + myMethod(i - 1);
        return sum;

    }
//用高斯公式
    public static void main(String[] args) {
        System.out.println((1 + 100) * 100 / 2);
    }
~~~

## druid配置信息

写在application.propertie

~~~properties
server.port=8088

spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.url=jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8
spring.datasource.username=root
spring.datasource.password=123456
~~~

MySQL的URL要背下来：`jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8`

## 常用注解

@RestController ---- 这实际上包含了@ResponseBody 和 @Controller两个注解

@ResponseBody ---- 表示返回的数据直接以Json格式的字符串来表示

@Controller ---- 表示这是一个控制器，它能够接收请求，并且由Spring自动创建该类对象

@RequestMapping ---- 表示定义一个请求名，当接收到该请求名的请求时，触发代码执行

@Autowired ---- 需要使用某个对象的时候，无需自己创建，由Spring容器直接推送

@Service ---- 表示这是一个业务逻辑主键，也可以由Spring自动创建该类对象

@Mapper ---- 这是一个MyBatis注解，它可以自动创建该接口的实现类并创建实现类对象，然后自动调用对应的方法去执行对应的SQL语句

@RequestParam ---- 接收请求参数并赋值该控制器方法的形参

@ModelAttribute ---- 将请求参数中的参数值赋给控制器方法形参对象的成员变量，并将该形参对象绑定到Model中

@GetMapping ---- 在控制器方法上接收get请求：用于查询

@PostMaping ---- 在控制器方法上接收Post请求：用于新增

@PutMapping ---- 在控制器方法上接收Put请求：用于修改

@DeleteMapping ---- 在控制器方法上接收Delete请求：用于删除





在地址栏按回车键，发送的是get请求

