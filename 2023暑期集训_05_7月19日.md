# 2023年7月9日

## Vector

它也是List接口的实现类，它的底层是数组，Vector和ArrayList的区别：

1. Vector线程同步，效率低，ArrayList线程不同步，效率高。
2. ArrayList底层数组扩容原理是每次扩1.5倍，Vector底层数组扩容原理是根据指定的扩容量来扩容，如果没有指定扩容量，则原数组长度翻倍

## LinkedList

它也是List接口的实现类，它的底层是链表

**数组和链表的比较**：

- 数组查询快，新增删除慢
- 链表查询慢，新增删除快

#### 手写的单向链表

~~~java
public interface List {

    public int size();

    public boolean isEmpty();

    public void add(Object o);

    public void add(int i, Object o);

    public Object get(int i);
}
~~~

~~~java
public class LinkedList implements List {

    Node head = new Node();//头节点
    int size;//当前集合中的元素个数


    public LinkedList() {
        this.size = 0;
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    @Override
    public void add(Object o) {
        this.add(size, o);
    }

    @Override
    public void add(int i, Object o) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        //找位置
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        //创建一个新节点
        Node newNode = new Node(o);
        //让新节点指向p本来指向的下一个节点
        newNode.setNext(p.next);
        //P指向新节点
        p.next = newNode;
        //元素个数加一
        this.size++;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        return p.getValue();
    }

    @Override
    public String toString() {
        StringBuffer s = new StringBuffer("[");
        Node p = head.next;
        for (int i = 0; i < size - 1; i++) {

            if (i != size - 1) {
                s.append(p.getValue() + ",");
            } else {
                s.append((p.getValue()));
            }
            p = p.next;
        }
        s.append("]");
        return s.toString();
    }
}

~~~

~~~java
public class Node {
    Object value;//当前节点的值
    Node next;//下一个节点

    public Node(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node() {
    }

    public Node(Object value, Node next) {
        this.value = value;
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", next=" + next +
                '}';
    }
}

~~~

~~~java
public class MyIndexOutOfBoundException extends RuntimeException {

    public MyIndexOutOfBoundException() {

    }

    public MyIndexOutOfBoundException(String message) {
        super(message);
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {

        List list = new LinkedList();
//        list.add(100);
//        list.add(200);
//        list.add(300);
//        list.add(400);
//        list.add(500);

        System.out.println(list);

    }
~~~



### java.util包中的LinkedList

它使用双向链表来实现

# 2023年7月20日

## 栈

这是一个容器，它的存取数据操作时是受限的。特点：先进先出，后进后出

栈的操作：

push ---- 入栈

pop ----  出栈

peek ---- 获取栈顶元素，但不出栈

## 队列

是个容器，存储数据操作时受限
特点：先进先出，后进后出，入队要从队尾入队，出队要从队首出队

队列的操作：

enqueue ---- 入队

dequeue ---- 出队

peek ---- 获取队首元素

## 双端队列

这也是一个容器，它的队尾和队首分别都可以入队和出队操作

- 如果把某一端限定了不能入队出队，则变成了一个栈
- 如果对某一段限定了只能入队，另一端只能出队，则变成了普通队列

在Java中，我们使用Deque标识一个双端队列，LinkedList是Deque的实现类，所以我们可以使用LinkedList表示一个双端队列，Deque接口是Queue接口的子接口，Qeueu表示队列

~~~java
//10进制转2进制
        System.out.println("请输入一个10进制整数：");
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        //String str = "";
        Deque deque = new LinkedList();
        do {
            int mod = n % 2;
            //str = mod + str;
            deque.push(mod);
            //System.out.println(mod);
            n /= 2;
        } while (n > 0);
        sc.close();
        while (!deque.isEmpty()) {
            System.out.print(deque.pop());
        }
~~~

## 树

这是一个集合，是一种在层级关系上定义的集合。一棵普通的树，根节点只有一个，往下有子节点，子节点往下还有子节点

节点的度：某个节点拥有子树的数目称为节点的度

树的度：一棵树中节点的度的最大值

叶子节点：度为0的节点

节点的层次：从当前节点开始是第一层，其子树是第二层，直到最深的叶子节点的层数

树的深度：树中节点的最大层次树

节点之间的关系：父亲，儿子，兄弟，堂兄弟

有序树：如果将树中的各个子树看成从左至右是有次序的，则称为有序树，如果不考虑顺序，则是无序树

m叉树：一棵树的任意一个节点，往下最多有几个分支就是几叉树。

森林：若干个互不相交的树的集合

二叉树：每个节点的度均不超过2的有序树

满二叉树：每一层的节点数都要达到最大数（除了叶子节点）的二叉树

完全二叉树：在满二叉树的基础上，最下层，从最右侧起，去掉若干相邻的子节点得到的二叉树

二叉树的性质：终端节点的数量 = 度为2的节点数量 + 1

二叉树的遍历：

- 先序：根左右（先遍历根节点，然后遍历左子树，最后遍历右子树）
- 中序：左根右
- 后序：左右根

### 例题：

已知：
中序： 4 5 1 3 2 6 7
后序： 5 4 3 7 6 2 1
求先序：
思路步骤：

1. 看后序，得到1是根
2. 看中序，得到45是左孩子，3267是右孩子
3. 看后序，得到4是1的左孩子

先序：1 4 5....

4. 看中序，得到5是4的右孩子
5. 看后序，得到2是1的右孩子

先序：1 4 5 2 ....

6. 看中序，得到3是2的左孩子，67是2的右孩子

先序：1 4 5 2 3 ...

7. 看后序，得到6是7的根节点，所以6是2的右孩子

先序：1 4 5 2 3 6 7

8. 看中序，得到7是6的右孩子

### 面试题

二叉树的遍历：给出中序，先序后序给一个求另一个，

解题思路：先看先序或者后序，得到根，再看中序，得到根的左孩子或右孩子，再依次轮换着看先序或者后序和中序，然后画出实际的二叉树

## 递归算法

在一个方法的内部调用当前方法本身，它可以将一个复杂的问题层层转化为一个个相似的小问题来求解，**注意**：在写递归的时候必须要有结束调用的条件，否则就会出现栈内存溢出的错误。

~~~java
//求1加到100
    public static void main(String[] args) {

        System.out.println(myMethod(1));
    }

    public static int myMethod(int i) {
        int sum = 0;
        if (1 == i)
            return 1;
        else
            sum = i + myMethod(i - 1);
        return sum;

    }
//用高斯公式
    public static void main(String[] args) {
        System.out.println((1 + 100) * 100 / 2);
    }
~~~

## druid配置信息

写在application.propertie

~~~properties
server.port=8088

spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.url=jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8
spring.datasource.username=root
spring.datasource.password=123456
~~~







