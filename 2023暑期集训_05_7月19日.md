# 2023年7月9日

## Vector

它也是List接口的实现类，它的底层是数组，Vector和ArrayList的区别：

1. Vector线程同步，效率低，ArrayList线程不同步，效率高。
2. ArrayList底层数组扩容原理是每次扩1.5倍，Vector底层数组扩容原理是根据指定的扩容量来扩容，如果没有指定扩容量，则原数组长度翻倍

## LinkedList

它也是List接口的实现类，它的底层是链表

**数组和链表的比较**：

- 数组查询快，新增删除慢
- 链表查询慢，新增删除快

#### 手写的单向链表

~~~java
public interface List {

    public int size();

    public boolean isEmpty();

    public void add(Object o);

    public void add(int i, Object o);

    public Object get(int i);
}
~~~

~~~java
public class LinkedList implements List {

    Node head = new Node();//头节点
    int size;//当前集合中的元素个数


    public LinkedList() {
        this.size = 0;
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public boolean isEmpty() {
        return 0 == this.size;
    }

    @Override
    public void add(Object o) {
        this.add(size, o);
    }

    @Override
    public void add(int i, Object o) {
        if (i < 0 || i > size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        //找位置
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        //创建一个新节点
        Node newNode = new Node(o);
        //让新节点指向p本来指向的下一个节点
        newNode.setNext(p.next);
        //P指向新节点
        p.next = newNode;
        //元素个数加一
        this.size++;
    }

    @Override
    public Object get(int i) {
        if (i < 0 || i >= size) {
            throw new MyIndexOutOfBoundException("对不起，下标越界");
        }
        Node p = head;
        for (int j = 0; j < i; j++) {
            p = p.next;
        }
        return p.getValue();
    }

    @Override
    public String toString() {
        StringBuffer s = new StringBuffer("[");
        Node p = head.next;
        for (int i = 0; i < size - 1; i++) {

            if (i != size - 1) {
                s.append(p.getValue() + ",");
            } else {
                s.append((p.getValue()));
            }
            p = p.next;
        }
        s.append("]");
        return s.toString();
    }
}

~~~

~~~java
public class Node {
    Object value;//当前节点的值
    Node next;//下一个节点

    public Node(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public Node() {
    }

    public Node(Object value, Node next) {
        this.value = value;
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", next=" + next +
                '}';
    }
}

~~~

~~~java
public class MyIndexOutOfBoundException extends RuntimeException {

    public MyIndexOutOfBoundException() {

    }

    public MyIndexOutOfBoundException(String message) {
        super(message);
    }
}

~~~

~~~java
public class Test {

    public static void main(String[] args) {

        List list = new LinkedList();
//        list.add(100);
//        list.add(200);
//        list.add(300);
//        list.add(400);
//        list.add(500);

        System.out.println(list);

    }
~~~



### java.util包中的LinkedList

它使用双向链表来实现