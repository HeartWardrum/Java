# 2023年8月10日

## EL

使用${} 表示EL表达式

它可以从域对象中取值，格式：

${xxxScope.键} ---- 根据键获取对应值

~~~jsp
<body>
我是测试页面
<%
    pageContext.setAttribute("key01", "value01");
    request.setAttribute("key02", "value02");
    session.setAttribute("key03", "value03");
    application.setAttribute("key04", "value04");

%>
<br/>
${pageScope.key01};
<br/>
${requestScope.key02};
<br/>
${sessionScope.key03};
<br/>
${applicationScope.key04};

</body>
~~~

getAttribute方法后面的小数点全部都是get方法

例如：`${pageScope.key01.bookname};`中，第一个小数点相当于getAttribute方法，第二个小数点相当于get方法

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    pageContext.setAttribute("key01", book);
    request.setAttribute("key02", book);
    session.setAttribute("key03", book);
    application.setAttribute("key04", book);

%>
<br/>
${pageScope.key01.bookname};
<br/>
${requestScope.key02.id};
<br/>
${sessionScope.key03.author};
<br/>
${applicationScope.key04.bookname};

</body>
~~~

xxxScope可以省略不写，如果不写，则按照与对象取值范围从小到大的顺序依次寻找，找到为止

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    Book book2 = new Book(1001, "许三观卖血记", "余华");


    pageContext.setAttribute("key01", book);
    request.setAttribute("key01", book2);

%>
<br/>
${key01.bookname};

</body>
~~~

打印结果：

~~~jsp
活着
~~~

**注意**： `${pageContext.request.contextPath}`表示web应用根目录

扩展用法：

1. 当字符串中自带 . 时
   ~~~jsp
   ${requestScope["com.iweb.test"]}
   ~~~

2. ${param.参数}

## JSTL

JavaServer Pages Standard Tag Library

这是JSP标准标签库，它和EL表达式搭配，可以简化页面开发

操作步骤：

1、下载依赖
2、使用<%@taglib %>导入JSTL
3、使用<c:>标签来完成各种功能

例如：

~~~jsp
<c:forEach>表示循环遍历一个域对象中的集合</c:forEach>
item属性表示域对象的key,var属性表示定义用来循环的变量

      <c:forEach items="${books}" var="book">
          <tr>
              <td>${book.id}</td>
              <td>${book.bookname}</td>
              <td>${book.author}</td>
              <td><a href="<%=request.getContextPath()%>/toEdit.book?id=${book.id}">Edit</a></td>
              <td><a class="del" href="<%=request.getContextPath()%>/delete.book?id=${book.id}">Delete</a></td>
          </tr>
      </c:forEach>

~~~

~~~jsp
<c:redirect>重定向到某个页面</c:redirect>
例如：
<c:redirect url="/user/login.jsp"></c:redirect>
原版JSP代码：
<jsp:forward page="/user/login.jsp" />
效果相同
~~~

~~~jsp
<c:import>导入某个页面到当前页面中，可以是当前web应用以内或以外的资源</c:import>
例如：
<c:import url="http://www.baidu.com" charEncoding="utf-8"></c:import> <!--导入了百度-->
~~~

## Cookie

这是存放在浏览器电脑上的小文本文件，它对应服务器上的一个Cookie类的对象，当浏览器第一次向服务器发送请求时，由服务器创建Cookie对象，随响应带回浏览器，然后浏览器将其保存为文本文件，下一次再发请求时，浏览器会自动携带该Cookie文件去往服务器，服务器会自动比对确认两次请求来自同一个浏览器。

~~~jsp
<body>

<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

Cookie中携带的时键值对

默认Cookie中携带的一个键叫做JSESSIONID，值是一个16进制数的键值对，它表示当前这个会话

~~~jsp
<body>
<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
        }
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

我们可以通过new Cookie(键，值)来创建一个自己的Cookie对象，然后通过response，addCookie(Cookie对象)将cookie对象绑定到response中带回浏览器

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        response.addCookie(cookie);
    }
%>
</body>
~~~

Cookie默认都是会话级别，它会随浏览器的关闭而消失

我们可以将其设置为持久级别：

使用Cookie对象的setMaxAge(秒数)表示当前cookie对象存活的时间，它不会受到当前会话的影响。

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        cookie.setMaxAge(30);//设置存活时间之后，就成为了持久层cookie
        response.addCookie(cookie);
    }
%>
</body>
~~~

如果使用cookie.setMaxAge(0) ---- 表示立即删除

如果秒数为负数，例如：`cookie.setMaxAge(-1312312)`，则相当于这句话没写

~~~jsp
<%
    String username = request.getParameter("username");
    if (username == null) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (int i = 0; i < cookies.length; i++) {
                if ("username".equals(cookies[i].getName())) {
                    username = cookies[i].getValue();
                }
            }
        }
    }else{
        Cookie cookie = new Cookie("username",username);
        cookie.setMaxAge(30);
        response.addCookie(cookie);
    }
    if(username == null){
        response.sendRedirect(request.getContextPath() + "/user/login.jsp");
    }
%>
~~~

# 2023年8月11日

## Session

HttpSession类的对象，表示当前会话

getId() ---- 获取当前会话的JSESSIONID

isNew() ---- 判断当前会话是否是新的会话

getCreationTime() ---- 获取当前会话的创建时间

getLastAccessedTime() ---- 获取当前会话中上次请求的时间

getMaxInactiveInterval() ---- 获取使当前会话失效的两次请求的间隔时间

~~~jsp

<body>
<h3>test3页面</h3>
<%=session.getId()%>
<br/>
<%=session.isNew()%>
<br/>
<%=session.getCreationTime()%>
<br/>
<%=session.getLastAccessedTime()%>
<br/>
<%=session.getMaxInactiveInterval()%>
</body>
~~~

session.invalidate(); ---- 使当前会话立即失效

### Session的应用

在单点项目中：

1. 使用Session来存放用户的登录信息
2. 用来防止重复提交

### 重复提交

1. 连续点击提交按钮
2. 点击“提交”后转发到成功页面，刷新该页面，也是重复提交
3. 点击“提交”后，请求转发到成功页面，点击“后退”，再点击提交，也是重复提交

**不是重复提交**：如果点击“提交”后，请求转发到成功页面，点击“后退”，再点击刷新，再点击“刷新”则不是重复提交

