# 2023年8月10日

## EL

使用${} 表示EL表达式

它可以从域对象中取值，格式：

${xxxScope.键} ---- 根据键获取对应值

~~~jsp
<body>
我是测试页面
<%
    pageContext.setAttribute("key01", "value01");
    request.setAttribute("key02", "value02");
    session.setAttribute("key03", "value03");
    application.setAttribute("key04", "value04");

%>
<br/>
${pageScope.key01};
<br/>
${requestScope.key02};
<br/>
${sessionScope.key03};
<br/>
${applicationScope.key04};

</body>
~~~

getAttribute方法后面的小数点全部都是get方法

例如：`${pageScope.key01.bookname};`中，第一个小数点相当于getAttribute方法，第二个小数点相当于get方法

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    pageContext.setAttribute("key01", book);
    request.setAttribute("key02", book);
    session.setAttribute("key03", book);
    application.setAttribute("key04", book);

%>
<br/>
${pageScope.key01.bookname};
<br/>
${requestScope.key02.id};
<br/>
${sessionScope.key03.author};
<br/>
${applicationScope.key04.bookname};

</body>
~~~

xxxScope可以省略不写，如果不写，则按照与对象取值范围从小到大的顺序依次寻找，找到为止

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    Book book2 = new Book(1001, "许三观卖血记", "余华");


    pageContext.setAttribute("key01", book);
    request.setAttribute("key01", book2);

%>
<br/>
${key01.bookname};

</body>
~~~

打印结果：

~~~jsp
活着
~~~

**注意**： `${pageContext.request.contextPath}`表示web应用根目录

扩展用法：

1. 当字符串中自带 . 时
   ~~~jsp
   ${requestScope["com.iweb.test"]}
   ~~~

2. ${param.参数}

## JSTL

JavaServer Pages Standard Tag Library

这是JSP标准标签库，它和EL表达式搭配，可以简化页面开发

操作步骤：

1、下载依赖
2、使用<%@taglib %>导入JSTL
3、使用<c:>标签来完成各种功能

例如：

~~~jsp
<c:forEach>表示循环遍历一个域对象中的集合</c:forEach>
item属性表示域对象的key,var属性表示定义用来循环的变量

      <c:forEach items="${books}" var="book">
          <tr>
              <td>${book.id}</td>
              <td>${book.bookname}</td>
              <td>${book.author}</td>
              <td><a href="<%=request.getContextPath()%>/toEdit.book?id=${book.id}">Edit</a></td>
              <td><a class="del" href="<%=request.getContextPath()%>/delete.book?id=${book.id}">Delete</a></td>
          </tr>
      </c:forEach>

~~~

~~~jsp
<c:redirect>重定向到某个页面</c:redirect>
例如：
<c:redirect url="/user/login.jsp"></c:redirect>
原版JSP代码：
<jsp:forward page="/user/login.jsp" />
效果相同
~~~

~~~jsp
<c:import>导入某个页面到当前页面中，可以是当前web应用以内或以外的资源</c:import>
例如：
<c:import url="http://www.baidu.com" charEncoding="utf-8"></c:import> <!--导入了百度-->
~~~

## Cookie

这是存放在浏览器电脑上的小文本文件，它对应服务器上的一个Cookie类的对象，当浏览器第一次向服务器发送请求时，由服务器创建Cookie对象，随响应带回浏览器，然后浏览器将其保存为文本文件，下一次再发请求时，浏览器会自动携带该Cookie文件去往服务器，服务器会自动比对确认两次请求来自同一个浏览器。

~~~jsp
<body>

<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

Cookie中携带的时键值对

默认Cookie中携带的一个键叫做JSESSIONID，值是一个16进制数的键值对，它表示当前这个会话

~~~jsp
<body>
<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
        }
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

我们可以通过new Cookie(键，值)来创建一个自己的Cookie对象，然后通过response，addCookie(Cookie对象)将cookie对象绑定到response中带回浏览器

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        response.addCookie(cookie);
    }
%>
</body>
~~~

Cookie默认都是会话级别，它会随浏览器的关闭而消失

我们可以将其设置为持久级别：

使用Cookie对象的setMaxAge(秒数)表示当前cookie对象存活的时间，它不会受到当前会话的影响。

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        cookie.setMaxAge(30);//设置存活时间之后，就成为了持久层cookie
        response.addCookie(cookie);
    }
%>
</body>
~~~

如果使用cookie.setMaxAge(0) ---- 表示立即删除

如果秒数为负数，例如：`cookie.setMaxAge(-1312312)`，则相当于这句话没写

~~~jsp
<%
    String username = request.getParameter("username");
    if (username == null) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (int i = 0; i < cookies.length; i++) {
                if ("username".equals(cookies[i].getName())) {
                    username = cookies[i].getValue();
                }
            }
        }
    }else{
        Cookie cookie = new Cookie("username",username);
        cookie.setMaxAge(30);
        response.addCookie(cookie);
    }
    if(username == null){
        response.sendRedirect(request.getContextPath() + "/user/login.jsp");
    }
%>
~~~

# 2023年8月11日

## Session

HttpSession类的对象，表示当前会话

getId() ---- 获取当前会话的JSESSIONID

isNew() ---- 判断当前会话是否是新的会话

getCreationTime() ---- 获取当前会话的创建时间

getLastAccessedTime() ---- 获取当前会话中上次请求的时间

getMaxInactiveInterval() ---- 获取使当前会话失效的两次请求的间隔时间

~~~jsp

<body>
<h3>test3页面</h3>
<%=session.getId()%>
<br/>
<%=session.isNew()%>
<br/>
<%=session.getCreationTime()%>
<br/>
<%=session.getLastAccessedTime()%>
<br/>
<%=session.getMaxInactiveInterval()%>
</body>
~~~

session.invalidate(); ---- 使当前会话立即失效

### Session的应用

在单点项目中：

1. 使用Session来存放用户的登录信息
2. 用来防止重复提交

### 重复提交

1. 连续点击提交按钮
2. 点击“提交”后转发到成功页面，刷新该页面，也是重复提交
3. 点击“提交”后，请求转发到成功页面，点击“后退”，再点击提交，也是重复提交

**不是重复提交**：如果点击“提交”后，请求转发到成功页面，点击“后退”，再点击刷新，再点击“刷新”则不是重复提交

## AJAX

Asynchronous JavaScript and XML

偷偷摸摸发请求的技术

无需刷新页面而使得前后端通信的一种技术

### 原生态的AJAX

原生态的AJAX是围绕一个叫做XMLHttpRequest的对象展开，该对象包括以下方法：

open(请求方式，url) ---- 装载请求

send() ---- 发送请求

当请求被发送，会调用onreadystatechange方法

在该方法中，我们通常判断readyState属性来了解发送的状态：0表示初始化，1表示正在加载，2表示已经加载，3表示交互中，4表示完成

当该属性值为4时，表示响应已经返回，这时我们还需要判断http协议的状态码，200表示成功，304表示没有改变

这时，我们可以通过responseText得到后端的返回值，进行页面的局部更新

~~~jsp
    <script type="text/javascript">
        window.onload = function () {
            var strNode = document.getElementById("str");
            strNode.onkeyup = function () {
                var request = new XMLHttpRequest();//定义一个AJAX的核心对象
                var method = "GET";
                var url = "<%=request.getContextPath()%>/test6";
                request.open(method, url);//装载
                request.send(null);
                request.onreadystatechange = function () {
                    if (request.readyState == 4) {
                        if (request.status == 200 || request.status == 304) {
                            var resp = request.responseText;
                            document.getElementById("message").innerHTML=resp;
                        }
                    }
                }
            }
        }
    </script>
~~~

~~~java
public class HelloAJAX extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        System.out.println("来了个请求");
        resp.getWriter().print("你好，这是我给你的返回值");
    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>test6</servlet-name>
        <servlet-class>com.iweb.test.HelloAJAX</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>test6</servlet-name>
        <url-pattern>/test6</url-pattern>
    </servlet-mapping>
~~~

ChatGPT：

~~~jsp
这段 JavaScript 代码是一个用于实现 AJAX 功能的示例。它的主要作用是在用户在输入框中输入内容时，通过 AJAX 向服务器发送请求并接收响应，然后将响应的内容更新到页面上。

以下是逐行解释代码的各部分：

1. `window.onload = function () { ... }`：当整个页面加载完毕后，执行包含在这个函数中的代码。

2. `var strNode = document.getElementById("str");`：获取具有 id 为 "str" 的 HTML 元素，通常是一个输入框元素。

3. `strNode.onkeyup = function () { ... }`：当用户在输入框中松开键盘按键时，执行包含在这个函数中的代码。

4. `var request = new XMLHttpRequest();`：创建一个 XMLHttpRequest 对象，用于发送和接收数据。

5. `var method = "GET";`：设置请求的方法为 "GET"，即向服务器获取数据。

6. `var url = "<%=request.getContextPath()%>/test6";`：构建请求的 URL，其中 `<%=request.getContextPath()%>` 用于获取当前 Web 应用的上下文路径。`/test6` 是服务器上处理这个请求的路径。

7. `request.open(method, url);`：配置 XMLHttpRequest 对象，指定请求的方法和 URL。

8. `request.send(null);`：发送请求。在这个示例中，请求没有发送额外的数据，因此参数为 `null`。

9. `request.onreadystatechange = function () { ... }`：设置一个回调函数，在状态改变时进行处理。

10. `if (request.readyState == 4) { ... }`：当请求状态变为 4，表示请求已完成。

11. `if (request.status == 200 || request.status == 304) { ... }`：当响应状态码为 200（成功）或 304（未修改）时，表示请求成功。

12. `var resp = request.responseText;`：获取响应的文本内容。

13. `document.getElementById("message").innerHTML=resp;`：将响应的文本内容更新到 id 为 "message" 的 HTML 元素中，从而在页面上显示。

总之，这段代码展示了如何使用原生 JavaScript 和 XMLHttpRequest 对象来实现一个简单的 AJAX 请求，以及如何将服务器响应的内容更新到页面上。
~~~



**修改版**

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function () {
            var strNode = document.getElementById("str");
            strNode.onkeyup = function () {
                var strvalue = this.value;
                var request = new XMLHttpRequest();//定义一个AJAX的核心对象
                var method = "GET";
                var url = "<%=request.getContextPath()%>/test6?str=" + strvalue;
                request.open(method, url);//装载
                request.send(null);
                request.onreadystatechange = function () {
                    if (request.readyState == 4) {
                        if (request.status == 200 || request.status == 304) {
                            var resp = request.responseText;
                            document.getElementById("message").innerHTML=resp;
                        }
                    }
                }
            }

        }
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

~~~java
public class HelloAJAX extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        String str = req.getParameter("str");
        System.out.println("来了个请求");
        resp.getWriter().print("你好，这是我给你的返回值" + str);
        //test the second git repository
    }
}
~~~

## JSON

这是一个数据格式，以`{`开头，以`}`结尾，中间是键值对，键值对的键和值以冒号分割，键值对之间以逗号分割，一般来讲，键都是字符串，值是任意类型

在JS中，JSON数据是以JSON对象的形式存在的

~~~jsp
    <script type="text/javascript">
        window.onload = function () {
            var jsonObj = {
                "name": "iweb",
                "age": 10,
                "address": {
                    "city": "Nanjing",
                    "school": "南信大"
                }
            };
            alert(jsonObj.name);
            alert(jsonObj.address.school);

        }
    </script>
~~~

### JSON字符串转JSON对象

1、eval函数 ---- 可以将字符串中的js代码解析出来

~~~javascript
            var str = "alert(\"hello\");";
            eval(str);
~~~

**注意**：如果是JSON字符串，那么eval函数中的字符串左右两边需要添加左小括号和右小括号

~~~JavaScript
            var str2 = "{\"name\":\"iweb\"}";
            var jsonObj2 = eval("(" +str2+")");
            alert(jsonObj2.name);
~~~

2、JSON.parse(JSON字符串)； ---- 直接转json对象

~~~JavaScript
            var str3= "{\"name\":\"iweb\"}";
            var jsonObj3 = JSON.parse(str3);
            alert(jsonObj3.name);
~~~

## jQuery提供的AJAX相关方法

1、load(url) ---- 某控件调用该方法，发起AJAX请求，返回值直接回填到该控件中

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $("#message").load(url);
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

后端servlet还有XML和AJAX那时候一样

**注意**：load方法如果传入一个url参数，则表示发送get请求，如果传入一个url参数和另一个JSON格式的请求参数，则发送POST请求

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $("#message").load(url, jsonObj);//post请求
                //$("#message").load(url);//get请求
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

2、$.get(url，参数，回调方法) ---- 发起一个get请求

3、$.post(url，参数，回调方法) ---- 发起一个post请求

**注意**：回调方法的参数自由定义，它表示后端返回的字符串

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $.get(url,jsonObj,function(data){
                   $("#message").html(data);
                });
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

#### 简单的用户名重复性校验

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").change(function () {
                var param = $("#str").val();
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $.post(url, jsonObj, function (data) {
                    var resultObj = JSON.parse(data);
                    if (resultObj.flag == 1) {
                        $("#message").css("color", "green").html("恭喜您，该用户名可以使用");
                    } else {
                        $("#message").css("color", "red").html("对不起，该用户名已存在");
                    }
                });
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message"></span>
</body>
</html>

~~~

~~~java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        List<String> list = new ArrayList<>();
        list.add("Tom");
        list.add("Jerry");
        String result = "";
        String str = req.getParameter("str");
        if (list.contains(str)) {
            result = "{\"flag\":0}";
        } else {
            result = "{\"flag\":1}";
        }
        System.out.println("来了个POST请求");
        resp.getWriter().print(result);
    }
~~~

