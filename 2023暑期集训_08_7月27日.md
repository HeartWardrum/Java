# 2023年7月27日



## Method类

表示加载类的方法，每个方法在反射看来都是一个Method对象，我们可以使用Class对象调用getMethod(方法名)来获取Method对象，然后使用Method对象.invoke(加载类对象)来完成加载类方法的调用。

~~~java
            Method m1= c1.getMethod("info");
            m1.invoke(p1);
~~~

如果方法带有参数，那么在获取Method对象时，我们需要传入参数的Class对象，同时调用invoke方法时，需要传入参数值。

~~~java
    public void display(String str) {
        System.out.println("我是" + str + "人");
    }
~~~

~~~java
            Method m2 = c1.getMethod("display",String.class);
            m2.invoke(p1,"中国");
~~~

## Field

在Java中，Field类是反射（reflection）机制的一部分，它代表了一个类的成员变量（字段）。通过Field类，我们可以在运行时获取类的字段信息，并对这些字段进行读取和写入操作，即使在编译时并不知道这些字段的名称或类型。

## getFields

通过反射对象获取加载类中的public成员变量的Field数组

`Class c = Person.class;`

`Field[] fields = c.getFields();`

## getDeclaredFields

通过反射对象获取加载类中所有成员变量的Field数组

~~~java
            Field[] fields = c1.getFields();
            System.out.println("一共有" + fields.length + "个public成员变量，他们分别是：");
            for (Field f : fields) {
                System.out.println(f);
            }

            Field[] fields2 = c1.getDeclaredFields();
            System.out.println("一共有" + fields2.length + "个成员变量，他们分别是：");
            for (Field f : fields2) {
                System.out.println(f);
            }
~~~

## getMethods()

通过反射对象获取加载类中方法的Method数组，包括它的父类的**公共**方法

## getDeclaredMethods()

通过反射对象获取加载类中方法的Method数组，不包括它的父类的任何方法。

~~~java
            Method[] methods = c1.getMethods();
            System.out.println("一个有：" + methods.length + "个方法，他们分别是：");
            for (Method m : methods) {
                System.out.println(m);
            }

            Method[] methods2 = c1.getDeclaredMethods();
            System.out.println("一共有：" + methods2.length + "个自己声明的方法，他们分别是：");
            for (Method m : methods2) {
                System.out.println(m);
            }
~~~

## Constructor

这是反射包中一个用来表示构造方法的类，我们通过反射对象调用getConstructors获取构造方法的数组

~~~java
            Constructor[] constructors = c1.getConstructors();
            System.out.println("一共有：" + constructors.length + "个构造方法，他们分别是：");
            for (Constructor c : constructors) {
                System.out.println(c);
            }
~~~

我们可以通过getConstructor(参数的Class对象列表)可以获取有参构造方法的Constructor对象，再由该对象调用newInstance()传入参数值，即可调用有参构造方法创建加载类对象

~~~java
            Constructor<Person> constructor = c1.getConstructor(String.class,int.class);
            Person p2 = constructor.newInstance("李四",20);
            System.out.println(p2);
~~~

## 设计模式

### 单例模式

一个类只能创建一个对象

格式：

1、饿汉模式编写：

构造方法私有化，提供一个`private static final 当前类型的`成员变量赋值为当前类对象

对外提供一个`public static 当前类型返回值`的方法供别人调用，返回该成员变量

~~~java
public class Singleton01 {

    private static final Singleton01 only = new Singleton01();
    
    private Singleton01() {
    }
    
    public static Singleton01 singleton01Factory() {
        return only;
    }
}

~~~

~~~java
public class Test {
    public static void main(String[] args) {
        Singleton01 s1 = Singleton01.singleton01Factory();
        Singleton01 s2 = Singleton01.singleton01Factory();
        System.out.println(s1 == s2);//s1和s2内存地址相同，是同一个对象
    }
}
~~~

2、懒汉模式编写：

构造方法私有化，提供一个`private static 当前类型的`成员变量赋值null

对外提供一个`public static 当前类型返回值的`方法供别人调用，判断成员变量是否为null，如果为null则调用构造方法创建该类对象，返回成员变量

**注意**：懒汉模式需要做线程同步，饿汉不需要

~~~java
public class Singleton02 {
    private static Singleton02 only = null;

    private Singleton02() {
    }


    public synchronized static Singleton02 singleton02Factory() {
        if (only == null)
            only = new Singleton02();
        return only;
    }

}
~~~

~~~java
        Singleton02 s3 = Singleton02.singleton02Factory();
        Singleton02 s4 = Singleton02.singleton02Factory();
        System.out.println(s3 == s4);//s3 和 s4是同一个对象
~~~

### 工厂模式

一个工厂类把创建实体的过程进行了封装，当用户需要一个实体类对象的时候，无需自己创建，由工厂类直接提供

1、静态工厂模式

首先提供一个Map集合的成员变量，用来存放产品对象

然后提供一个static静态代码块用来创建若干产品对象，并存入Map集合中，对外提供一个public的工厂方法，根据需求返回Map中某个产品对象

~~~java
public class Car {
    private String cno;
    private String brand;
    private String maxSpeed;

    public Car() {
    }

    public String getCno() {
        return cno;
    }

    public void setCno(String cno) {
        this.cno = cno;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(String maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public Car(String cno, String brand, String maxSpeed) {
        this.cno = cno;
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }

    @Override
    public String toString() {
        return "Car{" +
                "cno='" + cno + '\'' +
                ", brand='" + brand + '\'' +
                ", maxSpeed='" + maxSpeed + '\'' +
                '}';
    }
}

~~~

~~~java
public class CarFactory01 {


    private static Map<String, Car> map = new HashMap<>();

    //静态代码块，类加载的时候执行
    static {
        Car car01 = new Car("1001", "Audi", "240");
        Car car02 = new Car("1002", "Ford", "220");
        Car car03 = new Car("1003", "Volvo", "240");
        map.put(car01.getCno(), car01);
        map.put(car02.getCno(), car02);
        map.put(car03.getCno(), car03);
    }

    public static Car getCar(String cno) {
        return map.get(cno);
    }
}
~~~

~~~java
public class Test {

    public static void main(String[] args) {
        Car car1 = CarFactory01.getCar("1001");
        System.out.println(car1);
        Car car2 = CarFactory01.getCar("1002");
        System.out.println(car2);
    }
}

~~~

2、实例工厂模式

首先提供一个Map集合的成员变量用来存放产品对象

然后提供一个构造方法用来造一个工厂

还要提供一个生产的方法用来生产产品并存入Map

对外提供一个public工厂方法根据需求返回Map中某个产品对象

~~~java
public class CarFactory02 {


    private static Map<String, Car> map = new HashMap<>();

    public CarFactory02() {
        produce();
    }

    //静态代码块，类加载的时候执行
    void produce() {
        Car car01 = new Car("1001", "Audi", "240");
        Car car02 = new Car("1002", "Ford", "220");
        Car car03 = new Car("1003", "Volvo", "240");
        map.put(car01.getCno(), car01);
        map.put(car02.getCno(), car02);
        map.put(car03.getCno(), car03);
    }

    public  Car getCar(String cno) {
        return map.get(cno);
    }
}

~~~

~~~java
public class Test2 {
    public static void main(String[] args) {
        CarFactory02 carFactory02 = new CarFactory02();//造一座工厂
        Car car2 = carFactory02.getCar("1003");
        System.out.println(car2);
    }
}

~~~

### 代理模式

围绕主体业务提供周边的辅助业务，并且完成主体业务的一种设计模式。

首先提供一个统一的完整业务接口给主体类和代理类分别实现。

然后需要主体类提供主体业务方法

最后提供一个代理类，包含主体类的成员变量，可以调用主体类的主体方法。并提供额外的相关业务

用户只需要面向代理类即可完成整个业务

~~~java
public class Car {
    private String carName;
    private int carPrice;

    public Car() {
    }

    public Car(String carName, int carPrice) {
        this.carName = carName;
        this.carPrice = carPrice;
    }

    @Override
    public String toString() {
        return "Car{" +
                "carName='" + carName + '\'' +
                ", carPrice=" + carPrice +
                '}';
    }
}

~~~

~~~java
public interface SaleCar {
    public Car getCar(String cno);
}

~~~

~~~java
public class CarFactory implements SaleCar {

    private static Map<String, Car> map = new HashMap<>();

    public CarFactory() {
        createCar();
    }

    void createCar() {
        map.put("宝马", new Car("宝马", 50_0000));
        map.put("奥迪", new Car("奥迪", 30_0000));
        map.put("迈巴赫", new Car("宝马", 1250_0000));

    }


    @Override
    public Car getCar(String carName) {

        return map.get(carName);
    }
}

~~~

~~~java
public class Car4S implements SaleCar{

    @Override
    public Car getCar(String carName) {
        System.out.println("销售");
        CarFactory carFactory = new CarFactory();
        return carFactory.getCar(carName);
    }
}
~~~

~~~java
public class Test {


    public static void main(String[] args) {
        Car4S car4S  = new Car4S();
        System.out.println(car4S.getCar("迈巴赫"));
    }
}
~~~





