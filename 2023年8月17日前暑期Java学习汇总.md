# 2023年8月1日

## Tomcat

1. 这是一个流行的web容器，用来部署发布网站的工具，它需要运行在Java环境的服务器上
2. 修改Tomcat端口：配置根目录/conf/server.xml中的`<connector>`中的port属性

## URL地址结构

`http://ip地址:端口号/web应用的名称/请求名`

~~~
http://ip地址:端口号/web应用的名称/请求名
|__________________|		   |
     web站点根目录               |
|_______________________________|
		web应用的根目录
~~~

web站点根目录：`http://ip地址:端口号`

web应用的根目录：`web站点的根目录/web应用的名字`

完整的URL：`web应用的根目录/请求名`

**注意**：请求名对应web.xml中的`<url-pattern>`

## servlet

狭义上：Servlet是一个接口，他可以接收请求返回响应，广义上讲，servlet是一个实现了Servlet接口的实现类，它重写了接口中的抽象方法，包括生命周期相关的方法：

生命周期方法：

调用构造方法实例化 ---- 只有一个实例化的Servlet对象

init() ---- 初始化方法

service() ---- 接收到一个请求，并返回响应

destroy() ---- 销毁当前servlet对象

**注意**：init方法只会执行一次，而service方法在每次请求到来的时候都被执行一次，destroy方法在tomcat停止的时候被执行一次

~~~
//ChatGPT:
Java Servlet的生命周期由Servlet容器管理，它在Servlet的整个生命周期中调用不同的方法。以下是Servlet生命周期的主要阶段和相应的方法：

1. 加载和实例化阶段：
   - 当Servlet容器启动时，它会查找并加载Web应用程序中的Servlet类。
   - 然后，Servlet容器通过调用Servlet类的构造函数来实例化Servlet对象。
   - 只会在Servlet容器启动时加载一次，并在后续请求中共享同一个Servlet实例。

2. 初始化阶段：
   - 实例化后，Servlet容器会调用Servlet的init()方法进行初始化。
   - 在init()方法中，可以执行一些初始化任务，比如读取配置信息、建立数据库连接等。
   - 每个Servlet实例只会初始化一次。

3. 请求处理阶段：
   - 一旦Servlet初始化完成，它就可以处理客户端发来的请求了。
   - 当有新的请求到达时，Servlet容器会在单独的线程中调用Servlet的service()方法。
   - service()方法根据请求的类型（GET、POST等）调用doGet()、doPost()等具体的处理方法。

4. 销毁阶段：
   - 当Servlet容器关闭时，或者Web应用程序被卸载时，Servlet容器会调用Servlet的destroy()方法。
   - 在destroy()方法中，可以执行一些资源释放的操作，比如关闭数据库连接、保存状态等。

值得注意的是，当Servlet容器检测到Servlet类的代码或配置文件发生改变时，它会自动重新加载和实例化Servlet，然后再次调用init()方法进行初始化。因此，在Web应用程序运行过程中，Servlet可能会多次初始化和销毁。

Servlet生命周期的管理使得Servlet容器可以高效地管理资源，并在需要时重新加载和更新Servlet，从而实现Web应用程序的动态性和灵活性。
~~~



## web.xml

这是web项目中的核心配置文件，它配置了各个请求对应的servlet类

格式：

~~~xml
<servlet>标签子标签
<servlet-name> ---- 当前servlet名字
<servlet-class> ---- 当前servlet类的全类名
<servlet-mapping> ---- 表示一个servlet的映射信息，包含两个子标签：
<servlet-name> ---- 当前servlet名字
<url-pattern> ---- 表示当前请求名   
~~~

~~~xml
    <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>com.iweb.test.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/myfirstrequest</url-pattern>
    </servlet-mapping>
~~~

**注意**：一个`<servlet>`可以对应多个`<servlet-mapping>`，由此，多个请求名都会进入该servlet类

~~~xml
    <servlet>
        <servlet-name>second</servlet-name>
        <servlet-class>com.iweb.test.MySecondServlet</servlet-class>
        <load-on-startup>0</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>second</servlet-name>
        <url-pattern>/second</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>second</servlet-name>
        <url-pattern>/second02</url-pattern>
    </servlet-mapping>
~~~



## `<load-on-startup>`

配置在`<servlet>`中，表示当前servlet被初始化的时机，如果配置非负整数，则表示tomcat启动进行初始化

~~~xml
<load-on-startup>0</load-on-startup>
~~~

多个servlet的加载顺序是按照`<load-on-startup>`值从小到大进行加载，0最先被加载，数字越大越靠后

## 通配符

`<url-pattern>`中的通配符

1. `/*` ---- 任意请求都能进这个servlet（除非有其他明确指定的）
2. `/` ---- 功能大致类似`/*`
3. `*.do` ---- do为自定义后缀，可以更改

~~~xml
ChatGPT:
/*：匹配所有URL。
/test/*：匹配所有以/test/开头的URL，如/test/foo和/test/bar。
/test/abc：仅匹配/test/abc这个具体的URL。
*.html：匹配所有以.html结尾的URL，如/page.html和/docs/index.html。
/user/*/profile：匹配类似/user/123/profile和/user/john/profile的URL
~~~

## 2023年8月2日

## ServletConfig

这是当前Servlet大管家，他可以获取当前servlet中方方面面的信息

getInitParameter() ---- 获取当前servlet的初始化参数

**注意**：初始化参数使用`<init-param>`配置在`web.xml`的`<servlet>`中

~~~xml
    <servlet>
        <servlet-name>second</servlet-name>
        <servlet-class>com.iweb.test.MySecondServlet</servlet-class>
        <init-param>
            <param-name>username</param-name>
            <param-value>root</param-value>
        </init-param>
        <load-on-startup>0</load-on-startup>
    </servlet>
~~~

~~~java
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("当前servlet被初始化了");
        String username = servletConfig.getInitParameter("username");
        System.out.println(username);//打印root
    }
~~~

getServletName(); ---- 获取当前servlet的名字

## ServletContext

这是当前Web应用的大管家，它可以获取当前整个Web应用方方面面的信息

我们可以通过ServletConfig对象调用getServletContext()来获取ServletContext对象

ServletContext常用方法 ：

getInitParameter(参数名) ---- 获取当前web应用的初始化参数的参数值

注意：web应用的初始化参数配在`<servlet>`外，使用`<context-param>`标签来配置

~~~xml
    <context-param>
        <param-name>password</param-name>
        <param-value>123456</param-value>
    </context-param>
~~~

~~~java
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        ServletContext servletContext = servletConfig.getServletContext();
        String password = servletContext.getInitParameter("password"); 
    }
~~~

getRealPath(文件在项目中的位置) ---- 获取指定文件在部署发布后的绝对路径

getContextPath() ---- 获取当前web应用的根目录

## ServletRequest

表示当前请求

getParameter(参数名) ----- 根据参数名得到对应的参数值

## 前端向servlet发起请求的方式

1. url地址栏写url，按回车键
2. `<a>`通过href属性配置url-pattern
3. `<form>`通过action属性配置url-pattern
4. ajax

## 关于传参

url地址栏可以使用`？`带参数，参数之间使用&符号分割

`<a>`可以使用href带参数

`<form>`可以使用name属性对应参数名，value属性对应参数值

## servlet项目中get和post请求方式区别

url地址栏发请求一定是get请求

 `<a>`发请求一定是get请求

`<form>`默认是get请求，method属性设置为post则为post请求

区别：

1. get请求的参数会显示在地址栏，post参数隐藏在消息体中
2. get请求参数长度不能超过1k，post没有长度限制
3. get请求是幂等的，多次相同的get请求会返回相同的结果，不会对服务器产生影响，post不一定是幂等的。
4. get请求可以被浏览器缓存，提高性能。

## ServletResponse

表示servlet返回的响应，我们可以调用该对象的getWriter()得到一个PrintWriter对象，再由PrintWriter对象调用print方法，完成返回内容的打印
# 2023年8月4日

## servlet登录

~~~java
//src\main\java\com.iweb.test\Login
public class Login implements Servlet {

    ServletContext sc;

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        sc = servletConfig.getServletContext();
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

        String username = sc.getInitParameter("username");
        String password = sc.getInitParameter("password");
        //页面上填写的账号密码
        String usernameParam = servletRequest.getParameter("username");
        String passwordParam = servletRequest.getParameter("password");

        PrintWriter pw = servletResponse.getWriter();
        if (username.equals(username) && password.equals(passwordParam)) {
            pw.print("hello " + usernameParam);
        } else {
            pw.print("sorry " + usernameParam);
        }

    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}

~~~

~~~xml
<!-- web\WEB-INF\web.xml   -->
    <context-param>
        <param-name>username</param-name>
        <param-value>admin</param-value>
    </context-param>


    <context-param>
        <param-name>password</param-name>
        <param-value>123456</param-value>
    </context-param>


    <servlet>
        <servlet-name>login</servlet-name>
        <servlet-class>com.iweb.test.Login</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>login</servlet-name>
        <url-pattern>/login</url-pattern>
    </servlet-mapping>
~~~

~~~html
<!-- web\login.html   -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户登录</title>
</head>
<body>
<h3>用户登录</h3>
<form action="login" method="post">
    账号：<input type="text" name="username"/>
    <br/><br/>
    密码：<input type="password" name="password"/>
    <br/><br/>
    <input type="submit" value="登录"/>
</form>
</body>
</html>
~~~

## HttpServletRequest

它是ServletRequest的子接口，它拥有了ServletRequest中所有的方法，我们浏览器发起的请求实际上全都是HttpServletRequest类型

常用方法：

getServletContext() ---- 获取当前ServletContext对象

```java
@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println("来了一个请求");
    System.out.println(servletRequest instanceof HttpServletRequest);
    HttpServletRequest request = (HttpServletRequest) servletRequest;
    ServletContext sc = request.getServletContext();
    System.out.println(sc.getInitParameter("username"));
}
```

getRequestURI() ---- 获取当前请求URL中的URI部分（URI =URL - web站点根目录）

getMethod() ---- 获取当前请求的请求方式

getServletPath() ----  获取当前请求名

getContextPath() ---- 获取当前web应用根目录

~~~java
   @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("来了一个请求");
        System.out.println(servletRequest instanceof HttpServletRequest);
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        ServletContext sc = request.getServletContext();
        System.out.println(sc.getInitParameter("username"));
        String uri = request.getRequestURI();
        String method = request.getMethod();
        System.out.println(method);
        String urlpattern = request.getServletPath();
        System.out.println(urlpattern);
        String contextPath = request.getContextPath();
        System.out.println(contextPath);
    }
~~~

## HttpServlet

这是一个抽象类，它实现了Servlet接口，它重写了接口中生命周期相关的方法，它将ServletRequest和ServletResponse向下转型成了HttpServletRequest和HttpServletResponse然后它调用了getMethod()判断当前请求的请求方式，并提供了doGet和doPost供我们重写

在实际开发中，我们无序实现Servlet接口，只需要继承HttpServlet，并重写doGet或者doPost方法即可，可以专注于业务逻辑的开发。

## Git

git config -l ---- 查看git配置信息

git config --global user.name "xxx" ---- 配置自己的姓名

git config --global user.email "xxx@xxx.xxx" ---- 配置自己的邮箱地址

工作目录 ---- 自己写代码的文件夹

暂存区 ---- 保存代码的临时修改

本地资源仓库 ---- 存放本地待提交的数据

远程仓库 ---- 用来保存数据共享和交换的真实仓库

git add ---- 将工作目录提交到暂存区

git commit ---- 将暂存区的数据提交到本地仓库

git push ---- 将本地仓库的数据提交到远程仓库

git pull ---- 从远程仓库下载代码到本地工作目录

git init ---- 初始化一个git工作目录

git status ---- 查看git文件夹中的状态

`git add . `---- 将git文件夹中所有新文件添加到暂存区

`git commit -m "消息内容"` ---- 将暂存区的数据提交到本地仓库

test cmd

### 小组合作使用git远程仓库步骤

组长操作：

1. 新建一个SpringBoot项目
2. 新建一个gitee仓库
3. 本地新建一个git文件夹
   在一个空文件夹中，使用git命令行窗口输入git init
4. 将gitee仓库克隆到该文件夹：
   使用git clone地址
5. 将clone好的仓库文件夹中的.git和.gitignore拷贝到SpringBoot项目文件夹中
6. 在idea工具中上传该项目到gitee远程仓库

组员操作：

1. 打开idea工具，File ---- New ---- Project from version Controller...
   git的url填写当前gitee仓库的url
   点击“clone”
2. 安排一位同学上传配置文件：pom.xml  application.properties等，其他同学右键点击项目 ---- git ---- pull这些配置文件
3. 所有人将自己模块的包，类。接口...从自己的项目中复制到现在下载的git项目中，然后测试功能，不报错的情况下，上传到远程仓库
4. 对于公共文件，先pull，再知会组内其他成员，然后修改后上传

### 小组合作使用git远程仓库步骤（HBuild工具）

在Hbuild工具中，右键项目名 ---- git ---- 添加

添加完之后点击 Commit 提交，之后点击push，刷新仓库页面

**注意**：添加的时



其他组员clone该项目到HBuilder

完成之后各自启动测试，测试完成之后各自添加自己的文件，各自add、commit 和 push

对于公共文件，先pull，再知会组内其他成员，然后修改后上传
# 2023年8月7日

## JSP

JavaServer Pages

前后端混合编写的技术

前端代码使用HTML编写，后端的Java代码写在`<% %>`中

JSP技术必须写在后缀名是.jsp的文件中

~~~jsp
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
  hello
   <%
     System.out.println("hello jsp");
   %>
  </body>
</html>
~~~

当我们编写好JSP文件，随着Tomcat启动，它会自动翻译出一个Servlet，并执行
所以JSP的本质是一个Servlet
JSP是后端技术

## 将字符串打印到页面

1. `out.print("字符串)`
2. `<%="字符串"%>`

~~~jsp
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
  hello
   <%
     out.println("1");
   %>
  <%="2"%>
  </body>
</html>

~~~

## JSP九大隐含对象

rrosacppe

**隐含对象**：在JSP中无序定义可以直接使用的对象

out ---- JspWriter类的对象，可以打印字符串到网页上

request ---- HttpServletRequest类的对象，表示当前请求

response ---- HttpServletResponse类的对象，表示当前响应

pageContext ---- PageContext类的对象，表示当前页面上下文，它可以获取其他八位的对象

session ---- HttpSession类的对象，表示当前会话，会话指的是一次浏览器的打开到关闭的过程

application ---- ServletContext类的对象，是Servlet的大管家

config ---- 当前JSP翻译出的哪个Servlet类的ServletConfig对象

page ---- 当前JSP翻译出来的哪个Servlet类的对象

exception ---- 当前JSP抛出的异常对象

#### ChatGPT:

JSP（JavaServer Pages）中有九个隐含对象，它们是预先定义好的变量，开发人员可以在JSP页面中直接使用，用于访问与请求、会话、上下文等相关的信息。以下是这九个隐含对象的列表和简要说明：

1. **request（请求对象）**：表示当前HTTP请求的对象，可以用于获取请求参数、头信息等。

2. **response（响应对象）**：表示当前HTTP响应的对象，可以用于设置响应头、写入响应内容等。

3. **out（输出对象）**：用于向客户端浏览器输出内容，类似于`System.out`，但用于输出到浏览器。

4. **session（会话对象）**：表示用户的会话，可以用于在不同请求之间存储和获取用户的数据。

5. **application（应用上下文对象）**：表示整个Web应用程序的上下文信息，可以用于在不同会话之间共享数据。

6. **config（配置对象）**：表示JSP页面的配置信息，例如JSP的初始化参数。

7. **pageContext（页面上下文对象）**：表示JSP页面的上下文信息，包括其他隐含对象和一些有用的方法。

8. **page（页面对象）**：表示JSP页面本身的对象，相当于Java类的this。

9. **exception（异常对象）**：用于捕获页面中发生的异常，并进行相应的处理。

这些隐含对象在每个JSP页面中都是自动可用的，开发人员可以直接在页面中使用它们，从而方便地访问与请求、会话、上下文等相关的信息，实现更丰富的功能。

-------------

index.jsp表示首页,它的文件名可以不写就直接展示

~~~jsp
<html>
<head>
    <title>MyFirstJSP</title>
</head>
<body>
This is my first JSP

<%
String age = request.getParameter("age");
out.print("age = " + age);
int ageInt = Integer.valueOf(age);
if(ageInt >= 18){
    out.print("您已经成年了");
}else{
    out.print("未成年人禁止访问");
}
%>

</body>
</html>
~~~

**注意**：在同一个JSP文件中，各个JSP代码块是相通的

~~~jsp
<html>
<head>
    <title>MyFirstJSP</title>
</head>
<body>
This is my first JSP

<%
String age = request.getParameter("age");
%>
<br/>
<%
out.print("age = " + age);
%>
<br/>
<%
int ageInt = Integer.valueOf(age);
if(ageInt >= 18){
%>
您已经成年了
<%
}else{
%>
未成年爬！
<%
}
%>

</body>
</html>
~~~

注释：

`<%-- --%>`

## 四大域对象

pageContext

request

session

application

他们可以分别进行存值和取值的操作

存值 ---- setAttribute("键"，"值")

取值 ---- getAttribute("键"，"值")

删除值 ---- removeAttribute("键"，"值")

**作用范围**：

pageContext ---- 当前页面

request ---- 一次请求

session ---- 一次会话，浏览器的打开到关闭称为一次会话

application ---- 当前web应用，tomcat的启动到关闭

**注意**：实际开发中，用的最多的是request

~~~jsp
<html>
<head>
    <title>MyFirstJSP</title>
</head>
<body>
This is my first JSP

<%

    pageContext.setAttribute("pageKey", "pageValue");
    request.setAttribute("reqKey", "reqValue");
    session.setAttribute("sessionKey", "SessionValue");
    application.setAttribute("applicationKey", "applicationValue");
%>

<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("reqKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>
<br/>

<a href="mySecondJSP.jsp">跳转到第二个页面</a>
</body>
</html>
~~~

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
第二个页面
<br/>
<%=pageContext.getAttribute("pageKey")%>
<br/>
<%=request.getAttribute("reqKey")%>
<br/>
<%=session.getAttribute("sessionKey")%>
<br/>
<%=application.getAttribute("applicationKey")%>
<br/>
</body>
</html>
~~~

## 请求转发

1. 采用当前request对象调用getRequestDispatcher(路径)得到RequestDispatcher对象
2. 通过RequestDispatcher对象调用 forward(request,response)完成转发

~~~java
public class TestForward extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了个请求，即将转发去下一个页面");
        //转发去下一个页面
        String path = "/test2.jsp";
        //获取转发器
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(path);
        requestDispatcher.forward(req,resp);//完成转发

    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>testForward</servlet-name>
        <servlet-class>com.iweb.TestForward</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testForward</servlet-name>
        <url-pattern>/testForward</url-pattern>
    </servlet-mapping>
~~~

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
test1

<a href="testForward">to test2.jsp</a>

</body>
</html>
~~~

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
test2
</body>
</html>
~~~

##  重定向

通过HttpServletResponse对象调用sendRedirect(路径)即可

~~~java
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("即将重定向去下一个页面");
        String path = "/test20230807/test2.jsp";
        resp.sendRedirect(path);

    }
~~~

### 面试题：请求转发和重定向的区别

**本质区别**：

转发在转发前和转发后是同一个请求
重定向在重定向前后是两个不同的请求

**细节上的区别**：

1. 路径中的斜杠含义不同，转发的时候，斜杠表示web应用根目录，重定向的时候，表示web站点根目录
2. url地址栏的显示不同，转发的时候，显示的是初次发起的请求名，重定向的时候，显示的是最终到达的目标资源
3. 转发的时候可以使用request对象携带数据，重定向是时候不可以使用request对象携带数据
4. 转发只能转到当前web应用以内的资源，重定向可以重定向到任何资源

**注意**：转发和重定向不仅可以跳转到页面，还可以向下一个Servlet发送请求

~~~java
public class TestResult extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是测试servlet");

    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>testResult</servlet-name>
        <servlet-class>com.iweb.TestResult</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testResult</servlet-name>
        <url-pattern>/testResult</url-pattern>
    </servlet-mapping>
~~~

~~~java
public class TestForward extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("来了个请求，即将转发去下一个页面");
        //转发去下一个页面
        //String path = "/test2.jsp";
        String path = "/testResult";

        req.setAttribute("key01","value01");
        //获取转发器
        RequestDispatcher requestDispatcher = req.getRequestDispatcher(path);
        requestDispatcher.forward(req,resp);//完成转发

    }
}
~~~

## 关于路径的问题

在web.xml中，`<url-pattern>`的斜杠/表示web应用的根目录，我们发起请求所写的路径必须和该路径一致，

在页面上`<a>`和`<form>`中的斜杠/表示web站点的根目录

~~~jsp
<html>
<head>
    <title>Title</title>
</head>
<body>
我是d1下的test1
<a href="/test20230807/testForward">请求转发</a>
<a href="/test20230807/testRedirect">重定向</a>
</body>
</html>
~~~

## errorPage属性

当前页面如果报错，则跳转到某个提示页面

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" errorPage="error.jsp" language="java" %>
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
 <%
   int i = 0;
 %>
  <%=100/i%>
  </body>
</html>

~~~

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Error</title>
</head>
<body>
对不起，系统正在维护
</body>
</html>
~~~

isErrorPage="true" ---- 表示当前页面可以使用exception隐含对象展示简要的错误信息

## `<%@include file="目标页面"%>`

将目标JSP合并到当前JSP中

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" errorPage="error.jsp" language="java" %>
<%@include file="error.jsp"%>
<html>
  <head>
    <title>这是我的第一个Jsp网页</title>
  </head>
  <body>
这里是index.jsp
  </body>
</html>

~~~

## 参数中的中文乱码问题

在接收请求参数之前，首先使用request对象，调用setCharacterEncoding("utf-8")，完成转码

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>test3</title>
</head>
<body>
This is test3.jsp

<br/>
<form action="<%=request.getContextPath()%>/test3" method="post">
    <input type="text" name="username"/>
    <br/>
    <input type="submit" value="提交"/>
</form>
</body>
</html>
~~~

~~~java
public class Test3 extends HttpServlet {

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        System.out.println("我是post请求");
        String str = req.getParameter("username");
        System.out.println(str);
    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>test3</servlet-name>
        <servlet-class>com.iweb.Test3</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>test3</servlet-name>
        <url-pattern>/test3</url-pattern>
    </servlet-mapping>
~~~





# 2023年8月10日

## EL

使用${} 表示EL表达式

它可以从域对象中取值，格式：

${xxxScope.键} ---- 根据键获取对应值

~~~jsp
<body>
我是测试页面
<%
    pageContext.setAttribute("key01", "value01");
    request.setAttribute("key02", "value02");
    session.setAttribute("key03", "value03");
    application.setAttribute("key04", "value04");

%>
<br/>
${pageScope.key01};
<br/>
${requestScope.key02};
<br/>
${sessionScope.key03};
<br/>
${applicationScope.key04};

</body>
~~~

getAttribute方法后面的小数点全部都是get方法

例如：`${pageScope.key01.bookname};`中，第一个小数点相当于getAttribute方法，第二个小数点相当于get方法

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    pageContext.setAttribute("key01", book);
    request.setAttribute("key02", book);
    session.setAttribute("key03", book);
    application.setAttribute("key04", book);

%>
<br/>
${pageScope.key01.bookname};
<br/>
${requestScope.key02.id};
<br/>
${sessionScope.key03.author};
<br/>
${applicationScope.key04.bookname};

</body>
~~~

xxxScope可以省略不写，如果不写，则按照与对象取值范围从小到大的顺序依次寻找，找到为止

~~~jsp
<body>
我是测试页面
<%
    Book book = new Book(1001, "活着", "余华");
    Book book2 = new Book(1001, "许三观卖血记", "余华");


    pageContext.setAttribute("key01", book);
    request.setAttribute("key01", book2);

%>
<br/>
${key01.bookname};

</body>
~~~

打印结果：

~~~jsp
活着
~~~

**注意**： `${pageContext.request.contextPath}`表示web应用根目录

扩展用法：

1. 当字符串中自带 . 时
   ~~~jsp
   ${requestScope["com.iweb.test"]}
   ~~~

2. ${param.参数}

## JSTL

JavaServer Pages Standard Tag Library

这是JSP标准标签库，它和EL表达式搭配，可以简化页面开发

操作步骤：

1、下载依赖
2、使用<%@taglib %>导入JSTL
3、使用<c:>标签来完成各种功能

例如：

~~~jsp
<c:forEach>表示循环遍历一个域对象中的集合</c:forEach>
item属性表示域对象的key,var属性表示定义用来循环的变量

      <c:forEach items="${books}" var="book">
          <tr>
              <td>${book.id}</td>
              <td>${book.bookname}</td>
              <td>${book.author}</td>
              <td><a href="<%=request.getContextPath()%>/toEdit.book?id=${book.id}">Edit</a></td>
              <td><a class="del" href="<%=request.getContextPath()%>/delete.book?id=${book.id}">Delete</a></td>
          </tr>
      </c:forEach>

~~~

~~~jsp
<c:redirect>重定向到某个页面</c:redirect>
例如：
<c:redirect url="/user/login.jsp"></c:redirect>
原版JSP代码：
<jsp:forward page="/user/login.jsp" />
效果相同
~~~

~~~jsp
<c:import>导入某个页面到当前页面中，可以是当前web应用以内或以外的资源</c:import>
例如：
<c:import url="http://www.baidu.com" charEncoding="utf-8"></c:import> <!--导入了百度-->
~~~

## Cookie

这是存放在浏览器电脑上的小文本文件，它对应服务器上的一个Cookie类的对象，当浏览器第一次向服务器发送请求时，由服务器创建Cookie对象，随响应带回浏览器，然后浏览器将其保存为文本文件，下一次再发请求时，浏览器会自动携带该Cookie文件去往服务器，服务器会自动比对确认两次请求来自同一个浏览器。

~~~jsp
<body>

<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

Cookie中携带的时键值对

默认Cookie中携带的一个键叫做JSESSIONID，值是一个16进制数的键值对，它表示当前这个会话

~~~jsp
<body>
<%
    Cookie[] cookies  = request.getCookies();
    if(cookies != null  && cookies.length > 0){
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
        }
    }else{
        System.out.println("你好，初次见面请多关照");
    }
%>
</body>
~~~

我们可以通过new Cookie(键，值)来创建一个自己的Cookie对象，然后通过response.addCookie(Cookie对象)将cookie对象绑定到response中带回浏览器

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        response.addCookie(cookie);
    }
%>
</body>
~~~

Cookie默认都是会话级别，它会随浏览器的关闭而消失

我们可以将其设置为持久级别：

使用Cookie对象的setMaxAge(秒数)表示当前cookie对象存活的时间，它不再 受到当前会话的影响。

~~~jsp
<body>
<%
    Cookie[] cookies = request.getCookies();
    if (cookies != null && cookies.length > 0) {
        System.out.println("我记得你，你曾经来过！");
        for (int i = 0; i < cookies.length; i++) {
            out.print(cookies[i].getName() + " ---- " + cookies[i].getValue());
            out.print("<br/>");
        }
    } else {
        out.print("你好，初次见面请多关照");
        Cookie cookie = new Cookie("mycookie01", "xy");
        cookie.setMaxAge(30);//设置存活时间之后，就成为了持久层cookie
        response.addCookie(cookie);
    }
%>
</body>
~~~

如果使用cookie.setMaxAge(0) ---- 表示立即删除

如果秒数为负数，例如：`cookie.setMaxAge(-1312312)`，则相当于这句话没写

~~~jsp
<%
    String username = request.getParameter("username");
    if (username == null) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null && cookies.length > 0) {
            for (int i = 0; i < cookies.length; i++) {
                if ("username".equals(cookies[i].getName())) {
                    username = cookies[i].getValue();
                }
            }
        }
    }else{
        Cookie cookie = new Cookie("username",username);
        cookie.setMaxAge(30);
        response.addCookie(cookie);
    }
    if(username == null){
        response.sendRedirect(request.getContextPath() + "/user/login.jsp");
    }
%>
~~~

# 2023年8月11日

## Session

HttpSession类的对象，表示当前会话

是用于在服务器端跟踪用户状态和存储用户数据的机制。，

getId() ---- 获取当前会话的JSESSIONID

isNew() ---- 判断当前会话是否是新的会话

getCreationTime() ---- 获取当前会话的创建时间

getLastAccessedTime() ---- 获取当前会话中上次请求的时间

getMaxInactiveInterval() ---- 获取使当前会话失效的两次请求的间隔时间

~~~jsp

<body>
<h3>test3页面</h3>
<%=session.getId()%>
<br/>
<%=session.isNew()%>
<br/>
<%=session.getCreationTime()%>
<br/>
<%=session.getLastAccessedTime()%>
<br/>
<%=session.getMaxInactiveInterval()%>
</body>
~~~

session.invalidate(); ---- 使当前会话立即失效

### Session的应用

在单点项目中：

1. 使用Session来存放用户的登录信息
2. 用来防止重复提交

### 重复提交

1. 连续点击提交按钮
2. 点击“提交”后转发到成功页面，刷新该页面，也是重复提交
3. 点击“提交”后，请求转发到成功页面，点击“后退”，再点击提交，也是重复提交

**不是重复提交**：如果点击“提交”后，请求转发到成功页面，点击“后退”，再点击刷新，再点击“刷新”则不是重复提交

## AJAX

Asynchronous JavaScript and XML

偷偷摸摸发请求的技术

无需刷新页面而使得前后端通信的一种技术

### 原生态的AJAX

原生态的AJAX是围绕一个叫做XMLHttpRequest的对象展开，该对象包括以下方法：

open(请求方式，url) ---- 装载请求

send() ---- 发送请求

当请求被发送，会调用onreadystatechange方法

在该方法中，我们通常判断readyState属性来了解发送的状态：0表示初始化，1表示正在加载，2表示已经加载，3表示交互中，4表示完成

当该属性值为4时，表示响应已经返回，这时我们还需要判断http协议的状态码，200表示成功，304表示没有改变

这时，我们可以通过responseText得到后端的返回值，进行页面的局部更新

~~~jsp
    <script type="text/javascript">
        window.onload = function () {
            var strNode = document.getElementById("str");
            strNode.onkeyup = function () {
                var request = new XMLHttpRequest();//定义一个AJAX的核心对象
                var method = "GET";
                var url = "<%=request.getContextPath()%>/test6";
                request.open(method, url);//装载
                request.send(null);
                request.onreadystatechange = function () {
                    if (request.readyState == 4) {
                        if (request.status == 200 || request.status == 304) {
                            var resp = request.responseText;
                            document.getElementById("message").innerHTML=resp;
                        }
                    }
                }
            }
        }
    </script>
~~~

~~~java
public class HelloAJAX extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        System.out.println("来了个请求");
        resp.getWriter().print("你好，这是我给你的返回值");
    }
}
~~~

~~~xml
    <servlet>
        <servlet-name>test6</servlet-name>
        <servlet-class>com.iweb.test.HelloAJAX</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>test6</servlet-name>
        <url-pattern>/test6</url-pattern>
    </servlet-mapping>
~~~

ChatGPT：

~~~jsp
这段 JavaScript 代码是一个用于实现 AJAX 功能的示例。它的主要作用是在用户在输入框中输入内容时，通过 AJAX 向服务器发送请求并接收响应，然后将响应的内容更新到页面上。

以下是逐行解释代码的各部分：

1. `window.onload = function () { ... }`：当整个页面加载完毕后，执行包含在这个函数中的代码。

2. `var strNode = document.getElementById("str");`：获取具有 id 为 "str" 的 HTML 元素，通常是一个输入框元素。

3. `strNode.onkeyup = function () { ... }`：当用户在输入框中松开键盘按键时，执行包含在这个函数中的代码。

4. `var request = new XMLHttpRequest();`：创建一个 XMLHttpRequest 对象，用于发送和接收数据。

5. `var method = "GET";`：设置请求的方法为 "GET"，即向服务器获取数据。

6. `var url = "<%=request.getContextPath()%>/test6";`：构建请求的 URL，其中 `<%=request.getContextPath()%>` 用于获取当前 Web 应用的上下文路径。`/test6` 是服务器上处理这个请求的路径。

7. `request.open(method, url);`：配置 XMLHttpRequest 对象，指定请求的方法和 URL。

8. `request.send(null);`：发送请求。在这个示例中，请求没有发送额外的数据，因此参数为 `null`。

9. `request.onreadystatechange = function () { ... }`：设置一个回调函数，在状态改变时进行处理。

10. `if (request.readyState == 4) { ... }`：当请求状态变为 4，表示请求已完成。

11. `if (request.status == 200 || request.status == 304) { ... }`：当响应状态码为 200（成功）或 304（未修改）时，表示请求成功。

12. `var resp = request.responseText;`：获取响应的文本内容。

13. `document.getElementById("message").innerHTML=resp;`：将响应的文本内容更新到 id 为 "message" 的 HTML 元素中，从而在页面上显示。

总之，这段代码展示了如何使用原生 JavaScript 和 XMLHttpRequest 对象来实现一个简单的 AJAX 请求，以及如何将服务器响应的内容更新到页面上。
~~~



**修改版**

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript">
        window.onload = function () {
            var strNode = document.getElementById("str");
            strNode.onkeyup = function () {
                var strvalue = this.value;
                var request = new XMLHttpRequest();//定义一个AJAX的核心对象
                var method = "GET";
                var url = "<%=request.getContextPath()%>/test6?str=" + strvalue;
                request.open(method, url);//装载
                request.send(null);
                request.onreadystatechange = function () {
                    if (request.readyState == 4) {
                        if (request.status == 200 || request.status == 304) {
                            var resp = request.responseText;
                            document.getElementById("message").innerHTML=resp;
                        }
                    }
                }
            }

        }
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

~~~java
public class HelloAJAX extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        String str = req.getParameter("str");
        System.out.println("来了个请求");
        resp.getWriter().print("你好，这是我给你的返回值" + str);
        //test the second git repository
    }
}
~~~

## JSON

这是一个数据格式，以`{`开头，以`}`结尾，中间是键值对，键值对的键和值以冒号分割，键值对之间以逗号分割，一般来讲，键都是字符串，值是任意类型

在JS中，JSON数据是以JSON对象的形式存在的

~~~jsp
    <script type="text/javascript">
        window.onload = function () {
            var jsonObj = {
                "name": "iweb",
                "age": 10,
                "address": {
                    "city": "Nanjing",
                    "school": "南信大"
                }
            };
            alert(jsonObj.name);
            alert(jsonObj.address.school);

        }
    </script>
~~~

### JSON字符串转JSON对象

1、eval函数 ---- 可以将字符串中的js代码解析出来

~~~javascript
            var str = "alert(\"hello\");";
            eval(str);
~~~

**注意**：如果是JSON字符串，那么eval函数中的字符串左右两边需要添加左小括号和右小括号

~~~JavaScript
            var str2 = "{\"name\":\"iweb\"}";
            var jsonObj2 = eval("(" +str2+")");
            alert(jsonObj2.name);
~~~

2、JSON.parse(JSON字符串)； ---- 直接转json对象

~~~JavaScript
            var str3= "{\"name\":\"iweb\"}";
            var jsonObj3 = JSON.parse(str3);
            alert(jsonObj3.name);
~~~

## jQuery提供的AJAX相关方法

1、load(url) ---- 某控件调用该方法，发起AJAX请求，返回值直接回填到该控件中

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $("#message").load(url);
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

后端servlet还有XML和原生态AJAX时候一样

**注意**：load方法如果传入一个url参数，则表示发送get请求，如果传入一个url参数和另一个JSON格式的请求参数，则发送POST请求

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function(){
                var inputValue = $("#str").val();
                var jsonObj = {"inputValue":inputValue};
                var url = "<%=request.getContextPath()%>/ajax";
                $("#message").load(url,jsonObj);
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

2、$.get(url，参数，回调方法) ---- 发起一个get请求

3、$.post(url，参数，回调方法) ---- 发起一个post请求

**注意**：回调方法的参数自由定义，它表示后端返回的字符串

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").keyup(function () {
                var param = $("#str").val();
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $.get(url,jsonObj,function(data){
                   $("#message").html(data);
                });
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message" style="color:red"></span>
</body>
</html>
~~~

#### 简单的用户名重复性校验

~~~jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#str").change(function () {
                var param = $("#str").val();
                //这个jsonObj和下面url中?加参数分别对应POST请求和GET请求，二者择一j
                var jsonObj = {
                    "str": param
                };
                var url = "<%=request.getContextPath()%>/test6?str=" + param;
                $.post(url, jsonObj, function (data) {
                    var resultObj = JSON.parse(data);
                    if (resultObj.flag == 1) {
                        $("#message").css("color", "green").html("恭喜您，该用户名可以使用");
                    } else {
                        $("#message").css("color", "red").html("对不起，该用户名已存在");
                    }
                });
            })
        })
    </script>
</head>
<body>
<input type="text" id="str"/>
<span id="message"></span>
</body>
</html>

~~~

~~~java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html");
        List<String> list = new ArrayList<>();
        list.add("Tom");
        list.add("Jerry");
        String result = "";
        String str = req.getParameter("str");
        if (list.contains(str)) {
            result = "{\"flag\":0}";
        } else {
            result = "{\"flag\":1}";
        }
        System.out.println("来了个POST请求");
        resp.getWriter().print(result);
    }
~~~

# 2023年8月12日

## Filter ---- 过滤器

是一种用于在 Servlet 请求和响应之间执行过滤任务的组件

我们创建的过滤器需要实现javax.servlet包下的Filter接口

我们重写接口中的doFilter方法

当拦截到一个请求的时候，该方法会被执行，除此之外init表示初始化，它在tomcat启动时自动执行，destroy表示销毁，它在tomcat停止时自动执行。

我们需要配置web.xml

格式：

~~~xml
<filter>
<filter-name>过滤器名</filter-name>
<filter-class>过滤器类的全类名</filter-class>
</filter>
<filter-mapping>
<filter-name>过滤器名</filter-name>
<url-pattern>拦截的资源或请求</url-pattern>
</filter-mapping>

~~~

例如：

~~~xml
    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~java
public class HelloFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("拦截到了一个请求");
    }

    @Override
    public void destroy() {

    }
}
~~~

### 过滤器的放行

在doFilter方法中使用filterChain对象调用doFilter(servletRequest,servletResponse)即可放行

如果该过滤器之后还有其他过滤器，则放行到下一个过滤器，如果没有其他过滤器，则放行到目标资源



**注意**：过滤器也可以拦截去往servlet的请求

~~~java
//servlet
public class TestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("我是Servlet");
    }
}

~~~

~~~java
//filter
public class TestFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("我拦截到了一个去往testServlet的请求");
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("我是TestFilter，我宣布放行！");

    }

    @Override
    public void destroy() {

    }
}

~~~

~~~xml
<!-- web.xml -->
    <servlet>
        <servlet-name>testServlet</servlet-name>
        <servlet-class>com.iweb.test.TestServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>testServlet</servlet-name>
        <url-pattern>/testServlet</url-pattern>
    </servlet-mapping>


    <filter>
        <filter-name>testFilter</filter-name>
        <filter-class>com.iweb.test.TestFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>testFilter</filter-name>
        <url-pattern>/testServlet</url-pattern>
    </filter-mapping>
~~~

FilterConfig ---- 当前Filter的大管家，可用获取当前过滤器方方面面的信息，用法和ServletConfig一样

~~~xml
    <filter>
        <filter-name>hello</filter-name>
        <filter-class>com.iweb.test.HelloFilter</filter-class>
        <init-param>
            <param-name>username</param-name>
            <param-value>xunyi</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>hello</filter-name>
        <url-pattern>/success.jsp</url-pattern>
    </filter-mapping>
~~~

~~~java
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String username = filterConfig.getInitParameter("username");
        System.out.println(username);
    }
~~~

多级过滤器，他们的顺序，是web.xml中`<filter-mapping>`排列的先后顺序决定的。# 2023年8月14日

## Listener ---- 监听器

监听着我们web项目中的域对象什么时候被创建，什么时候被销毁

我们通常所说的监听器，指的是实现了监听器接口的实现类，该实现类需要在web.xml中配置`<listener>`标签，该标签包含`<listener-class>`指向当前监听器类。

1、ServletContextListener： 它监听着ServletContext对象什么时候被创建，什么时候被销毁，当它被创建的时候，会自动执行contextInitialized方法，当他被销毁的时候，会自动执行contextDestroyed方法

web.xml:

~~~xml
    <listener>
        <listener-class>com.iweb.test.HelloListener</listener-class>
    </listener>
~~~

HelloListener.java:

~~~java
package com.iweb.test;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class HelloListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被创建了");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了");

    }
}
~~~

2、HttpSessionListener:它监听着一个会话什么时候创建，什么时候销毁
当它创建的时候调用sessionCreated方法
当它销毁的时候，调用sessionDestroyed方法

~~~java
package com.iweb.test;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class HelloListener implements ServletContextListener, HttpSessionListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被创建了");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了");

    }

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话创建了");
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话销毁了");
    }
}
 
~~~

**注意**：当关闭浏览器的时候，仅仅是当前会话不再可以被使用，而没有立即销毁，当调用invalidate方法时，会话立即销毁

~~~jsp
<%
    session.invalidate();
%>
~~~

3、ServletRequestListener:他监听着一个请求什么时候被创建，什么时候倍销毁

requestInitialized() ---- 一个请求倍创建时自动调用该方法

requestDestroyed() ---- 一个请求被销毁自动调用该方法

~~~java
public class HelloListener implements ServletContextListener, HttpSessionListener, ServletRequestListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被创建了");
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("ServletContext对象被销毁了");

    }

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话创建了");
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        System.out.println("一个会话销毁了");
    }

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        System.out.println("一个请求被创建了");
    }

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        System.out.println("一个请求被销毁了");
    }
}

~~~

## Spring

### 两大核心

IoC ---- 控制反转，又称依赖注入（DI），反转了资源提供的方向，原本需要自己去创建对象，现在由Spring推送，自己的程序被动地接收

AOP ---- 面向切面的编程，将所有与业务逻辑无关，但是每个模块都必须编写的代码（如：日志管理，转码工作）抽取出来做成一个切面，它自动切入指定的模块，完成它的工程，我们只需要专注自己模块的业务逻辑即可。

### 搭建Spring项目的步骤

1. 创建一个Maven工程
2. 在pom.xml中添加spring-core，spring-beans，spring-context依赖
3. 在resources文件夹中添加applicationContext.xml配置文件，并在该文件的<beans>下添加<bean>表示一个对象，<bean>中包含id属性表示该Bean的唯一标识符，class属性指向该对象的类，<property>标签表示该对象的属性，name表示属性名，value表示属性值
4. 创建测试类，使用ApplicationContext对象调用getBean方法获取Spring容器中的对象。

工程详见：HelloSpring20230814 

pom.xml:

~~~xml
<!-- Spring基础的三个依赖  主要用来使用IoC       
<!-- https://mvnrepository.       com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.3.6</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-beans -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>5.3.6</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.6</version>
        </dependency>
~~~



resources文件夹下的applicationContext.xml文件：

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="stu1" class="com.iweb.test.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="张三"></property>
        <property name="sage" value="20"></property>

    </bean>
</beans>
~~~

Student.java

~~~java

package com.iweb.test;

public class Student {

    private String sno;
    private String sname;
    private String sage;

    public String getSno() {
        return sno;
    }

    @Override
    public String toString() {
        return "Student{" +
                "sno='" + sno + '\'' +
                ", sname='" + sname + '\'' +
                ", sage='" + sage + '\'' +
                '}';
    }

    public void setSno(String sno) {
        this.sno = sno;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getSage() {
        return sage;
    }

    public void setSage(String sage) {
        this.sage = sage;
    }

    public Student() {
    }

    public Student(String sno, String sname, String sage) {
        this.sno = sno;
        this.sname = sname;
        this.sage = sage;
    }
}

~~~

Test.java

~~~java

package com.iweb.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        Student student1 = (Student) ac.getBean("stu1");
        System.out.println(student1);
    }
}

~~~

**注意**：当Spring容器被加载的时候，它就会利用反射调用容器中对象所在的类的无参构造方法创建对象，并且调用set方法为该对象赋属性值

**注意**：Spring容器中的<property> name属性对应的是实体类set方法的方法名去掉set剩下的部分首字母转小写。

**注意**：getBean不仅可以传入id值获取对象，还可以传入类名.class获取对象

当某个对象的某个属性是另外一个对象的时候，那么我们在<property>中使用ref引入另外一个对象的<bean>作为当前的属性值

~~~xml
    <bean id="stu1" class="com.iweb.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="Jerry"></property>
        <property name="sage" value="20"></property>
        <property name="school" ref="school1"></property>
    </bean>

    <bean id="school1" class="com.iweb.School">
        <property name="schoolName" value="nuist"></property>
        <property name="schoolAddress" value="nanjing"></property>
    </bean>
~~~

在Spring容器中，我们可以使用<constructor-arg>来调用实体类中有参的构造方法来创建对象

~~~xml
    <bean id="stu1" class="com.iweb.Student">
        <property name="sno" value="1001"></property>
        <property name="sname" value="Jerry"></property>
        <property name="sage" value="20"></property>
        <property name="school" ref="school1"></property>
    </bean>

   <bean id="school1" class="com.iweb.School">
       <constructor-arg name="schoolName" value="nuist"></constructor-arg>
       <constructor-arg name="schoolAddress" value="nanjing232323"></constructor-arg>
   </bean>
~~~

name属性对应构造方法的参数名

value属性对应传入参数的值

`<property>`和`<constructor-arg>`标签的区别：

- 使用 `<property>` 标签配置属性时，Spring 将会在创建对象后，通过对应的 setter 方法设置属性的值。这意味着 `School` 类必须有对应的 setter 方法。
- 使用 `<constructor-arg>` 标签配置构造函数参数时，Spring 将会在创建对象时直接调用指定的构造函数，传递设置的参数值。这意味着 `School` 类必须有一个与参数列表匹配的构造函数。

### 扫描器

Spring的容器中，可以使用扫描器去扫描一个包，包内所有带@Component的类都会自动创建对象，无需再手动配置Spring Beans

添加扫描器的步骤：

1. 添加context命名空间和验证文件（从Spring官网拷入）
   ~~~xml
   <!-- 添加了xmlns:context那行和最后两行 -->
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
         					  https://www.springframework.org/schema/context/spring-context.xsd"><!--这里面添加两行-->
   
   </beans>
   ~~~

2. 添加<context:component-scan>标签，并在base-package属性中配置需要扫描的包名

   ~~~xml
   <!-- 添加了xmlns:context那行和最后两行 -->
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
         					  https://www.springframework.org/schema/context/spring-context.xsd"><!--这里面添加两行-->
       
       
   <context:component-scan base-package="com.iweb"></context:component-scan><!-- 写下这一行，自此，com.iweb包下面的所有类，只要加了@Component注解，就不用再写<bean>配置来创建对象了 -->
       
   </beans>
   
   
   ~~~

### Spring框架可以对工厂模式进行很好的支持

在<bean>标签中，我们可以使用class执行工厂类，factory-method指向工厂方法，<constructor-arg>给工厂方法传参来获取对应的产品对象。

Car.java

~~~Java
package com.iweb.factory;

public class Car {

    private String cno;
    private String brand;
    private String price;
    private String maxSpeed;

    @Override
    public String toString() {
        return "Car{" +
                "cno='" + cno + '\'' +
                ", brand='" + brand + '\'' +
                ", price='" + price + '\'' +
                ", maxSpeed='" + maxSpeed + '\'' +
                '}';
    }

    public String getCno() {
        return cno;
    }

    public void setCno(String cno) {
        this.cno = cno;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public String getPrice() {
        return price;
    }

    public void setPrice(String price) {
        this.price = price;
    }

    public String getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(String maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    public Car() {
    }

    public Car(String cno, String brand, String price, String maxSpeed) {
        this.cno = cno;
        this.brand = brand;
        this.price = price;
        this.maxSpeed = maxSpeed;
    }
}

~~~

CarFactory1.java

~~~java
package com.iweb.factory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CarFactory1 {


  static   Map<String, Car> cars = new HashMap<>();

    static {

        cars.put("1001", new Car("1001", "Audi", "30,0000", "240"));
        cars.put("1001", new Car("1002", "Ford", "15,0000", "220"));
        cars.put("1001", new Car("1003", "Volov", "13,0000", "240"));
        cars.put("1001", new Car("1004", "BMW", "35,0000", "300"));

    }

    public static Car getCar(String cno){
        return cars.get(cno);
    }
}

~~~

applicationContext.xml

~~~xml
    <bean id="car1" class="com.iweb.factory.CarFactory1" factory-method="getCar">
        <constructor-arg name="cno" value="1001"></constructor-arg>
    </bean>
~~~

如果是实例工厂模式，则首先需要创建工厂的<bean>对象，然后在产品的<bean>对象中，使用factory-bean指向工厂的<bean> factory-method指向工厂方法

CarFactory2.java

~~~java
package com.iweb.factory;

import java.util.HashMap;
import java.util.Map;

public class CarFactory2 {


    static Map<String, Car> cars = new HashMap<>();

    public CarFactory2() {
        cars.put("1001", new Car("1001", "Audi", "30,0000", "240"));
        cars.put("1001", new Car("1002", "Ford", "15,0000", "220"));
        cars.put("1001", new Car("1003", "Volov", "13,0000", "240"));
        cars.put("1001", new Car("1004", "BMW", "35,0000", "300"));

    }


    public  Car getCar(String cno) {
        return cars.get(cno);
    }
}

~~~

applicationContext.xml

~~~java
    <bean id="factory2" class="com.iweb.factory.CarFactory2"></bean>
    <bean id="car2" factory-bean="factory2" factory-method="getCar">
        <constructor-arg name="cno" value="1001"></constructor-arg>
    </bean>
~~~

除了以上两种工厂模式，spring还提供了一个FactoryBean接口，我们只需要将自己的工厂类实现该接口并重写三个方法：getObject()中返回产品对象，getObjetType()中返回产品对象的类型，isSingleton()返回是否是单例
然后将该工厂类配到spring容器中即可



main方法的执行可以先不加载当前类

## AOP

AOP开发步骤：

1. 添加spring-aspects依赖和spring-aop依赖
2. 添加纯净版的业务逻辑类
3. 添加通知类
4. 再Spring容器中田家庵纯净版业务逻辑类的对象和通知类的对象
5. 在Spring容器中添加`<aop:config>`标签并配置切点表达式指向业务逻辑类的方法，添加`<aop:advisor>`来绑定切点表达式和通知类的`<bean>`
6. 编写测试类，完成测试



首先配置pom.xml
~~~xml
       <!-- 使用AOP需要加的依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>5.3.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>5.3.6</version>
        </dependency>
~~~

再配置applicationContext.xml

添加了 ` xmlns:aop="http://www.springframework.org/schema/aop"`

和 `http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd`

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd

 http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

</beans>
~~~

首先需要一个纯净版的业务逻辑类

MyArithmetic2.java

~~~java
package com.iweb.test;

public class MyArithmetic2 {
//不带打印日志的语句

    public int add(int a,int b){

        int result = a + b;
        return result;
    }

    public int subtract(int a,int b){

        int result = a - b;
        return result;
    }


    public int multiply(int a,int b){

        int result = a * b;
        return result;
    }


    public int divide(int a,int b){

        int result = a / b;
        return result;
    }

}
~~~

还需要一个前置类

MyBeforeAdvice.java

~~~java
package com.iweb.test;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName() +
                " start , get params: " + objects[0] + " and " + objects[1]);

    }
}
~~~

在applicationContext.xml中添加<bean>

~~~xml
    <aop:config>
        <aop:pointcut id="myPoint" expression="execution(* com.iweb.test.MyArithmetic2.*(..))"/>
        <aop:advisor advice-ref="myBeforeAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>

    <bean id="myArithmetic2" class="com.iweb.test.MyArithmetic2"></bean>
    <bean id="myBeforeAdvice" class="com.iweb.test.MyBeforeAdvice"></bean>
~~~

测试类：

~~~java
package com.iweb.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test7 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        MyArithmetic2 ma = (MyArithmetic2) ac.getBean("myArithmetic2");
        int i = ma.add(1,2);
        System.out.println(i);
    }
}

~~~

### 通知类：

MethodBeforeAdvice ---- 前置通知

AfterReturningAdvice ---- 后置返回通知

添加后置返回通知：
MyBeforeAdvice.java

~~~java
package com.iweb.test;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println(method.getName() +
                " start , get params: " + objects[0] + " and " + objects[1]);

    }
}

~~~

修改applicationContext.xml

~~~xml
    <aop:config>
        <aop:pointcut id="myPoint" expression="execution(* com.iweb.test.MyArithmetic2.*(..))"/>
        <aop:advisor advice-ref="myBeforeAdvice" pointcut-ref="myPoint"></aop:advisor>
        <aop:advisor advice-ref="myAfterAdvice" pointcut-ref="myPoint"></aop:advisor>
    </aop:config>

    <bean id="myArithmetic2" class="com.iweb.test.MyArithmetic2"></bean>
    <bean id="myBeforeAdvice" class="com.iweb.test.MyBeforeAdvice"></bean>
    <bean id="myAfterAdvice" class="com.iweb.test.MyAfterAdvice"></bean>
~~~

### 使用注解的方式来完成AOP

1. 我们创建通知类，添加@Component和@Aspect注解，在通知类中添加@Before表示前置通知，切点表达式写在注解中
2. 在Spring容器中配置扫描器扫描通知类的包和业务逻辑包
3. 在Spring容器中添加`<aop:aspectj-autoproxy>`使得注解生效
4. 编写测试类完成测试

通知类的注解：

@Before("切点表达式") --- 前置注解

@After("切点表达式") --- 后置注解

@`AfterReturning(value="切点表达式"，returning="返回值变量名，例如：result")` ---- 后置返回通知
然后在方法中必须要有Object 类型的参数，参数名要和上面的一样
例如：`public void afterMethod(JoinPoint joinPoint,Object result)`

@After和@AfterReturning的区别：
如果程序报错（比如：除0），@After依旧会触发，@AfterReturning不会触发，因为没有返回值

MyArithmetic3.java

```java
package com.iweb.test2;


import org.springframework.stereotype.Component;

@Component
public class MyArithmetic3 {
//不带打印日志的语句

    public int add(int a,int b){

        int result = a + b;
        return result;
    }

    public int subtract(int a,int b){

        int result = a - b;
        return result;
    }


    public int multiply(int a,int b){

        int result = a * b;
        return result;
    }


    public int divide(int a,int b){

        int result = a / b;
        return result;
    }

}
```

前置通知：

```java
package com.iweb.test2;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyBeforeAdvice2 {


    @Before("execution(* com.iweb.test2.MyArithmetic3.*(..))")
    public void beforeMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();//获取切入的方法名
        Object[] args = joinPoint.getArgs();
        System.out.println(methodName + " start ,get params : " + args[0] + " and " + args[1]);
    }
}
```

测试：

```java
package com.iweb.test2;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test8 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        int result = ((MyArithmetic3) ac.getBean(MyArithmetic3.class)).subtract(30,2);
        System.out.println(result);

    }
}
```

applicationContext.xml

```xml
<context:component-scan base-package="com.iweb.test2"></context:component-scan>
<!-- 使aop注解生效 -->
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

后置通知：

```java
package com.iweb.test2;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAfteAdvice2 {


    @After("execution(* com.iweb.test2.MyArithmetic3.*(..))")
    public void afterMethod(JoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + " ends!");
    }
}
```

带返回值的后置通知：

```java
package com.iweb.test2;


import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MyAfteAdvice3 {


    @AfterReturning(value="execution(* com.iweb.test2.MyArithmetic3.*(..))",returning = "result")
    public void afterMethod(JoinPoint joinPoint,Object result){
        String methodName = joinPoint.getSignature().getName();

        System.out.println(methodName + " ends! result: " + result);


    }


}
```# 2023年8月15日

### `<url-pattern>`中的`/ ` 和  `/* `区别

`/*` 是拦截所有请求

`/`是拦截`.jsp`以外的所有请求

## SpringMVC

这是一个封装了Servlet的框架，它能够接收请求，返回响应

搭建步骤：

1. 创建一个Maven项目，添加框架的支持，选择springMVC
2. 在pom.xml中添加spring-webmvc和servlet的依赖
3. 在web.xml中将`<url-pattern>`修改为`/`，并在请求分发器的`<servlet>`添加初始化参数指向spring配置文件（dispatcher-servlet.xml）
4. 修改spring配置文件，添加扫描器扫描控制器所在的包
5. 修改spring配置文件，添加视图解析器，指向返回页面的前缀和后缀
6. 在控制器类中添加@Controller注解，方法上添加@RequestMapping("请求名")表示接收指定的请求，返回值为响应的页面文件名
7. 启动Tomcat，完成测试。

pom.xml中添加依赖：

~~~xml
        <!-- SpringMVC -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.3.6</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
~~~

web.xml中进行修改

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
    </context-param>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
         <!-- 添加了4行 -->
        <init-param>      
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/dispatcher-servlet.xml</param-value>
        </init-param>
        
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>  <!-- 修改了 -->
    </servlet-mapping>
</web-app>
~~~

修改dispatcher-servlet.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/context
      					  https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 使用了扫描器 -->
    <context:component-scan base-package="com.iweb.test.controller"></context:component-scan>
</beans>
~~~

被扫描的类

```java
package com.iweb.test.controller;
import org.springframework.stereotype.Controller;

@Controller
public class HelloSpringMVC {

    @RequestMapping("/hellospringmvc")
    public String hello() {
        System.out.println("来了个请求！");
        return "hello";
    }
```

在dispatcher-servlet.xml中加入视图解析器：

~~~xml
    <!-- 视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/jsp/"></property><!-- 前缀 -->
        <property name="suffix" value=".jsp"></property><!-- 后缀 -->
        <!-- 前缀后后缀中间缺少的，就是@Controller中return的字符串，例如HelloSpringMVC.java中的return "hello" -->
    </bean>
~~~

## ModelAndView

这是一个类，用来返回响应到指定页面，并且在request中携带数据

我们的控制器方法可以返回该类型

addObject("键"，"值") ---- 存放数据到request中

setViewName() ---- 设置返回页面的路径

```java
@RequestMapping("/test2")
public ModelAndView test(ModelAndView mv) {
    System.out.println("来了个ModelAndView请求！");
    mv.addObject("myKey","myValue");
    mv.setViewName("hello");
    return mv;
}
//前端使用${requestScope.myKey}来打印
```

在SpringMVC的控制器方法中，我们可以定义HttpSession和HttpRequestRequest参数，由SpringMVC传递给我们使用

```java
@RequestMapping("/test2")
public ModelAndView test(ModelAndView mv, HttpSession session,
                         HttpServletRequest request) {
    System.out.println("来了个ModelAndView请求！");
    mv.addObject("myKey", "myValue");
    mv.setViewName("hello");
    session.setAttribute("sessionKey", "sessionValue");
    request.setAttribute("requestKey","requestValue");
    ServletContext application = request.getServletContext();
    application.setAttribute("applicationKey","applicationValue");
    return mv;
}
```

```jsp
${requestScope.myKey}
<br/>
${sessionScope.sessionKey}
<br/>
${requestScope.requestKey}
<br/>
${applicationScope.applicationKey}
```

在@RequestMapping注解中，

method = RequestMethod.GET表示只接受get请求
method = RequestMethod.POST表示只接受post请求

## @RequestParam

接收请求参数

```java
    @RequestMapping(value = "/test2", method = RequestMethod.GET)
    public ModelAndView func(ModelAndView mv, @RequestParam String username, @RequestParam String password) {
        mv.setViewName("world");//去world.jsp prefix是/jsp/  suffix是.jsp
        System.out.println("username = " + username);
        System.out.println("password = " + password);
        return mv;
    }
```

## CharacterEncodingFilter过滤器

完成参数转码，解决中文乱码的问题。

在web.xml中

```xml
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>utf-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## @PathVariable

可以绑定url中的占位符到控制器方法的形参中，占位符部分使用{参数名}表示

```jsp
<a href="<%=request.getContextPath()%>/test3/1001">test3</a>
```

```java
@RequestMapping("/test3/{id}")
public String test3(@PathVariable("id") String id){
    System.out.println(id);
    return "hello";//跳转到hello.jsp
}
```

## Model 

这时ModelAndView中的Model，它可以绑定数据到request中

addAttribute("键"，"值") ---- 将键值对存入request中。

```java
@RequestMapping("/test3/{id}")
public String test3(@PathVariable("id") String id, Model model) {
    System.out.println(id);
    model.addAttribute("modelKey", "modelValue");
    return "hello";//跳转到hello.jsp
}
```

## @ModelAttribute

可以把一个对象绑定到Model中

```java
@RequestMapping("/test4")
public String test4(@ModelAttribute User user){
    user.setUsername("xunyi");
    user.setFullname("xunyi lannister");
    user.setPassword("213");
    return "hello";
}
```

```jsp
${requestScope.user.fullname}
```

@ModelAttribute可以绑定同名参数到某个对象的同名属性中

```java
@RequestMapping("/test5")
public String test5(@ModelAttribute User user){
    return "hello";
}
```

# 2023年8月16日

## SpringMVC中对静态文件的放行

在web.xml中，请求分发器配置了斜杠,他能够拦截`.jsp`以外的所有请求，当我们需要导入静态文件的时候，它也会拦截，我们需要对静态文件放行，具体操作：

添加<servlet-mapping>里面包含<servlet-name>为default，<url-pattern>为*.后缀

具体的某个后缀的静态文件就会被放行

```xml
<!-- 放行*.js -->
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.js</url-pattern>
</servlet-mapping>
```

新版：检测用户名是否存在

```jsp
<%--
  Created by IntelliJ IDEA.
  User: HeartWardrum
  Date: 2023-08-16/0016
  Time: 8:47
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>

    <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.11.3.min.js"></script>
    <script type="text/javascript">
        $(function () {
            $("#username").change(function () {
                var username = $(this).val();
                var jsonObj = {
                    "username": username
                };
                var url = "<%=request.getContextPath()%>/checkedUser"
                $.post(url, jsonObj, function (data) {
                    var resultObj = JSON.parse(data);
                    if (resultObj.flag == 1) {
                        $("#message").css("color", "green").html("恭喜，用户名可用");
                        $("#sub").prop("disabled", false);
                    } else {
                        $("#message").css("color", "red").html("对不起，用户名已存在");
                        $("#sub").prop("disabled", true);//提交按钮置灰
                    }
                })
            })
        })
    </script>
</head>
<body>
<form action="<%=request.getContextPath()%>/test5" method="post">
    username<input type="text" name="username" value="" id="username"/>
    <span id="message"></span>
    <br/>
    password<input type="text" name="password" value=""/>
    <br/>
    fullname<input type="text" name="fullname" value=""/>
    <br/>
    <input type="submit" value="提交" id="sub"/>
</form>
</body>
</html>

```

```java
package com.iweb.test.controller;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Controller
public class CheckedUsername {


    @RequestMapping("/checkedUser")
    public void checkedUser(HttpServletResponse response, @RequestParam String username) throws IOException {
        List<String> users = new ArrayList<>();
        users.add("tom");
        users.add("jerry");
        String result = "";
        if (users.contains(username)) {
            result = "{\"flag\":0}";
        } else {
            result = "{\"flag\":1}";
        }
        System.out.println("校验用户名是否存在");
        response.getWriter().print(result);

    }

}
```

## SpringMVC中的跳转

1. 转发到页面：默认返回的字符串，需要拼上前缀后缀。

2. 转发到下一个控制器：返回的字符串格式：“forward:/url地址”

   ```java
   @RequestMapping("forwardToController1")
   public String next1(){
       System.out.println("即将请求转发到下一个控制器");
       return "forward:/next";//不会去读前缀后缀
   }
   ```

   ```java
   package com.iweb.test.controller;
   
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.RequestMapping;
   
   @Controller
   public class NextController {
   
       @RequestMapping("/next")
       public String next() {
           System.out.println("我是下一个控制器");
           return "hello";
       }
   
   }
   ```

   ```jsp
   <a href="<%=request.getContextPath()%>/forwardToController1">转发去下一个控制器</a>
   ```

用ModelAndView的写法：

```java
@RequestMapping("/forwardToController1")
public ModelAndView next2(ModelAndView mv){
    System.out.println("即将请求转发到下一个控制器");
    mv.setViewName("forward:/next");
    return mv;
}
```

3 、重定向到下一个页面：返回的字符串格式："redirect:url地址" ，支持String和ModelAndView的返回值

```java
    @RequestMapping("/redirectToPage")
    public ModelAndView next3(ModelAndView mv){
        System.out.println("即将重定向到下一个页面");
        mv.setViewName("redirect:/jsp/hello.jsp");
        return mv;
    }
```

4、重定向到下一个控制器

```java
@RequestMapping("/redirectToController")
public ModelAndView next4(ModelAndView mv){
    System.out.println("即将重定向到下一个控制器");
    mv.setViewName("redirect:/next");
    return mv;
}
```

## 控制器之间传递数据

1、使用session

第一个控制器：

```java
@RequestMapping("/redirectToController")
public ModelAndView next4(ModelAndView mv,HttpSession session){
    System.out.println("即将重定向到下一个控制器");
    session.setAttribute("message","ni hao");
    mv.setViewName("redirect:/next");
    return mv;
}
```

第二个控制器：

```java
@RequestMapping("/next")
public String next(HttpSession session) {
    System.out.println("我是下一个控制器");
    System.out.println(session.getAttribute("message"));
    session.removeAttribute("message");
    return "hello";
}
```

2、使用RedirectAttributes用于在重定向的时候传递数据

`addFlashAttribute("键"，"值") `---- 用来存值

在接收端通过`@ModelAttribute( "键") ` 来接收数据

同时在spring容器种添加` <mvc:annotation-driven`>使其生效

了解即可，做项目基本不用# 2023年8月17日

## MyBatis

这是一个持久化层的框架，这是一个ORM的框架

持久化：泛指所有针对数据库的操作

ORM：Object-Relational Mapping 对象关系映射，数据库中的一张表和Java中的一个实体类对应，表中的一个字段和Java中的一个成员变量对应，表中的一行记录和Java中的一个对象对应

### 搭建MyBatis框架的步骤

1、创建Maven项目，导入MyBatis和数据库的依赖
2、在pom.xml中指明配置文件的路径
3、添加实体类对应数据库中的表
4、添加MyBatis总的配置文件
5、添加SQL语句的配置文件
6、在总的配置文件中加载SQL语句的配置文件
7、添加测试类，配置二级缓存和一级缓存，完成测试

pom.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.iweb</groupId>
    <artifactId>MyBatis20230817</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>


    <dependencies>

        <!--    MyBatis    -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.6</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.23</version>
        </dependency>


    </dependencies>


    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
        </resources>
    </build>
</project>
```

src/main/resources/mybatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration


        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.77.100:3306/mysql?characterEncoding=utf-8"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>


    </environments>


    <mappers>
        <mapper resource="com/iweb/dao/MyBook.xml"/>
    </mappers>
</configuration>
```

项目的dao包中的配置文件 MyBook.xml:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mybook">
    <select id="queryById" parameterType="int" resultType="com.iweb.model.MyBook">
        select * from mybook  where id = #{id}
    </select>
</mapper>
```

测试类：

```java
package com.iweb.test;

import com.iweb.model.MyBook;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class Test1 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        SqlSession sqlSession = null;

        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
            //由工厂的建造者拿着inputStream材料去建一座生产SqlSession的工厂 ，SqlSessionFactory成为MyBatis的二级缓存
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //工厂开始生产SqlSession对象 , sqlSession成为MyBatis的一级缓存
            sqlSession = sqlSessionFactory.openSession();
            //由SqlSession对象调用方法执行SQL语句
            int id = 1001;
            MyBook myBook = sqlSession.selectOne("mybook.queryById", id);
            sqlSession.commit();
            System.out.println(myBook);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (sqlSession != null)
                sqlSession.close();

        }
    }
}
```

### MyBatis常用方法

selectOne() ---- 查询一条语句

selectList() ---- 查询多条记录

```java
List<MyBook> myBooks = sqlSession.selectList("mybook.queryAll");
```

```xml
<select id="queryAll"  resultType="com.iweb.model.MyBook">
    select * from mybook
</select>
```

insert() ---- 新增一条记录

```java
MyBook myBook = new MyBook(null, "The Little Prince", "Richard Howard");
int i = sqlSession.insert("mybook.addOne",myBook);
sqlSession.commit();
System.out.println(i);
```

```xml
<insert id="addOne" parameterType="com.iweb.model.MyBook">
    insert into mybook values(null,#{bookname},#{author})
</insert>
```

delete() ---- 删除一条记录

```java
int i = sqlSession.delete("mybook.deleteOne",id);
```

update() ---- 修改一条记录

```java
int id = 1113;
MyBook myBook = sqlSession.selectOne("mybook.queryById",id);
myBook.setBookname("琼恩兰尼斯特的费伦之旅");
myBook.setAuthor("博德之门");
int i = sqlSession.update("mybook.updateOne",myBook);
```

```xml
<update id="updateOne" parameterType="com.iweb.model.MyBook">
    update mybook set bookname = #{bookname} , author = #{author} where id = #{id}
</update>
```

**注意**：在MyBatis中，任何传参和返回值在没有ORM的时候，都可以使用Map来封装数据

查询全部：

```java
List<Map<String, Object>> myBooks = sqlSession.selectList("mybook.queryAll2");
sqlSession.commit();
System.out.println(myBooks);
```

```xml
<select id="queryAll2" resultType="java.util.HashMap">
    select * from mybook
</select>
```

新增一条：

```java
Map<String, Object> map = new HashMap<>();
map.put("id", null);
map.put("bookname", "1984");
map.put("author", "George Orwell");
int i = sqlSession.insert("mybook.addOne2", map);
System.out.println(i);
```

```xml
<insert id="addOne2" parameterType="java.util.HashMap">
    insert into mybook values(null,#{bookname},#{author})
</insert>
```

###  `<resultMap>`

创造一个ORM对象的映射

type表示实体类

`<result>`表示具体的对应关系

`property`表示成员变量

`column表示字段

新的MyBook类：

```java
package com.iweb.model;

public class MyBook2 {
    private Integer my_id;
    private String  my_bookname;
    private String  my_author;
```

```xml
<resultMap id="myResult" type="com.iweb.model.MyBook2">
    <result property="my_id" column="id"></result>
    <result property="my_bookname" column="bookname"></result>
    <result property="my_author" column="author"></result>
</resultMap>

<select id="queryAll3" resultMap="myResult">
    select * from mybook
</select>
```

```java
List<MyBook2> myBook2s = sqlSession.selectList("mybook.queryAll3");
System.out.println(myBook2s);
```

### 动态SQL

在MyBatis中，我们使用<if>标签来动态拼接SQL语句

test属性表示判断条件，当条件满足就会拼上<if>标签对中的子语句

```xml
<select id="queryByParam" parameterType="java.util.Map" resultType="com.iweb.model.MyBook">
    select * from mybook
    where 1=1
    <if test="id!=null">
        and id = #{id}
    </if>
    <if test="bookname!=null">
        and bookname = #{bookname}
    </if>
    <if test="author!=null">
        and author = #{author}
    </if>
</select>
```

```java
Map<String,Object> map = new HashMap<>();
map.put("bookname","1984");
List<MyBook> myBooks = sqlSession.selectList("mybook.queryByParam",map);
System.out.println(myBooks);
```

### 面向接口编程

1、接口名、配置文件名、命名空间名一致
2、接口中方法名和配置文件中SQL语句的id一致
3、接口中方法的参数和SQL语句的参数类型一致
4、接口中方法的返回值类型和SQL语句的返回值类型一致
满足以上四点，当我们调用接口中的方法，会自动执行SQL语句完成数据库操作。

model文件夹下User类：

```java
package com.iweb.model;

public class User {
    private String id;
    private String username;
    private String password;


    public User() {
    }

    public User(String id, String username, String password) {
        this.id = id;
        this.username = username;
        this.password = password;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```

dao文件夹下UserDao接口：

```java
package com.iweb.dao;

import com.iweb.model.User;

import java.util.List;

public interface UserDao {

    public void addOne(User user);

    public List<User> queryAll();

    public User queryById(String id);

    public void updateOne(User user);

    public void deleteOne(String id);

}
```

dao文件夹下，UserDao.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.UserDao">
    <insert id="addOne" parameterType="com.iweb.model.User">
        insert into my_user values(#{id},#{username},#{password})
    </insert>

    <select id="queryAll" resultType="com.iweb.model.User">
        select * from my_user
    </select>

    <select id="queryById" parameterType="java.lang.String" resultType="com.iweb.model.User">
        select * from my_user where id = #{id}
    </select>

    <update id="updateOne" parameterType="com.iweb.model.User" >
        update my_user set username = #{username} , password = #{password} where id = #{id}
    </update>

    <delete id="deleteOne" parameterType="java.lang.String" >
        delete from my_user where id = #{id}
    </delete>
</mapper>
```

修改mybatis-config.xml,在<mapper>标签中添加一行：

```xml
<mappers>
    <mapper resource="com/iweb/dao/MyBook.xml"/>
    <mapper resource="com/iweb/dao/UserDao.xml"/>   <!-- 添加了这一行 -->
</mappers>
```

测试类：

```java
package com.iweb.test;

import com.iweb.dao.UserDao;
import com.iweb.model.MyBook;
import com.iweb.model.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Test2 {

    public static void main(String[] args) {
        InputStream inputStream = null;
        SqlSession sqlSession = null;

        try {
            inputStream = Resources.getResourceAsStream("mybatis-config.xml");
            //由工厂的建造者拿着inputStream材料去建一座生产SqlSession的工厂 ，SqlSessionFactory成为MyBatis的二级缓存
            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            //工厂开始生产SqlSession对象 , sqlSession成为MyBatis的一级缓存
            sqlSession = sqlSessionFactory.openSession();
            //由SqlSession对象调用方法执行SQL语句


            //主要修改的是这边
            UserDao ud = sqlSession.getMapper(UserDao.class);
            List<User> users = ud.queryAll();
            System.out.println(users);
            
            
            sqlSession.commit();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (sqlSession != null)
                sqlSession.close();

        }
    }
}
```

查询一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
User user = ud.queryById("1005");
System.out.println(user);
```

新增一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
User user = new User("1007","lannister","7788");
ud.addOne(user);
```

修改一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
User user = ud.queryById("1007");
user.setUsername("join_lannister");
user.setPassword("3223");
ud.updateOne(user);
```

删除一条：

```java
UserDao ud = sqlSession.getMapper(UserDao.class);
ud.deleteOne("1007");
```

### 一对一级联查询

1、首先确定主从表，查询主表带出从表
2、编写各自实体类和接口，主表的实体类中包含从表类型的成员变量 
3、在主表查询语句中编写`<resultMap>`创建ORM对象关系映射，其中关联条件的`<result>`中的property对应成员变量，column对应关联字段，select对应从表的关联查询语句的id，javatype对应从表关联查询的返回值类型

Card实体类：

```java
package com.iweb.model;

public class Card {
    private String cardid;
    private String address;
    private String pname;
    private String starttime;

    public Card() {
    }

    public Card(String cardid, String address, String pname, String starttime) {
        this.cardid = cardid;
        this.address = address;
        this.pname = pname;
        this.starttime = starttime;
    }

    public String getCardid() {
        return cardid;
    }

    public void setCardid(String cardid) {
        this.cardid = cardid;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public String getStarttime() {
        return starttime;
    }

    public void setStarttime(String starttime) {
        this.starttime = starttime;
    }

    @Override
    public String toString() {
        return "Card{" +
                "cardid='" + cardid + '\'' +
                ", address='" + address + '\'' +
                ", pname='" + pname + '\'' +
                ", starttime='" + starttime + '\'' +
                '}';
    }
}
```

Person实体类：	

```java
package com.iweb.model;

public class Person {
    private String pid;
    private String pname;
    private Integer age;
    private String gender;
    private Card card;


    public Person() {
    }

    public Person(String pid, String pname, Integer age, String gender, Card card) {
        this.pid = pid;
        this.pname = pname;
        this.age = age;
        this.gender = gender;
        this.card = card;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Card getCard() {
        return card;
    }

    public void setCard(Card card) {
        this.card = card;
    }

    @Override
    public String toString() {
        return "Person{" +
                "pid='" + pid + '\'' +
                ", pname='" + pname + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                ", card=" + card +
                '}';
    }

```

CardDao:

```java
package com.iweb.dao;

import com.iweb.model.Card;

public interface CardDao {

    //根据cardid查询一张身份证信息
    public Card queryById(String cardid);


}
```

CardDao.xml:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.CardDao">

    <select id="queryById" parameterType="java.lang.String" resultType="com.iweb.model.Card">
        select c.cardid, c.pname, c.address, date_format(c.starttime, '%Y-%m-%d') starttime
        from card c
        where c.cardid = #{cardid}
    </select>
</mapper>
```

PersonDao:

```java
package com.iweb.dao;

import com.iweb.model.Person;

public interface PersonDao {

    //根据pid查询一个人的信息,以及他的身份证信息
    public Person queryById(String pid);

}
```

PersonDao.xml:

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.iweb.dao.PersonDao">

    <!--  根据pid查询一个人的信息,以及他的身份证信息  -->
    <select id="queryById" parameterType="java.lang.String" resultMap="personResult">
        select *
        from person p
        where p.pid = #{pid}
    </select>

    <resultMap id="personResult" type="com.iweb.model.Person">
        <result property="pid" column="pid"></result>
        <result property="pname" column="pname"></result>
        <result property="age" column="age"></result>
        <result property="gender" column="gender"></result>
        <association property="card" column="cardid"
                     select="com.iweb.dao.CardDao.queryById"
                     javaType="com.iweb.model.Card"></association>
    </resultMap>
</mapper>
```

mybatis-config.xml中加两行：

```xml
<mappers>
    <mapper resource="com/iweb/dao/MyBook.xml"/>
    <mapper resource="com/iweb/dao/UserDao.xml"/>
    <mapper resource="com/iweb/dao/CardDao.xml"/>
    <mapper resource="com/iweb/dao/PersonDao.xml"/>
</mappers>
```

测试类：

```java
PersonDao pd = sqlSession.getMapper(PersonDao.class);
Person person = pd.queryById("p001");
System.out.println(person);
```

### 一对多级联查询

如果查询多的一端带出一的一端，还是使用`<association>`

如果查询一的一端带出多的一端，使用`<collection>`标签property对应成员变量，column对应关联字段，select对应多的一端表的关联查询语句的id，javatype为List，oftype为List中的泛型





