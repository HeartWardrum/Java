# 6-19

数字商务项目

# localhost 访问不跨域 但 127.0.0.1 访问跨域，你知道为什么吗？

## localhost：本地服务器，不经过网卡传输的，它不受网络防火墙和网卡相关的限制

127.0.0.1：本机地址是域名访问，通过网卡传输的，依赖网卡，并受到网络防火墙和网卡相关的限制。

1.PC端业务管理下的指标项根据市里每年变化会改变。

- [ ] 今年需隐藏“签约项目投资总额”、“亿元以上项目数”、“注册项目数”、“开工/运营数”，

- [ ] 新增“招引项目数”并将“开工/运营数”拆分为“开工项目数”和“运营项目数”。
- [ ] 模版下载只需要修改表格名称为上述新增项，单位均为“个”。钉钉端同步隐藏和新增。

2.首页数据显示同第1条，

- [ ] 隐藏“签约项目投资总额”、“亿元以上项目数”、“注册项目数”、“开工/运营数”，
- [ ] 新增“招引项目数”并将“开工/运营数”拆分为“开工项目数”和“运营项目数”。



# 绕过公司加密测试上传文件的方法

~~~java

File file1 = new File("D:\\test\\" + System.currentTimeMillis() + ".xlsx");
FileCopyUtils.copy(file.getBytes,file1);
InputStream inputStream = new FileInputStream(file1);
~~~



# 遇到问题：在idea中创建文件夹 "test.mapper"，创建的是一层文件夹，如果遇到使用mybatis时出现bindingException问题，可以看看是不是误以为是test文件夹下还有个mapper包



# 6-24

序 号 2 一 级 功 能 PC 端 钉 钉 端 二 级 功 能 业 务 管 理 市 表 管 理 首 页 导 出 图 表 功 能 首 页 招 商 引 资 

隐 藏 “ 签 约 项 目 投 资 总 额 ” 新 增 “ 招 引 项 目 数 ” 模 块 需 求 描 述 “ 亿 元 以 上 项 目 数 ” “ 注 册 项 目 数 ” 菜 单 “ 招 商 引 资 ” 模 块 模 版 设 置 中 隐 藏 “ 签 约 项 目 投 资 总 额 ” 整 个 大 列 ， 其 余 两 项 保 留 “ 亿 元 以 上 项 目 数 ” 更 名 为 “ 招 引 项 目 数 ” ， 模 版 设 置 中 表 格 标 题 也 更 改 为 “ 招 引 项 目 数 ” ， 第 二 列 “ 项 目 总 数 （ 个 ） ” 修 改 为 “ 招 引 项 目 数 （ 个 ） ” ， 隐 藏 第 四 列 “ 注 册 项 目 数 ” 栏 ， 保 留 开 工 运 营 数 ， 其 余 不 变 。 隐 藏 “ 签 约 项 目 投 资 总 额 ” 、 “ 亿 元 以 上 项 目 数 ” 、 “ 注 册 项 目 数 ” 新 增 “ 招 引 项 目 数 ” 模 块 数 据 展 示 、 数 据 统 计 表 pc 端 显 示 的 图 表 支 持 导 出 至 excel （ 或 可 编 辑 的 软 件 功 能 ） 功 能 。 主 要 是 包 括 项 目 数 柱 状 图 、 折 线 图 、 增 幅 折 线 图 隐 藏 “ 签 约 项 目 投 资 总 额 ” 、 “ 亿 元 以 上 项 目 数 ” 新 增 “ 招 引 项 目 数 ” 模 块 隐 藏 “ 签 约 项 目 投 资 总 额 ” 、 “ 亿 元 以 上 项 目 数 ” 新 增 “ 招 引 项 目 数 ” 模 块 数 据 展 示 、 数 据 统 计 表 “ 注 册 项 目 数 ” “ 注 册 项 目 数 ”



在Java中，使用包装类而不是基本类型作为主键（例如`pkid`）在某些情况下是有好处的。主要原因如下：

1. **null表示未赋值**：包装类（如`Integer`、`Long`等）可以为null，表示尚未分配主键值。这在插入新记录之前或主键值尚未从数据库中生成时特别有用。
2. **对象的灵活性**：包装类是对象，可以与Java的集合框架更好地配合使用。例如，`HashMap`的键不能是基本类型，但可以是包装类。
3. **ORM框架的支持**：大多数ORM框架（如Hibernate、MyBatis）推荐使用包装类，因为它们能够处理null值，从而更好地管理对象的生命周期。

### 修改主键为包装类示例

假设你有一个实体类`User`，其中`pkid`使用了基本类型`int`。可以将其改为包装类`Integer`。

# 6-26

山西法援律所律师信息接收接口

## 使用Stream时的冲突策略

~~~java
    public Map<String, String> getUsersMap() {
        List<SysUser> sysUsers = sysUserMapper.queryAll();
        
        // 使用流操作直接生成 Map，处理可能的重复键
        Map<String, String> map = sysUsers.stream()
            .filter(one -> StringUtils.hasText(one.getUsername()))
            .collect(Collectors.toMap(
                SysUser::getUsername,
                SysUser::getPassword,
                (existing, replacement) -> existing // 处理重复键的策略：保留现有的值
            ));

        return map;
    }
~~~

