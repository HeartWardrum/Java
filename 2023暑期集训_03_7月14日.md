# 2023年7月14日

## equals(对象)

判断当前对象是否与传入对象相等

Object的equals(对象) ---- 它判断的是两个对象是否是同一个对象，只有同一个对象才认为相等，否则都是不等。所以我们通常需要对Object类的equals方法进行重写，把我们自己认为相等的标准写入equals()

一般来讲，我们都会以成员变量值全部相等，作为相等的标准。

~~~java
public class Cat {

    int color;
    int height;
    int weight;

    public Cat(int color, int height, int weight) {
        this.color = color;
        this.height = height;
        this.weight = weight;
    }

    @Override
    public boolean equals(Object obj) {
        if (null == obj) {
            return false;
        }
        if (!(obj instanceof Cat)) {
            return false;
        } else {
            Cat c = (Cat) obj;
            if (c.color == this.color && c.height == this.height &&
                    c.weight == this.weight) {
                return true;
            } else {
                return false;
            }
        }

    }
}

//test
public class Test {


    public static void main(String[] args) {
        int i = 100;
        int j = 100;
        System.out.println(i == j);//true

        Cat c1 = new Cat(999, 12, 12);
        Cat c2 = new Cat(999, 12, 12);
        System.out.println(c1 == c2);//false
        System.out.println(c1.equals(c2));//true
    }
}

~~~

## final

它可以用来修饰一个类，表示该类不能被继承

它可以用来修饰一个方法，表示该方法不能被重写

它可以用来修饰一个变量，表示该变量值不能改

## 常量

~~~java
public static final 常量类型 常量名
~~~

## 接口

接口中的方法都是抽象方法，它使用interface定义

接口中的方法默认都是public的

接口是抽象方法和常量的集合

类可以通过implements来实现接口，实现接口就必须要重写接口中所有的抽象方法。

在调用的时候，我们可以通过接口类型的引用指向其实现类的对象。当我们使用该引用调用接口类的方法，实际执行的是实现类中重写的方法，所以接口也具有多态性

一个接口可以被多个无关的类实现
一个类可以同时实现多个无关的接口
如果接口的引用指向实现类的对象，那么该引用只能访问当前接口中的方法

## 异常处理

~~~java
try{
    可能抛出异常的代码
}catch (异常类型 变量名){
    当抛出该异常类型对象时的处理语句
}
~~~

## throws 

当我们的方法可能抛出某个异常时，我们不作处理，使用throws抛给调用者来处理

~~~java
public class Test3 {


    public static void main(String[] args) {
        f(10);
    }

    public static void f(int i) throws ArithmeticException {
        int res = 0;
        res = 100 / i;
        System.out.println(res);
    }
}
~~~

## throw

手动抛一个异常

~~~java
public class Test3 {


    public static void main(String[] args) {
        try {
            f(0);
        } catch (ArithmeticException e) {
            System.out.println("除数不能为0");
        }
        
    }

    public static void f(int i) throws ArithmeticException {
        int res = 0;
        if (0 == i) {
            System.out.println("开始抛异常...");
            throw new ArithmeticException();
        }
        System.out.println("正常计算...");
        res = 100 / i;
        System.out.println(res);
    }
}
~~~

所有异常类的结构图：

![https://res.cloudinary.com/dvqgs9esp/image/upload/v1689314013/javaStudy/%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE_sw0vzq.jpg](https://res.cloudinary.com/dvqgs9esp/image/upload/v1689314013/javaStudy/所有异常类的结构图_sw0vzq.jpg)

### 常见异常

1. NullPointerException (空指针异常)：当试图在一个空对象上调用方法或访问属性时抛出。
2. IllegalArgumentException (非法参数异常)：当传递给方法的参数不合法时抛出，例如传递了不允许的值或无效的参数。
3. ArrayIndexOutOfBoundsException (数组索引越界异常)：当访问数组中不存在的索引时抛出。
4. ArithmeticException (算术异常)：当发生数学运算错误时抛出，例如除数为零。
5. ClassCastException (类转换异常)：当试图将一个对象强制转换为不兼容的类时抛出。
6. IllegalStateException (非法状态异常)：当对象处于不允许的状态时抛出，例如在调用方法之前或之后。
7. IOException (输入输出异常)：处理输入和输出操作时可能发生的异常，例如文件读写错误。
8. FileNotFoundException (文件未找到异常)：当试图打开不存在的文件时抛出。
9. InterruptedException (中断异常)：当线程在等待、休眠或阻塞状态时被中断时抛出。
10. UnsupportedOperationException (不支持操作异常)：当不支持的操作或方法被调用时抛出。

运行时异常在编译的时候可以不做处理，而编译通过。

非运行时异常在编译的时候，必须try catch 或者throws，否则编译报错

读取文件：

~~~java
    public static void main(String[] args) {
        InputStream is = null;
        try {
            is = new FileInputStream("D:\\java\\MyProject\\test20230714\\src\\com\\iweb\\test\\Test4.java");
            int i = 0;
            while ((i = is.read()) != -1) {
                System.out.print((char) i);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
~~~

## finally

它是跟在try catch后面的第三个代码块，表示无论是否抛异常，都一定要执行的代码

注意：当finally代码块之前执行了return语句，那么，finally代码块中的代码也一定会执行，而且会在return之前执行

注意：当一个try代码块对应多个catch代码的时候，catch代码块的先后顺序要求先捕获子类异常，后捕获父类异常

### 面试题

final、finally、finalize三个单词有什么区别



finalize：垃圾回收器调用的一个方法的方法名

## String

字符串，不可变的字符序列

字符串是常量，存放在常量区

注意：做项目的过程中，凡是牵涉到字符串的比较，一律使用equals()

new String("hello");  ---- 创建了两个对象，现在常量池创建"hello"，然后再拷贝一份到堆内存

~~~java
    public static void main(String[] args){
        String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1 == s2);//true
        String s3 = "he" + "llo";
        System.out.println(s1 == s3);//true
        String s4 = new String("hello");
        System.out.println(s1 == s4);//false
        System.out.println(s1.equals(s4));//true
    }
~~~

常用方法

~~~java
        String s2 = "hello";
        System.out.println(s2.charAt(4));//o
        System.out.println(s2.endsWith("llo"));//true
        System.out.println(s2.endsWith("hel"));//false
        System.out.println(s2.endsWith(""));//true
        String s5 = "HELLO";
        System.out.println(s2.equals(s5));//false
        System.out.println(s2.equalsIgnoreCase(s5));//true
        System.out.println(s2.indexOf("o"));//4
        System.out.println(s2.isEmpty());//false
        String s6 = "";
        System.out.println(s6.isEmpty());//true
        System.out.println(s2.length());//5


        String s7 = s2.replace("ll", "LL");
        System.out.println(s7);//heLLo
        System.out.println(s2);//hello  常量是不会变的
        String s8 = "Java,Oracle,Html,Servlet,Spring,Vue";
        String[] arr = s8.split(",");
        for(int i = 0;i < arr.length;i++){
            System.out.print(arr[i] + "  ");
        }//Java  Oracle  Html  Servlet  Spring  Vue
        String s9 = s2.substring(0,4);
        System.out.println();
        System.out.println(s9);//hell
        String s10 = s2.toUpperCase();
        System.out.println(s10);//HELLO
        String s11 = s10.toLowerCase();
        System.out.println(s11);//hello
        String s12 = "         sfaf      ";
        String s13 = s12.trim();//无法去除字符串中间的空格
        System.out.println(s13);//sfaf
        System.out.println(s12);//         sfaf
        Cat c = new Cat();
        String s14 = String.valueOf(c);
        System.out.println(s14);//com.iweb.test.Cat@745f
~~~

注意：trim()无法去除字符串中间的空格，要用以下方法：

~~~java
        String s15 = "  hello my  friend  ";
        String s16 = s15.replaceAll("\\s+","");
        System.out.println(s16);
//使用了正则表达式\\s+来匹配一个或多个连续的空格，并将其替换为空字符串，从而实现去除空格的效果。
~~~

## 加密算法

使用 `DigestUtils.md5Hex(明文)`;

~~~java
    public static void main(String[] args) {
        String s1 = "123456";
        String s2 = DigestUtils.md5Hex(s1);
        System.out.println(s2);//e10adc3949ba59abbe56e057f20f883e
    }
~~~



sha256加密 ---- 使用`DigestUtils.sha256Hex(明文)`

~~~java
        String s3 = DigestUtils.sha256Hex(s1);
        System.out.println(s3);
~~~

## StringBuffer

可变的字符序列，它里面的字符串内容可以被改变

append(字符串) ---- 将传入的字符串追加到当前字符串后面

insert(下标，字符串) ---- 将传入的字符串插入指定下标

delete(起始下标，结束下标) ---- 删除指定下标位置开始到指定下标位置结束的子字符

~~~Java
    public static void main(String[] args){
        StringBuffer stringBuffer = new StringBuffer("hello");
        stringBuffer.append(" world");
        System.out.println(stringBuffer);//hello world
        stringBuffer.insert(3,"Tom");
        System.out.println(stringBuffer);//helTomlo world
        stringBuffer.delete(3,6);//从下标为3删到下标为6
        System.out.println(stringBuffer);//hello world

    }
~~~

## StringBuilder

和StringBuffer类似，也是可变字符序列

StringBuffer和StringBuilder的区别：

- StringBuffer是线程同步的，在多线程的项目中，安全性高，但是效率低
- StringBuilder是线程不同步的，在多线程的项目中，安全性低，但效率高

## Math

数学相关的类

sqrt ---- 平方根

random ---- [0.0,1.0) 的随机小数

abs ---- 绝对值

round ---- 四舍五入求整数部分

max ---- 最大值

min ---- 最小值

# 2023年7月15日

## Date

日期类，创建出Date对象表示当前时间，我们可以使用SimpleDateFormat对象来定义年月日时分秒的格式，格式中：y表示年，M表示月，d表示日，h表示小时，m表示分钟，s表示秒

我们可以使用SimpleDateFormat对象调用format方法传入Date对象得到符合该格式的日期字符串。

~~~java
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);//Sat Jul 15 09:19:13 CST 2023
        SimpleDateFormat sdf =
                new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
        String s = sdf.format(date);
        System.out.println(s);//2023-07-15 09-19-13
    }
~~~



## BigDecimal

大数值型，它可以在项目中进行算数运算，它的底层是字符串，没有长度限制，它也没有浮点型精度误差的问题，它提供了一些方法供我们调用：

add() ---- 加法

subtract() ---- 减法

multiply() ---- 乘法

divide() ---- 除法，在除法中，第二个参表示小数位，第三个参表示保留方式，ROUND_HALF_UP表示四舍五入的方式

计算结果也是BigDecimal对象，我们可以调用它的xxxValue()转成基本数据类型

~~~java
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);//Sat Jul 15 09:19:13 CST 2023
        SimpleDateFormat sdf =
                new SimpleDateFormat("yyyy-MM-dd hh-mm-ss");
        String s = sdf.format(date);
        System.out.println(s);//2023-07-15 09-19-13


        double d1 = 1.0;
        double d2 = 3.0;
        BigDecimal b1 = new BigDecimal(String.valueOf(d1));
        BigDecimal b2 = new BigDecimal(String.valueOf(d2));
        BigDecimal res = b1.add(b2);
        System.out.println(res);//4.0
        double resultDouble = res.doubleValue();
        System.out.println(resultDouble);//4.0

        BigDecimal res2 = b2.subtract(b1);
        System.out.println(res2);//2.0

        BigDecimal res3 = b1.multiply(b2);
        System.out.println(res3);//3.00

        BigDecimal res4 = b1.divide(b2, 5, BigDecimal.ROUND_HALF_UP);
        System.out.println(res4);//0.33333


    }
~~~

## 枚举型

使用enum来定义该类型，该类型的变量只能在指定的若干值中间获取

定义格式：

~~~java
enum 枚举类型名{
    值1，值2...
}
~~~

定义变量并初始化：

枚举类型 变量名 = 枚举类型.值

~~~java
public enum MyColor {
    red,blue,green,yello
}
~~~

~~~java
        MyColor m = MyColor.blue;
        System.out.println(m);//blue
        switch (m) {
            case red:
                System.out.println("红色");
                break;
            case green:
                System.out.println("绿色");
                break;
            case blue:
                System.out.println("蓝色");
                break;
            default:
                System.out.println("黄色");
                break;
        }
~~~

## 基本数据类型包装类

java中针对8种基本数据类型，分别提供了各自的包装类

当传入参数需要用到对象而不是数值的时候，就轮到包装类上场了

Integer ---- int

Character ---- char

剩下的6种，首字母转大写即可

创建包装类的对象，之许哟啊将基本数据类型数值传入包装类的构造方法即可

从包装类对象种取出基本数据类型数值只需要调用xxxValue()即可

valueOf(字符串) ---- 将字符串中的数值取出获取最基本数据类型的包装类对象

parseXxx(字符串) ---- 将字符串中的数值取出获取该基本数据类型的数值

~~~java
    public static void main(String[] args) {
        Integer integer = new Integer(100);
        System.out.println(integer);
        int i = integer.intValue();//Integer  -> int
        System.out.println(i);

        String s = String.valueOf(i);//int -> String
        System.out.println(s);

        Integer integer1 = Integer.valueOf(s);//String  -> Integer
        System.out.println(integer1);
        
        //Integer.parseInt()
        int i1 = Integer.parseInt(s);//String -> int
        System.out.println(i1);

    }
~~~

注意：如果从字符串中解析数值，则该字符串中的数值必须符合类型规范，否则会抛出NumberFormatException异常

成员变量只声明未初始化在类初始化时会赋予默认值可以直接使用；局部变量必须赋值才可以使用，如果局部变量未赋值，**编译无法通过**。

基本数据类型的包装类对象的默认值为null



## 集合

常用的集合类：

List ---- 这是一个接口，里面存放的元素都是有序的，可重复的

List接口有一个ArrayList的实现类，它的底层是数组

add(对象) ---- 添加元素

size() ---- 获取List中元素的个数

get(下标) ---- 根据下标获取该下标位置的元素

contains(对象) ---- 判断当前集合是否包含指定对象

remove(对象) ---- 从当前集合中删除指定对象

注意：不管是contains还是remove，传入的对象，都需要和当前集合中的某个对象相互equals才能完成操作

~~~java
		//Student类中必须重写equals方法，才能使用contains和remove方法
        System.out.println(list.contains(
                new Student("1000", "zhangsan", 12)));
        System.out.println(list.remove(
                new Student("1000", "zhangsan", 12)));
            
~~~

Iterator ---- 迭代器，它是foreach循环的底层原理，我们可以通过iterator()来获取当前集合的迭代器

常用方法：

hasNext() ---- 判断是否迭代结束

next() ---- 迭代下一个元素

remove() ---- 删除当前正vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv在被迭代的元素，注意：必须先调用一次next()之后才可以调用remove()进行删除

~~~java
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object o = iterator.next();//迭代下一个元素
            System.out.println(o);
            iterator.remove();
        }
~~~

## Set

是个接口，里面存放的元素是无序的，不可重复的

常用方法：

add(对象) ---- 添加元素

~~~java
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(new Student("1000", "zhangsan", 12));
        set.add("hello");


        System.out.println(set.size());
        System.out.println(set);

        for (Object o : set) {
            System.out.println(o);
        }

    }
~~~

